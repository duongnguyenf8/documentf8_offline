## background gradient là gì?

Background gradient là một thuộc tính CSS cho phép chúng ta tạo ra các gradient nền cho các phần tử HTML. Gradient là một hiệu ứng hình ảnh chuyển tiếp từ màu này sang màu khác.

Background gradient có thể được sử dụng để tạo ra các hiệu ứng hình ảnh đẹp mắt và chân thực cho các trang web.

Ví dụ, chúng ta có thể sử dụng background gradient để tạo ra một nền chuyển tiếp từ màu xanh sang màu trắng, hoặc tạo ra một nền chuyển tiếp từ màu tím sang màu cam.

---

## Cách sử dụng Background Gradient

Gradient là một hiệu ứng giúp tạo ra sự chuyển màu mượt mà từ một màu sang màu khác. Gradient có thể được sử dụng cho nhiều mục đích khác nhau, chẳng hạn như tạo ra một background đẹp mắt, làm nổi bật một phần tử trên trang web hoặc tạo ra một hiệu ứng chuyển động.

Có hai loại gradient chính trong CSS: gradient tuyến tính(linear-gradient) và gradient hình cầu(radial-gradient).

- **linear-gradient** là gradient được tạo ra từ hai điểm. Điểm bắt đầu của gradient được gọi là điểm đầu và điểm kết thúc của gradient được gọi là điểm cuối. Linear-gradient có thể được sử dụng để tạo ra một hiệu ứng chuyển màu theo **một đường thẳng**.

- **radial-gradient** là gradient được tạo ra từ một điểm. Điểm bắt đầu của gradient được gọi là điểm tâm và gradient hình cầu sẽ lan tỏa ra xung quanh điểm tâm. Radial-gradient có thể được sử dụng để tạo ra một hiệu ứng chuyển màu theo **một vòng tròn**.

Để sử dụng gradient, chúng ta cần sử dụng thuộc tính `background-image` và định nghĩa gradient trong thuộc tính `background-image`. Định nghĩa gradient bao gồm các thuộc tính sau:

- **gradient-type:** Loại gradient. Có thể là `linear-gradient` hoặc `radial-gradient`.

- **start-point:** Điểm bắt đầu của gradient. Có thể là `left` hoặc `right` cho gradient tuyến tính và `center` hoặc `top` cho gradient hình cầu.

- **end-point:** Điểm kết thúc của gradient. Có thể là `right` hoặc `left` cho gradient tuyến tính và `bottom` hoặc `top` cho gradient hình cầu.

- **color-stops:** Các màu của gradient. Có thể được định nghĩa bằng cách sử dụng giá trị hex, tên màu hoặc mã RGB.

Ví dụ: sau đây là định nghĩa của một gradient tuyến tính với hai màu:

<htmlcss-snippet>

```html
<div class="container"></div>
<style>
  .container {
    width: 100vw;
    height: 100vh;
    background-image: linear-gradient(to right, red, blue);
  }
</style>
```

</htmlcss-snippet>

Gradient này sẽ tạo ra một hiệu ứng chuyển màu từ đỏ sang xanh theo chiều từ trái sang phải.

Chúng ta cũng có thể sử dụng thuộc tính `angle` để định nghĩa góc của gradient. Giá trị của thuộc tính `angle` là góc tính từ chiều dọc của trang web.

---

Ví dụ: sau đây là định nghĩa của một gradient hình cầu với hai màu và góc là 45 độ:

<htmlcss-snippet>

```html
<div class="container"></div>
<style>
  .container {
    width: 100vw;
    height: 100vh;
    background-image: linear-gradient(45deg, red, blue);
  }
</style>
```

</htmlcss-snippet>

Gradient này sẽ tạo ra một hiệu ứng chuyển màu từ đỏ sang xanh theo một góc 45 độ.

Chúng ta cũng có thể sử dụng thuộc tính `color-stop` để định nghĩa nhiều màu cho gradient.

---

Ví dụ: sau đây là định nghĩa của một gradient tuyến tính với ba màu:

<htmlcss-snippet>

```html
<div class="container"></div>
<style>
  .container {
    width: 100vw;
    height: 100vh;
    background-image: linear-gradient(to right, red 30%, green 50%, blue 70%);
    background-repeat: no-repeat;
  }
</style>
```

</htmlcss-snippet>

Gradient này sẽ tạo ra một hiệu ứng chuyển màu từ đỏ sang xanh với điểm dừng màu xanh ở 50% của chiều rộng của gradient.

Cuối cùng, chúng ta có thể sử dụng thuộc tính `background-repeat` để định nghĩa cách gradient được lặp lại. Giá trị của thuộc tính `background-repeat` có thể là `no-repeat`, `repeat-x`, `repeat-y` hoặc `repeat`. Giá trị `no-repeat` sẽ khiến gradient không được lặp lại. Giá trị `repeat-x` sẽ khiến gradient được lặp lại theo chiều ngang. Giá trị `repeat-y` sẽ khiến gradient được lặp lại theo chiều dọc. Giá trị `repeat` sẽ khiến gradient được lặp lại theo cả chiều ngang và chiều dọc.

---

## Background gradient có phải chỉ để làm background chuyển màu mượt mà?

Thuộc tính **color-stop** được định nghĩa là khoảng mà ở đó, color sẽ không bị chuyển màu. Sau khoảng đó màu sẽ ngưng phủ và khoảng trống còn lại để pha màu với màu tiếp theo. Vì thế. Nếu khoảng cách 2 **color-stop** bằng nhau hoặc chờm qua nhau thì màu sẽ không thể pha vào nhau. Khi đó, chúng ta có một background 2 màu cắt nhau mà không có chuyển màu.

<htmlcss-snippet>

```html
<div class="container"></div>
<style>
  .container {
    width: 100vw;
    height: 100vh;
    background-image: linear-gradient(to right, red 50%, blue 50%);
  }
</style>
```

</htmlcss-snippet>

**Background gradient thực chất là một "ảnh đặc biệt" chứ không phải một background màu nên không thể sử dụng background-color**

---

## Thuộc tính transition

Transition là một thuộc tính CSS cho phép chúng ta tạo ra các hiệu ứng chuyển tiếp cho các thuộc tính CSS. Transition là một cách tuyệt vời để làm cho các trang web của chúng ta trở nên sống động và hấp dẫn hơn.

Để sử dụng transition, chúng ta cần sử dụng thuộc tính `transition` và định nghĩa các thuộc tính CSS mà chúng ta muốn chuyển tiếp. Sau đó, chúng ta cần định nghĩa thời gian chuyển tiếp bằng thuộc tính `transition-duration`.

---

## Xây dựng hiệu ứng với thuộc tính transition

Ví dụ, đoạn code CSS sau sẽ tạo ra một hiệu ứng chuyển tiếp cho thuộc tính `width` của phần tử `div`:

<htmlcss-snippet>

```html
<div class="box1">
  <span>box1</span>
</div>
<div class="box2">
  <span>box2</span>
</div>
<style>
  .box1 {
    width: 100px;
    height: 100px;
    background-color: red;
  }
  .box2 {
    width: 100px;
    height: 100px;
    background-color: blue;
    transition: width 2s ease-in-out;
  }
  .box1:hover {
    width: 300px;
  }
  .box2:hover {
    width: 300px;
  }
</style>
```

</htmlcss-snippet>

Trong ví dụ trên, thuộc tính `transition` được sử dụng để định nghĩa rằng thuộc tính `width` của phần tử `div` sẽ chuyển tiếp trong 2 giây. thuộc tính `ease-in-out` được sử dụng để định nghĩa rằng hiệu ứng chuyển tiếp sẽ bắt đầu chậm, sau đó tăng tốc và cuối cùng chậm lại khi kết thúc.

Chúng ta cũng có thể định nghĩa thời gian chuyển tiếp cho các thuộc tính CSS khác, chẳng hạn như `height`, `color`, `background-color`, `font-size`, và nhiều thuộc tính khác.

Transition là một thuộc tính CSS rất mạnh mẽ và linh hoạt. Chúng ta có thể sử dụng nó để tạo ra nhiều hiệu ứng chuyển tiếp khác nhau cho các trang web của mình.

---

Dưới đây là một số ví dụ về cách sử dụng transition:

- Chúng ta có thể sử dụng transition để tạo ra một hiệu ứng khi người dùng di chuột qua các phần tử trên trang web.

<htmlcss-snippet>

```html
<button>Hover me</button>
<style>
  button {
    padding: 10px 20px;
    background-color: red;
    color: white;
    border: none;
    transition: background-color 0.5s ease-in-out;
  }
  button:hover {
    background-color: blue;
  }
</style>
```

</htmlcss-snippet>

---

- Chúng ta có thể sử dụng transition để tạo ra một hiệu ứng khi người dùng nhấp vào các nút.

<htmlcss-snippet>

```html
<button>Click me</button>
<style>
  button {
    padding: 10px 20px;
    background-color: red;
    color: white;
    border: none;
    transition: background-color 0.3s ease-in-out;
  }
  button:active {
    background-color: blue;
  }
</style>
```

</htmlcss-snippet>

---

- Chúng ta có thể sử dụng transition để tạo ra một hiệu ứng khi người dùng nhập dữ liệu vào các ô input.

<htmlcss-snippet>

```html
<input type="text" placeholder="Focus me!" />
<style>
  input {
    padding: 10px 20px;
    background-color: red;
    color: white;
    border: none;
    transition: background-color 0.5s ease-in-out;
  }
  input:focus {
    background-color: blue;
  }
</style>
```

</htmlcss-snippet>

---

- Chúng ta có thể sử dụng transition để tạo ra một hiệu ứng khi người dùng di chuột qua các liên kết.

Với một chút sáng tạo, chúng ta có thể sử dụng transition để tạo ra những hiệu ứng tuyệt vời cho các trang web của mình.

<htmlcss-snippet>

```html
<a href="#">Hover Me!</a>
<style>
  a {
    background-image: linear-gradient(to right, #54b3d6, #54b3d6 50%, #333 50%);
    background-size: 200% 100%;
    background-position: -100%;
    display: inline-block;
    padding: 5px 0;
    position: relative;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    transition: 0.3s ease-in-out;
    transition-property: background-position;
  }
  a:before {
    content: "";
    background: #54b3d6;
    display: block;
    position: absolute;
    bottom: -3px;
    left: 0;
    width: 0;
    height: 3px;
    transition: 0.3s ease-in-out;
    transition-property: width;
  }
  a:hover {
    background-position: 0;
  }
  a:hover::before {
    width: 100%;
  }
  body {
    display: grid;
    font-size: 30px;
    font-weight: 700;
    max-height: 100vh;
    place-items: center;
  }
</style>
```

---

> Transition là một thuộc tính CSS cho phép chúng ta tạo ra các hiệu ứng chuyển tiếp cho các thuộc tính CSS. Transition là một cách tuyệt vời để làm cho các trang web của chúng ta trở nên sống động và hấp dẫn hơn.

Dưới đây là một số hiệu ứng transition phổ biến trong trang web hiện nay:

---

## Điều chỉnh kích thước

Chúng ta có thể sử dụng transition để điều chỉnh kích thước của các phần tử trên trang web, chẳng hạn như tăng hoặc giảm kích thước của một nút khi người dùng di chuột qua nó.

**Ví dụ:**

<htmlcss-snippet>

```html
<button>Hover me</button>
<style>
  button {
    padding: 10px 20px;
    background-color: red;
    color: white;
    border: none;
    transition: transform 0.5s ease-in-out;
  }
  button:hover {
    transform: scale(1.2);
  }
</style>
```

</htmlcss-snippet>

---

## Điều chỉnh vị trí

Chúng ta cũng có thể sử dụng transition để điều chỉnh vị trí của các phần tử trên trang web, chẳng hạn như di chuyển một nút khi người dùng di chuột qua nó.

**Ví dụ:**

<htmlcss-snippet>

```html
<button>Hover me</button>
<style>
  button {
    padding: 10px 20px;
    background-color: red;
    color: white;
    border: none;
    transition: transform 0.5s ease-in-out;
  }
  button:hover {
    transform: translateX(100px);
  }
</style>
```

</htmlcss-snippet>

---

## Điều chỉnh màu sắc

Chúng ta có thể sử dụng transition để điều chỉnh màu sắc của các phần tử trên trang web, chẳng hạn như thay đổi màu sắc của một nút khi người dùng di chuột qua nó.

**Ví dụ:**

<htmlcss-snippet>

```html
<button>Hover me</button>
<style>
  button {
    padding: 10px 20px;
    background-color: red;
    color: white;
    border: none;
    transition: background-color 0.5s ease-in-out;
  }
  button:hover {
    background-color: blue;
  }
</style>
```

</htmlcss-snippet>

---

## Điều chỉnh độ trong suốt

Chúng ta có thể sử dụng transition để điều chỉnh độ mờ của các phần tử trên trang web, chẳng hạn như làm mờ một nút khi người dùng di chuột qua nó.

**Ví dụ:**

<htmlcss-snippet>

```html
<button>Hover me</button>
<style>
  button {
    padding: 10px 20px;
    background-color: red;
    color: white;
    border: none;
    opacity: 0.5;
    transition: opacity 0.5s ease-in-out;
  }
  button:hover {
    opacity: 1;
  }
</style>
```

</htmlcss-snippet>

---

## Điều chỉnh độ mờ

Chúng ta có thể sử dụng transition để điều chỉnh độ trong suốt của các phần tử trên trang web, chẳng hạn như làm trong suốt một nút khi người dùng di chuột qua nó.

**Ví dụ:**

<htmlcss-snippet>

```html
<img src="https://picsum.photos/200/300" alt="image" />
<style>
  img {
    filter: blur(5px);
    transition: filter 0.5s ease-in-out;
  }
  img:hover {
    filter: blur(0);
  }
</style>
```

</htmlcss-snippet>

Đây chỉ là một vài trong số rất nhiều hiệu ứng transition phổ biến trong trang web hiện nay.

Với một chút sáng tạo, chúng ta có thể sử dụng transition để tạo ra những hiệu ứng tuyệt vời cho các trang web của mình.

---

## Lưu ý khi sử dụng transition

- **Hoạt động vẽ lại của trình duyệt**

  Khi người dùng tương tác với một trang web, trình duyệt sẽ phải vẽ lại trang web đó. Quá trình vẽ lại này bao gồm một số bước:

  1. Trình duyệt sẽ lấy nội dung của trang web từ máy chủ.

  2. Trình duyệt sẽ giải mã nội dung HTML, CSS và JavaScript của trang web.

  3. **DOM Tree**

  - Trình duyệt tạo ra Document Object Model - một cây bao gồm các đối tượng trong HTML Document, mỗi node của cây tượng trưng cho một HTML tag.

  4. **CSSOM Tree**

  - Sau khi tạo ra DOM tree, trình duyệt tiếp tục tao ra CSSOM (CSS Object Model) - giống như DOM nhưng nó dành cho CSS. Về cơ bản nó “map” các CSS style được cài đặt cho webpage.

  5. **Layout**

  - Sau khi hoàn tất quá trình này trình duyệt của chúng ta biết được CSS nào tương ứng với thành phần nào và sẽ tiếp tục tính toán không gian chiếm dụng và nó nằm ở đâu trên màn hình.

  6.  **Paint**

  - Painting là một tiến trình tô từng pixels trên màn hình và DevTools cũng cung cấp một option để minh họa quá trình này

  7.  **Composite**

  - Trong bước này, trình duyệt kết hợp tất cả các lớp với nhau. Đây là một quá trình quan trọng, đặc biệt là đối với các yếu tố động. Mọi sai lầm ở bước này có thể gây ra trường hợp như là một phần tử sẽ xuất hiện chồng lên phần tử khác không chính xác.

  **layout -> paint -> compose**

  - Một ví dụ cho trường hợp đầu tiên là tác động của người dùng dẫn đến thay đổi chiều rộng của một thành phần. Khi đó trình duyệt của chúng ta cần tính lại vị trí cho các thành phần trên màn hình bởi một thành phần thay đổi cũng ảnh hưởng đến các thành phần khác.

  **paint -> compose**

  - Ví dụ chúng ta thay đổi màu nền thì sẽ không có sự thay đổi nào về layout cả nên trình duyệt sẽ chỉ cần xử lý lại từ bước painting.

  **compose**

  - Nếu chúng ta biến đổi một thành phần không liên quan đến màu sắc (transform), trình duyệt chỉ cần thực hiện lại việc compose.

  Tham khảo [freecodecamp.org/news/web-animation-performance-fundamentals](https://www.freecodecamp.org/news/web-animation-performance-fundamentals/)

  Các thuộc tính CSS sau đây sẽ khiến trình duyệt vẽ lại toàn bộ trang web:

  - `width`
  - `height`
  - `position`
  - `top`
  - `left`
  - `right`
  - `bottom`
  - `margin`
  - `padding`
  - `border`
  - `...`

  Các thuộc tính CSS sau đây sẽ khiến trình duyệt chỉ tô lại các phần tử của trang web mà bị thay đổi:

  - `color`
  - `background-color`
  - `opacity`
  - `transform`
  - `...`

  Các phương thức CSS như `opacity`, `transform`,... được trình duyệt hỗ trợ như nào?

  - Trình duyệt sẽ tạo ra một lớp mới cho phần tử đó và chỉ tô lại lớp đó. Điều này sẽ giúp trình duyệt tối ưu hóa việc vẽ lại trang web và giúp trang web hoạt động mượt mà hơn.

- **Việc sử dụng transition hợp lý ảnh hưởng tốt thế nào tới trang web so với sử dụng transition bừa bãi và sử dụng transition-property là all**

  Việc sử dụng transition hợp lý sẽ giúp trang web hoạt động mượt mà và hiệu quả hơn. Điều này là do transition sẽ giúp trình duyệt vẽ lại các phần tử của trang web một cách dần dần, thay vì vẽ lại toàn bộ trang web một cách đột ngột. Điều này sẽ giúp giảm thiểu độ giật và lag của trang web, đồng thời giúp cải thiện trải nghiệm người dùng.

  Sử dụng transition bừa bãi hoặc sử dụng `transition-property` là `all` sẽ khiến trang web hoạt động chậm hơn và gây ra độ giật và lag. Điều này là do trình duyệt sẽ phải vẽ lại toàn bộ trang web một cách đột ngột khi có bất kỳ thay đổi nào về các thuộc tính CSS. Điều này sẽ làm cho trang web trở nên khó sử dụng và trải nghiệm người dùng sẽ bị ảnh hưởng xấu.

- **Việc sử dụng transition bừa bãi ảnh hưởng xấu tới trải nghiệm người dùng như thế nào so với việc sử dụng ít hơn nhưng hiệu quả**

  Việc sử dụng transition bừa bãi sẽ khiến trang web trở nên khó sử dụng và trải nghiệm người dùng sẽ bị ảnh hưởng xấu. Điều này là do transition sẽ khiến trang web hoạt động chậm hơn và gây ra độ giật và lag. Ngoài ra, việc sử dụng transition bừa bãi sẽ khiến trang web trở nên rối mắt và khó tập trung.

  Sử dụng ít hơn nhưng hiệu quả sẽ giúp trang web hoạt động mượt mà và hiệu quả hơn. Điều này là do chúng ta chỉ sử dụng transition cho các phần tử của trang web cần thiết và chúng ta sử dụng các thuộc tính CSS phù hợp để tạo ra các hiệu ứng transition đẹp mắt và hấp dẫn.

- **Lưu ý khi sử dụng transition**

  Khi sử dụng transition, chúng ta cần lưu ý một số điều sau:

  - Sử dụng transition cho các phần tử của trang web cần thiết.
  - Sử dụng các thuộc tính CSS phù hợp để tạo ra các hiệu ứng transition đẹp mắt và hấp dẫn.
  - Không sử dụng transition quá nhiều sẽ khiến trang web trở nên khó sử dụng và trải nghiệm người dùng sẽ bị ảnh hưởng xấu.

---

## Thuộc tính `transform`

- Định nghĩa: Thuộc tính `transform` trong CSS cho phép chúng ta biến đổi, xoay, co giãn hoặc biến đổi hình dạng các phần tử HTML.
- Cú pháp: `transform: <transform-function>`
- Các giá trị của `<transform-function>`:

  - `translate()`: Dịch chuyển phần tử theo trục X và trục Y.

    - Trong đó có 2 giá trị:
      - `translateX()`: Dịch chuyển phần tử theo trục X.
      - `translateY()`: Dịch chuyển phần tử theo trục Y.
      ***

  - `scale()`: Thay đổi tỷ lệ kích thước của phần tử.
    - Trong đó có 2 giá trị:
      - `scaleX()`: Thay đổi tỷ lệ kích thước của phần tử theo trục X.
      - `scaleY()`: Thay đổi tỷ lệ kích thước của phần tử theo trục Y.
      ***
  - `rotate()`: Xoay phần tử theo góc quay.
    - Trong đó có 2 giá trị:
      - `rotateX()`: Xoay phần tử theo trục X.
      - `rotateY()`: Xoay phần tử theo trục Y.
      ***
  - `skew()`: Nghiêng phần tử theo trục X và trục Y.
    - Trong đó có 2 giá trị:
      - `skewX()`: Nghiêng phần tử theo trục X.
      - `skewY()`: Nghiêng phần tử theo trục Y.
      ***
  - `matrix()`: Kết hợp các phép biến đổi tùy chỉnh.
  - Và còn nhiều giá trị khác nữa.

- Các giá trị của `<transform-function>` có thể được kết hợp với nhau để tạo ra các hiệu ứng phức tạp.

- Thuộc tính `transform-origin` được sử dụng để định nghĩa điểm bắt đầu của phần tử khi thực hiện các phép biến đổi.

  - Ví dụ ở đây chúng ta sẽ định nghĩa điểm bắt đầu của phần tử là `top left`:

  <htmlcss-snippet>

  ```html
  <div class="box"></div>

  <style>
    .box {
      width: 100px;
      height: 100px;
      background-color: red;
      transform-origin: top left;
      transition: transform 0.5s ease-in-out;
    }
    .box:hover {
      transform: rotate(45deg);
    }
  </style>
  ```

  </htmlcss-snippet>

---

- Thuộc tính `transform-style` được sử dụng để định nghĩa cách các phần tử con của phần tử đang được biến đổi sẽ được hiển thị.

  - Ví dụ ở đây chúng ta sẽ định nghĩa cách các phần tử con của phần tử đang được biến đổi sẽ được hiển thị là `preserve-3d`:

  <htmlcss-snippet>

  ```html
  <div class="box">
    <div class="box-child"></div>
  </div>

  <style>
    .box {
      width: 100px;
      height: 100px;
      background-color: red;
      transform-style: preserve-3d;
      transition: transform 0.5s ease-in-out;
    }
    .box-child {
      width: 100px;
      height: 100px;
      background-color: blue;
    }
    .box:hover {
      transform: rotate(45deg);
    }
  </style>
  ```

  </htmlcss-snippet>

---

- Thuộc tính `perspective` được sử dụng để định nghĩa độ sâu của phần tử 3D.

  - Ví dụ ở đây chúng ta sẽ định nghĩa độ sâu của phần tử 3D là `100px`:

  <htmlcss-snippet>

  ```html
  <div class="box"></div>

  <style>
    .box {
      width: 100px;
      height: 100px;
      background-color: red;
      perspective: 100px;
      transition: transform 0.5s ease-in-out;
    }
    .box:hover {
      transform: rotateX(45deg);
    }
  </style>
  ```

  </htmlcss-snippet>

---

- Thuộc tính `perspective-origin` được sử dụng để định nghĩa điểm bắt đầu của phần tử 3D.

  - Ví dụ ở đây chúng ta sẽ định nghĩa điểm bắt đầu của phần tử 3D là `top left`:

  <htmlcss-snippet>

  ```html
  <div class="box"></div>

  <style>
    .box {
      width: 100px;
      height: 100px;
      background-color: red;
      perspective: 100px;
      perspective-origin: top left;
      transition: transform 0.5s ease-in-out;
    }
    .box:hover {
      transform: rotateX(45deg);
    }
  </style>
  ```

  </htmlcss-snippet>

---

## Ứng dụng trong thực tế

Thuộc tính `transform` có rất nhiều ứng dụng trong phát triển web, từ tạo hiệu ứng chuyển động cho phần tử, xoay ảnh, tạo hiệu ứng hover cho các nút, đến tạo các slider 3D và biến đổi hình dạng phức tạp. Dưới đây là một ví dụ về cách sử dụng thuộc tính `transform` trong thực tế để tạo ra một aside menu:

<htmlcss-snippet>

```html
<div class="container">
  <input type="checkbox" id="toggle" hidden />
  <div class="menu">
    <div class="menu-header">
      <h1>Menu</h1>
      <label for="toggle" class="close-btn">Close</label>
    </div>
    <ul>
      <li>Home</li>
      <li>About</li>
      <li>Contact</li>
    </ul>
  </div>
  <label for="toggle" class="toggle-btn">Menu</label>
</div>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  .container {
    width: 100vw;
    height: 100vh;
    background-color: #333;
  }
  .menu {
    width: 300px;
    height: 100vh;
    background-color: #fff;
    position: relative;
    transform: translateX(-100%);
    transition: transform 0.5s ease-in-out;
  }
  .menu-header {
    padding: 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #ccc;
  }
  .menu-header h1 {
    font-size: 20px;
    font-weight: 700;
  }
  .menu ul {
    list-style: none;
    padding: 20px;
  }
  .menu ul li {
    padding: 10px 0;
    font-size: 16px;
    font-weight: 500;
    cursor: pointer;
  }
  .toggle-btn {
    position: absolute;
    top: 20px;
    right: 20px;
    padding: 10px 20px;
    background-color: #333;
    color: #fff;
    cursor: pointer;
  }
  .toggle-btn:hover {
    background-color: #222;
  }
  .close-btn {
    padding: 10px 20px;
    background-color: #333;
    color: #fff;
    border: none;
    cursor: pointer;
  }
  .close-btn:hover {
    background-color: #222;
  }
  #toggle:checked ~ .menu {
    transform: translateX(0);
  }
</style>
```

</htmlcss-snippet>

---

## Case Study: Áp dụng Transition và Transform để xây dựng hiệu ứng.

`Transition` và `transform` là hai thuộc tính CSS rất mạnh mẽ có thể được sử dụng để tạo ra nhiều hiệu ứng khác nhau cho các trang web.

`Transition` không chỉ được kết hợp với `transform`. Tuy nhiên giá trị của thuộc tính `transform` là một trong những giá trị phổ biến nhất được sử dụng với `transition`.

---

## Transition và Transform

Với 2 thuộc tính này nếu sử dụng hiệu quả, chúng ta có thể làm hầu hết các hiệu ứng chuyển động cho các phần tử trên trang web của mình.

- Di chuyển các phần tử của trang web

- Thay đổi kích thước các phần tử của trang web

- Thay đổi màu sắc của các phần tử của trang web

- Thay đổi độ mờ của các phần tử của trang web

- Tạo hiệu ứng bóng đổ cho các phần tử của trang web

- Và nhiều hiệu ứng khác nữa

**Liệt kê các cách sử dụng transition và transform hiệu quả**

Để sử dụng `transition` và `transform` hiệu quả, chúng ta cần lưu ý một số điều sau:

- Chỉ sử dụng `transition` và `transform` cho các phần tử của trang web cần thiết.

- Sử dụng các thuộc tính CSS phù hợp để tạo ra các hiệu ứng `transition` đẹp mắt và hấp dẫn.

- Không sử dụng `transition` quá nhiều sẽ khiến trang web trở nên khó sử dụng và trải nghiệm người dùng sẽ bị ảnh hưởng xấu.

- Đôi lúc không cần thiết phải sử dụng **`animation`** để làm các tác vụ đơn giản của `transition` và `transform`.

  - Vì `animation` sẽ tốn nhiều tài nguyên hơn `transition` và `transform`.

  - Vì `animation` viết dài hơn, khó hiểu hơn `transition` và `transform`.

  - Vì `animation` thường được sử dụng cho các hiệu ứng không yêu cầu sự tương tác của người dùng.

  - Vì `animation` thường được sử dụng cho các hiệu ứng phức tạp hơn.

  - Vì `animation` thường được sử dụng cho các hiệu ứng không thể thực hiện được bằng `transition` và `transform`.

- Cũng cần chú ý tới `transition-duration` hợp lý để tránh người dùng phải chờ đợi quá lâu.

  - Có thể tham khảo các blog, trang báo và tài liệu nghiên cứu nổi tiếng như:

    - [https://www.nngroup.com/articles/response-times-3-important-limits/](https://www.nngroup.com/articles/response-times-3-important-limits/)

    - [https://jlelliotton.blogspot.com/p/the-economic-value-of-rapid-response.html](https://jlelliotton.blogspot.com/p/the-economic-value-of-rapid-response.html)

    - [https://gugel.medium.com/the-doherty-threshold-5471ca990de6](https://gugel.medium.com/the-doherty-threshold-5471ca990de6)

    - [https://www.researchgate.net/publication/234791131_The_importance_of_percent-done_progress_indicators_for_computer-human_interfaces](https://www.researchgate.net/publication/234791131_The_importance_of_percent-done_progress_indicators_for_computer-human_interfaces)

    - [https://yusufarslan.net/sites/yusufarslan.net/files/upload/content/Miller1968.pdf](https://yusufarslan.net/sites/yusufarslan.net/files/upload/content/Miller1968.pdf)

  - Theo đó:

    - Cung cấp phản hồi trang web trong vòng 400 mili giây để thu hút sự chú ý của người dùng và tăng năng suất.

    - Thanh tiến trình giúp làm cho thời gian chờ có thể chấp nhận được, bất kể độ chính xác của chúng.

    - Việc cố tình thêm độ trễ vào một quy trình thực sự có thể làm tăng giá trị cảm nhận của nó và tạo cảm giác tin cậy, ngay cả khi bản thân quy trình đó thực sự tốn ít thời gian hơn nhiều.

---

## Kỹ thuật chia layout với Flexbox

Flexbox là một kỹ thuật bố trí cực kỳ linh hoạt cho phép chúng ta dễ dàng định dạng các phần tử trên trang web của mình. Flexbox có thể được sử dụng để tạo ra nhiều bố cục khác nhau, bao gồm:

- Dòng ngang
- Cột dọc
- Bảng
- Modules
- Trình bày hình ảnh
- Vẫn nhiều hơn nữa

Flexbox dựa trên ba trụ cột chính:

- **Trục chính:** Trục chính là trục mà các phần tử flex được sắp xếp. Trục chính có thể là trục ngang (theo chiều ngang) hoặc trục dọc (theo chiều dọc).
- **Trục phụ:** Trục phụ là trục vuông góc với trục chính. Trục phụ thường được sử dụng để sắp xếp các phần tử flex còn lại.
- **Sự sắp xếp:** Sự sắp xếp là cách các phần tử flex được sắp xếp trên trang web. Sự sắp xếp có thể là theo thứ tự, ngược thứ tự hoặc theo thứ tự ngẫu nhiên.

Flexbox cung cấp một số thuộc tính CSS để định dạng các phần tử flex. Một số thuộc tính CSS quan trọng nhất bao gồm:

- **`display`:** Thuộc tính `display` được sử dụng để xác định rằng một phần tử là phần tử flex.
- **`align-content`:** Thuộc tính `align-content` được sử dụng để xác định cách các phần tử flex được sắp xếp theo trục phụ khi không gian bị giới hạn.
- **`align-items`:** Thuộc tính `align-items` được sử dụng để xác định cách các phần tử flex được sắp xếp theo trục phụ.
- **`align-self`:** Thuộc tính `align-self` được sử dụng để xác định cách một phần tử flex được sắp xếp theo trục phụ.
- **`justify-content`:** Thuộc tính `justify-content` được sử dụng để xác định cách các phần tử flex được sắp xếp theo trục chính.
- **`flex-wrap`:** Thuộc tính `flex-wrap` được sử dụng để xác định cách các phần tử flex được xếp chồng lên nhau khi không gian bị giới hạn.
- **`flex-direction`:** Thuộc tính `flex-direction` được sử dụng để xác định trục chính của các phần tử flex.
- **`flex-grow`:** Thuộc tính `flex-grow` được sử dụng để xác định cách các phần tử flex chia sẻ không gian thừa.
- **`flex-shrink`:** Thuộc tính `flex-shrink` được sử dụng để xác định cách các phần tử flex thu nhỏ khi không gian bị giới hạn.
- **`flex-basis`:** Thuộc tính `flex-basis` được sử dụng để xác định kích thước ban đầu của các phần tử flex.
- **`order`:** Thuộc tính `order` được sử dụng để xác định thứ tự sắp xếp của các phần tử flex.
- **`flex`:** Thuộc tính `flex` được sử dụng để gộp các thuộc tính `flex-grow`, `flex-shrink` và `flex-basis` thành một thuộc tính duy nhất.
- **`gap`:** Thuộc tính `gap` được sử dụng để xác định khoảng cách giữa các phần tử flex.
- **`row-gap`:** Thuộc tính `row-gap` được sử dụng để xác định khoảng cách giữa các phần tử flex theo trục chính.
- **`column-gap`:** Thuộc tính `column-gap` được sử dụng để xác định khoảng cách giữa các phần tử flex theo trục phụ.

Flexbox là một kỹ thuật rất mạnh mẽ và linh hoạt có thể được sử dụng để tạo ra nhiều bố cục khác nhau cho các trang web của chúng ta.

Một số lưu ý khi sử dụng Flexbox:

- Chỉ sử dụng Flexbox cho các phần tử cần được sắp xếp theo cách linh hoạt.

- Hiểu rõ các thuộc tính CSS của Flexbox và cách chúng hoạt động.

- Sử dụng Flexbox để tạo ra các bố cục đơn giản và sử dụng Grid để tạo ra các bố cục phức tạp.

- Sử dụng Flexbox cần chú ý để đảm bảo performance tốt nhất.

---

---

## **Thuộc tính Grid**

Thuộc tính `display: grid` có nghĩa là phần tử sẽ được hiển thị dưới dạng `grid-container`. `Grid-containercontainer` là một cách bố trí linh hoạt cho phép chúng ta kiểm soát cách các phần tử được sắp xếp và căn chỉnh trên trang web của mình.

Khi chúng ta đặt thuộc tính `display` thành `grid`, chúng ta có thể sử dụng các thuộc tính CSS khác để kiểm soát cách các phần tử `grid-container` được sắp xếp và căn chỉnh. Một số thuộc tính CSS quan trọng nhất cho `grid-container` bao gồm:

- **`grid-template-columns`:** Thuộc tính `grid-template-columns` được sử dụng để xác định kích thước và số lượng cột trong `grid-container`.
- **`grid-template-rows`:** Thuộc tính `grid-template-rows` được sử dụng để xác định kích thước và số lượng hàng trong `grid-container`.
- **`grid-template`:** Thuộc tính `grid-template` được sử dụng để xác định kích thước và số lượng cột và hàng trong `grid-container`.
- **`grid-auto-columns`:** Thuộc tính `grid-auto-columns` được sử dụng để xác định kích thước tự động của các cột trong `grid-container`.
- **`grid-auto-rows`:** Thuộc tính `grid-auto-rows` được sử dụng để xác định kích thước tự động của các hàng trong `grid-container`.
- **`grid-gap`:** Thuộc tính `grid-gap` được sử dụng để xác định khoảng cách giữa các cột và hàng trong `grid-container`.
- **`grid-column-gap`:** Thuộc tính `grid-column-gap` được sử dụng để xác định khoảng cách giữa các cột trong `grid-container`.
- **`grid-row-gap`:** Thuộc tính `grid-row-gap` được sử dụng để xác định khoảng cách giữa các hàng trong `grid-container`.
- **`grid-template-areas`:** Thuộc tính `grid-template-areas` được sử dụng để xác định các khu vực trong `grid-container`.
- **`grid-placement`:** Thuộc tính `grid-placement` được sử dụng để xác định vị trí của một phần tử trong `grid-container`.
- **`grid-area`:** Thuộc tính `grid-area` được sử dụng để xác định khu vực mà một phần tử chiếm trong `grid-container`.

---

## **Thuộc tính Inline Grid**

Thuộc tính `display: inline-grid` có nghĩa là phần tử sẽ được hiển thị dưới dạng `grid-container` nhưng vẫn có thể thiết lập kích thước và padding.

Khi chúng ta đặt thuộc tính `display` thành `inline-grid`, chúng ta có thể sử dụng các thuộc tính CSS khác để kiểm soát cách các phần tử `grid-container` được sắp xếp và căn chỉnh. Một số thuộc tính CSS quan trọng nhất cho `grid-container` bao gồm:

- **`grid-template-columns`:** Thuộc tính `grid-template-columns` được sử dụng để xác định kích thước và số lượng cột trong `grid-container`.
- **`grid-template-rows`:** Thuộc tính `grid-template-rows` được sử dụng để xác định kích thước và số lượng hàng trong `grid-container`.
- **`grid-template`:** Thuộc tính `grid-template` được sử dụng để xác định kích thước và số lượng cột và hàng trong `grid-container`.
- **`grid-auto-columns`:** Thuộc tính `grid-auto-columns` được sử dụng để xác định kích thước tự động của các cột trong `grid-container`.
- **`grid-auto-rows`:** Thuộc tính `grid-auto-rows` được sử dụng để xác định kích thước tự động của các hàng trong `grid-container`.
- **`grid-gap`:** Thuộc tính `grid-gap` được sử dụng để xác định khoảng cách giữa các cột và hàng trong `grid-container`.
- **`grid-column-gap`:** Thuộc tính `grid-column-gap` được sử dụng để xác định khoảng cách giữa các cột trong `grid-container`.
- **`grid-row-gap`:** Thuộc tính `grid-row-gap` được sử dụng để xác định khoảng cách giữa các hàng trong `grid-container`.
- **`grid-template-areas`:** Thuộc tính `grid-template-areas` được sử dụng để xác định các khu vực trong `grid-container`.
- **`grid-placement`:** Thuộc tính `grid-placement` được sử dụng để xác định vị trí của một phần tử trong `grid-container`.
- **`grid-area`:** Thuộc tính `grid-area` được sử dụng để xác định khu vực mà một phần tử chiếm trong `grid-container`.

---

## Sử dụng Grid để tạo bố cục

Grid có thể được sử dụng để tạo ra nhiều bố cục khác nhau cho các trang web của chúng ta. Một số bố cục phổ biến nhất bao gồm:

- **Bố cục dòng ngang:** Bố cục dòng ngang là bố cục mà các phần tử được sắp xếp theo chiều ngang.

- **Bố cục cột dọc:** Bố cục cột dọc là bố cục mà các phần tử được sắp xếp theo chiều dọc.

- **Bố cục hỗn hợp:** Bố cục hỗn hợp là bố cục mà các phần tử được sắp xếp theo cả chiều ngang và chiều dọc.

- **Bố cục hình ảnh:** Bố cục hình ảnh là bố cục mà các phần tử được sắp xếp theo cả chiều ngang và chiều dọc và có kích thước bằng nhau.

- **Bố cục trình bày:** Bố cục trình bày là bố cục mà các phần tử được sắp xếp theo cả chiều ngang và chiều dọc và có kích thước khác nhau.

- **Bố cục bảng:** Bố cục bảng là bố cục mà các phần tử được sắp xếp theo cả chiều ngang và chiều dọc và có kích thước khác nhau và có thể tràn ra ngoài `grid-container`.

- **Bố cục module:** Bố cục module là bố cục mà các phần tử được sắp xếp theo cả chiều ngang và chiều dọc và có kích thước khác nhau và có thể tràn ra ngoài `grid-container` và có thể chồng lên nhau.

- **Bố cục trang web:** Bố cục trang web là bố cục mà các phần tử được sắp xếp theo cả chiều ngang và chiều dọc và có kích thước khác nhau và có thể tràn ra ngoài `grid-container` và có thể chồng lên nhau và có thể chia thành các khu vực.

- **Bố cục trang web responsive:** Bố cục trang web responsive là bố cục mà các phần tử được sắp xếp theo cả chiều ngang và chiều dọc và có kích thước khác nhau và có thể tràn ra ngoài `grid-container` và có thể chồng lên nhau và có thể chia thành các khu vực và có thể thay đổi kích thước theo kích thước của trình duyệt.

---

### Ví dụ về sử dụng Grid.

---

#### Bố cục dòng ngang

Bố cục dòng ngang là bố cục mà các phần tử được sắp xếp theo chiều ngang.

<htmlcss-snippet>

```html
<div class="container">
  <div class="item">Item 1</div>
  <div class="item">Item 2</div>
  <div class="item">Item 3</div>
  <div class="item">Item 4</div>
  <div class="item">Item 5</div>
  <div class="item">Item 6</div>
</div>
<style>
  .container {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-gap: 20px;
  }
  .item {
    background-color: #333;
    color: #fff;
    padding: 20px;
  }
</style>
```

</htmlcss-snippet>

Ở trong ví dụ này, chúng ta sử dụng thuộc tính `grid-template-columns` để xác định kích thước và số lượng cột trong `grid-container`. Chúng ta sử dụng hàm `repeat()` để lặp lại các cột. Hàm `repeat()` nhận hai tham số, tham số đầu tiên là số lần lặp lại và tham số thứ hai là kích thước của mỗi cột. Trong ví dụ này, chúng ta sử dụng `1fr` làm kích thước của mỗi cột. `1fr` có nghĩa là mỗi cột sẽ chiếm một phần bằng nhau trong `grid-container`.

Vậy có nghĩa là ở đây, chúng ta sẽ có 3 cột và mỗi cột sẽ chiếm một phần bằng nhau trong `grid-container`.

---

#### Bố cục cột dọc

Bố cục cột dọc là bố cục mà các phần tử được sắp xếp theo chiều dọc.

<htmlcss-snippet>

```html
<div class="container">
  <div class="item">Item 1</div>
  <div class="item">Item 2</div>
  <div class="item">Item 3</div>
  <div class="item">Item 4</div>
  <div class="item">Item 5</div>
  <div class="item">Item 6</div>
</div>
<style>
  .container {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-gap: 20px;
    grid-auto-flow: column;
  }
  .item {
    background-color: #333;
    color: #fff;
    padding: 20px;
  }
</style>
```

</htmlcss-snippet>

Ở trong ví dụ này, chúng ta sử dụng thuộc tính `grid-auto-flow` để xác định cách các phần tử được sắp xếp trong `grid-container`. Chúng ta sử dụng giá trị `column` để xác định rằng các phần tử sẽ được sắp xếp theo chiều dọc.

---

#### Bố cục hỗn hợp

Bố cục hỗn hợp là bố cục mà các phần tử được sắp xếp theo cả chiều ngang và chiều dọc.

<htmlcss-snippet>

```html
<div class="container">
  <div class="item">
    <img src="https://picsum.photos/200/300" alt="image" />
  </div>
  <div class="item"><img src="https://picsum.photos/200" alt="image" /></div>
  <div class="item">
    <img src="https://picsum.photos/200/400" alt="image" />
  </div>
  <div class="item">
    <img src="https://picsum.photos/400/200" alt="image" />
  </div>
  <div class="item">
    <img src="https://picsum.photos/300/200" alt="image" />
  </div>
  <div class="item"><img src="https://picsum.photos/300" alt="image" /></div>
</div>
<style>
  .container {
    display: grid;
    grid-gap: 20px;
    grid-auto-flow: column;
    grid-auto-rows: 200px;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    grid-auto-flow: row dense;
  }
  .item {
    background-color: #333;
    color: #fff;
    padding: 20px;
  }
  img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
</style>
```

</htmlcss-snippet>

Ở trong ví dụ này, chúng ta sử dụng:

- Thuộc tính `grid-auto-rows` để xác định kích thước tự động của các hàng trong `grid-container`.

- Thuộc tính `grid-template-columns` để xác định kích thước và số lượng cột trong `grid-container`.

- Thuộc tính `grid-auto-flow` để xác định cách các phần tử được sắp xếp trong `grid-container`.

- Hàm `repeat()` để lặp lại các cột.

- Hàm `auto-fit` để xác định số lượng cột tối đa có thể hiển thị trong `grid-container`.

- Hàm `minmax()` để xác định kích thước tối thiểu và tối đa của mỗi cột.

- Giá trị `dense` để xác định rằng các phần tử sẽ được sắp xếp một cách gần nhau nhất có thể.

---

## Hiệu ứng animation

Animation là một thuộc tính CSS cho phép chúng ta thêm các hiệu ứng hoạt hình cho các phần tử của trang web.

Animation có thể được sử dụng để tạo ra nhiều hiệu ứng khác nhau, bao gồm:

- Di chuyển các phần tử của trang web

- Thay đổi kích thước các phần tử của trang web

- Thay đổi màu sắc của các phần tử của trang web

- Thay đổi độ mờ của các phần tử của trang web

- Tạo hiệu ứng bóng đổ cho các phần tử của trang web

- Và còn nhiều hiệu ứng khác.

---

## Thuộc tính animation

Animation có một số thuộc tính quan trọng, bao gồm:

- `animation-name`: Thuộc tính này cho phép chúng ta xác định tên của hiệu ứng animation.

- `animation-duration`: Thuộc tính này cho phép chúng ta xác định thời gian của hiệu ứng animation.

- `animation-timing-function`: Thuộc tính này cho phép chúng ta xác định chức năng thời gian của hiệu ứng animation.

- `animation-delay`: Thuộc tính này cho phép chúng ta xác định thời gian trễ của hiệu ứng animation.

- `animation-iteration-count`: Thuộc tính này cho phép chúng ta xác định số lần lặp lại của hiệu ứng animation.

- `animation-direction`: Thuộc tính này cho phép chúng ta xác định hướng của hiệu ứng animation.

- `animation-fill-mode`: Thuộc tính này cho phép chúng ta xác định cách các thuộc tính của phần tử được áp dụng trước và sau hiệu ứng animation.

---

## Cách viết gộp các thuộc tính animation

Chúng ta có thể gộp các thuộc tính animation bằng cách sử dụng cú pháp sau:

```css
.box {
  animation-name: animated;
  animation-duration: 2s;
  animation-timing-function: ease-in-out;
  animation-delay: 0s;
  animation-iteration-count: 1;
  animation-direction: normal;
  animation-fill-mode: forwards;
  /* Sau khi gộp lại, chúng ta chỉ cần viết: */
  animation: animated 2s ease-in-out 0s 1 normal forwards;
}
```

---

### Cách viết animation với các giá trị mặc định

Chúng ta có thể viết animation với các giá trị mặc định bằng cách sử dụng cú pháp sau:

```css
.box {
  animation-name: animated;
  animation-duration: 2s;
  animation-timing-function: ease; /* ease là giá trị mặc định */
  animation-delay: 0s; /* 0s là giá trị mặc định */
  animation-iteration-count: 1; /* 1 là giá trị mặc định */
  animation-direction: normal; /* normal là giá trị mặc định */
  animation-fill-mode: none; /* none là giá trị mặc định */
  /* Sau khi gộp lại, chúng ta chỉ cần viết: */
  animation: animated 2s;
}
```

---

## Hiệu ứng @keyframes

`@keyframes` là một khối CSS cho phép chúng ta định nghĩa các khung hình chính của hiệu ứng animation. Mỗi khung hình chính là một trạng thái của hiệu ứng animation tại một thời điểm cụ thể.

Để tạo một hiệu ứng animation, chúng ta cần tạo một khối `@keyframes` và định nghĩa các khung hình chính của hiệu ứng animation.

Sau đó, chúng ta cần sử dụng thuộc tính `animation-name` để xác định tên của hiệu ứng animation và sử dụng thuộc tính `animation-duration` để xác định thời gian của hiệu ứng animation.

---

## Cách viết @keyframes

Chúng ta có thể viết `@keyframes` bằng cách sử dụng cú pháp sau:

```css
@keyframes animated {
  from {
    /* Bắt đầu chạy animation. */
  }
  percent {
    /* Các khoảng giữa của animation. */
  }
  to {
    /* Kết thúc animation. */
  }
}
```

---

## Thực hành với các animation phổ biến

1: Loading

<htmlcss-snippet>

```html
<div class="wrapper">
  <span class="dot"></span>
  <span class="dot"></span>
  <span class="dot"></span>
  <span class="dot"></span>
</div>
<style>
  body {
    margin: 0;
  }
  .wrapper {
    width: 100vw;
    height: 100vh;
    display: grid;
    place-items: center;
    position: relative;
  }
  .wrapper .dot {
    position: absolute;
    height: 80px;
    width: 80px;
    border-radius: 50%;
    transform: scale(1);
    background: #008ae6;
    animation: loading 1s infinite cubic-bezier(0.1, 0.3, 0.15, 1);
  }
  .dot:nth-child(2) {
    background: #e60000;
    animation-delay: 0.25s;
  }
  .dot:nth-child(3) {
    background: #ffcc00;
    animation-delay: 0.5s;
  }
  .dot:nth-child(4) {
    background: #008800;
    animation-delay: 0.75s;
  }
  @keyframes loading {
    50% {
      transform: scale(0.25);
      filter: hue-rotate(360deg);
      border-radius: 8px;
    }
  }
</style>
```

</htmlcss-snippet>

2. Hiệu ứng bóng chat.

<htmlcss-snippet>

```html
<div class="wrapper">
  <div class="messenger">👻</div>
</div>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  .wrapper {
    display: grid;
    place-items: center;
    height: 100vh;
  }
  .messenger {
    font-size: 10rem;
    border-radius: 50%;
    padding: 1rem;
    outline: 1px solid #fad;
    outline-offset: -10px;
    box-shadow: 0 0 0 20px rgba(255, 170, 170, 0);
    animation: shadow-pulse 1s infinite;
  }
  @keyframes shadow-pulse {
    50% {
      outline-offset: 20px;
      box-shadow: 0 0 0 0px rgba(255, 170, 170, 0.4);
    }
  }
</style>
```

</htmlcss-snippet>

3. GIF CSS sprites

Kỹ thuật này sử dụng một hình ảnh duy nhất để tạo ra một hiệu ứng animation kết hợp với 1 hàm là step để chuyển động chính xác.

Sử dụng thêm các kỹ thuật của background css sprite để tạo ra hiệu ứng animation.

Tuy nhiên việc demo khá dài nên sẽ không đưa vào đây.

4. Ngoài ra còn nhiều hiệu ứng và kỹ thuật khác.

---

## Phân biệt animation và transition

Animation và transition đều là các thuộc tính CSS cho phép chúng ta thêm các hiệu ứng cho các phần tử của trang web. Tuy nhiên, animation và transition có một số điểm khác biệt sau:

- Animation là một hiệu ứng được lặp lại, trong khi transition là một hiệu ứng chỉ được thực hiện một lần.

- Animation có thể được sử dụng để tạo ra nhiều hiệu ứng khác nhau, trong khi transition chỉ có thể được sử dụng để thay đổi thuộc tính của một phần tử.

- Animation có thể được sử dụng để tạo ra các hiệu ứng phức tạp hơn, trong khi transition chỉ có thể được sử dụng để tạo ra các hiệu ứng đơn giản.

---

## Hiệu suất khi sử dụng animation

Animation có thể làm giảm performance của trang web, đặc biệt là khi chúng ta sử dụng nhiều animation trên cùng một trang. Để cải thiện performance của trang web khi sử dụng animation, chúng ta nên thực hiện một số điều sau:

- Chỉ sử dụng animation cho các phần tử cần thiết.

- Sử dụng các animation đơn giản thay vì các animation phức tạp.

- Sử dụng các animation có thời gian ngắn.

- Sử dụng các animation có chức năng thời gian phù hợp.

---

## Hiệu ứng phổ biến của animation thường gặp

Animation là một thuộc tính CSS cho phép chúng ta thêm các hiệu ứng hoạt hình cho các phần tử của trang web. Animation có thể được sử dụng để tạo ra nhiều hiệu ứng khác nhau, bao gồm:

- Di chuyển các phần tử của trang web
- Thay đổi kích thước các phần tử của trang web
- Thay đổi màu sắc của các phần tử của trang web
- Thay đổi độ mờ của các phần tử của trang web
- Tạo hiệu ứng bóng đổ cho các phần tử của trang web

1. **Loading animation**

Loading animation là một hiệu ứng được sử dụng để hiển thị trạng thái đang tải của một trang web hoặc một phần tử của trang web. Loading animation thường được sử dụng để thông báo cho người dùng rằng trang web hoặc phần tử của trang web đang tải và sẽ sớm sẵn sàng để sử dụng.

2. **Call to action animation**

Call to action animation là một hiệu ứng được sử dụng để thu hút sự chú ý của người dùng và khuyến khích họ thực hiện một hành động cụ thể, chẳng hạn như nhấp vào nút, xem video hoặc đọc bài viết. Call to action animation thường được sử dụng để tăng hiệu quả của các chiến dịch marketing và quảng cáo.

3. **Tooltip animation**

Tooltip animation là một hiệu ứng được sử dụng để hiển thị thông tin bổ sung khi người dùng di chuột qua một phần tử của trang web. Tooltip animation thường được sử dụng để cung cấp thông tin về chức năng của một phần tử hoặc để cung cấp thêm thông tin về sản phẩm hoặc dịch vụ được quảng cáo.

4. **Menu animation**

Menu animation là một hiệu ứng được sử dụng để hiển thị và ẩn menu của một trang web. Menu animation thường được sử dụng để làm cho menu của trang web trở nên đẹp mắt và hấp dẫn hơn.

5. **Slider animation**

Slider animation là một hiệu ứng được sử dụng để hiển thị một loạt hình ảnh hoặc video trên một trang web. Slider animation thường được sử dụng để giới thiệu sản phẩm hoặc dịch vụ, để kể một câu chuyện hoặc để cung cấp thông tin tổng quan về một chủ đề.

---

## Xây dựng hiệu ứng với animation và @keyframes

Để xây dựng một hiệu ứng animation, chúng ta cần sử dụng thuộc tính `animation-name` để xác định tên của hiệu ứng animation và sử dụng thuộc tính `animation-duration` để xác định thời gian của hiệu ứng animation.

Sau đó, chúng ta cần sử dụng khối `@keyframes` để định nghĩa các khung hình chính của hiệu ứng animation.

Trong ví dụ lần này, chúng ta sẽ làm một loading animation.

<htmlcss-snippet>

```html
<div class="container">
  <span class="loading item1"></span>
  <span class="loading item2"></span>
  <span class="loading item3"></span>
  <span class="loading item4"></span>
</div>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  .container {
    --orange: #faa300;
    background: #333;
    width: 100vw;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .loading {
    margin: 0 15px;
    width: 35px;
    height: 15px;
    border-radius: 8px;
    background: var(--orange);
    box-shadow: 0 0 10px 0 #ffa6007e;
  }
  .item1 {
    margin-right: -30px;
    transform-origin: center left;
    animation: spin 3s linear infinite;
  }
  .item2 {
    transform-origin: center right;
    animation: spin2 3s linear infinite;
    animation-delay: 0.2s;
  }
  .item3 {
    transform-origin: center right;
    animation: spin3 3s linear infinite;
    animation-delay: 0.3s;
  }
  .item4 {
    transform-origin: center right;
    animation: spin4 3s linear infinite;
    animation-delay: 0.4s;
  }
  @keyframes spin {
    0% {
      transform: rotate(0deg);
      filter: hue-rotate(0deg);
    }
    25% {
      transform: rotate(360deg);
    }
    30% {
      transform: rotate(370deg);
      filter: hue-rotate(360deg);
    }
    35% {
      transform: rotate(360deg);
    }
    100% {
      transform: rotate(360deg);
      filter: hue-rotate(0);
    }
  }
  @keyframes spin2 {
    0% {
      transform: rotate(0deg);
      filter: hue-rotate(0deg);
    }
    20% {
      transform: rotate(0deg);
    }
    30% {
      transform: rotate(-180deg);
    }
    35% {
      transform: rotate(-190deg);
    }
    40% {
      transform: rotate(-180deg);
      filter: hue-rotate(360deg);
    }
    78% {
      transform: rotate(-180deg);
    }
    95% {
      transform: rotate(-360deg);
    }
    98% {
      transform: rotate(-370deg);
    }
    100% {
      transform: rotate(-360deg);
      filter: hue-rotate(0);
    }
  }
  @keyframes spin3 {
    0% {
      transform: rotate(0deg);
      filter: hue-rotate(0deg);
    }
    27% {
      transform: rotate(0deg);
    }
    40% {
      transform: rotate(180deg);
    }
    45% {
      transform: rotate(190deg);
    }
    50% {
      transform: rotate(180deg);
    }
    62% {
      transform: rotate(180deg);
      filter: hue-rotate(360deg);
    }
    75% {
      transform: rotate(360deg);
    }
    80% {
      transform: rotate(370deg);
    }
    85% {
      transform: rotate(360deg);
    }
    100% {
      transform: rotate(360deg);
      filter: hue-rotate(0);
    }
  }
  @keyframes spin4 {
    0% {
      transform: rotate(0deg);
      filter: hue-rotate(0deg);
    }
    38% {
      transform: rotate(0deg);
    }
    60% {
      transform: rotate(-360deg);
    }
    65% {
      transform: rotate(-370deg);
      filter: hue-rotate(360deg);
    }
    75% {
      transform: rotate(-360deg);
    }
    100% {
      transform: rotate(-360deg);
      filter: hue-rotate(0);
    }
  }
</style>
```

</htmlcss-snippet>

---

## Animation rất tốn tài nguyên

Animation là một cách tuyệt vời để thêm tính hấp dẫn và tương tác cho các trang web của chúng ta. Tuy nhiên, animation cũng có thể tốn tài nguyên và có thể làm chậm tốc độ tải trang web của chúng ta. Do đó, điều quan trọng là sử dụng animation một cách tối ưu.

Một số mẹo để sử dụng animation một cách tối ưu bao gồm:

- Chỉ sử dụng animation cho các phần tử cần thiết.

- Sử dụng các animation đơn giản thay vì các animation phức tạp.

- Sử dụng các animation có thời gian ngắn.

- Sử dụng các animation có chức năng thời gian phù hợp.

- Sử dụng các thư viện animation được build sẵn và tối ưu hóa.

---

## Thư viện animate.style

Animate.style là một thư viện CSS nhỏ gọn và dễ sử dụng cho phép chúng ta thêm hiệu ứng hoạt hình cho các phần tử của trang web của mình. Thư viện này có một số tính năng nổi bật, bao gồm:

- Một bộ sưu tập lớn các hiệu ứng hoạt hình
- Dễ dàng sử dụng
- Tối ưu hóa cho hiệu suất

Để sử dụng animate.style, chúng ta chỉ cần thêm thư viện vào trang web của mình và sau đó sử dụng các thuộc tính CSS để áp dụng hiệu ứng hoạt hình cho các phần tử.

Ví dụ: để làm cho một phần tử di chuyển từ trái sang phải, chúng ta có thể sử dụng thuộc tính `animation-name: move-left-right;`.

Animate.style là một cách tuyệt vời để thêm hiệu ứng hoạt hình cho các trang web của chúng ta.

Thư viện này dễ sử dụng và có một bộ sưu tập lớn các hiệu ứng hoạt hình để chúng ta lựa chọn.

---

## Các thư viện animation khác:

Ngoài animate.style, còn có một số thư viện animation khác mà chúng ta có thể sử dụng, bao gồm:

- Wow.js: Thư viện này thêm hiệu ứng hoạt hình khi người dùng cuộn trang web.

  - [Xem thêm](https://wowjs.uk/)

- AOS: Thư viện này thêm hiệu ứng hoạt hình khi người dùng di chuột qua các phần tử của trang web và khi người dùng cuộn trang web.

  - [Xem thêm](https://michalsnik.github.io/aos/)

- FullPage.js: Thư viện này thêm hiệu ứng hoạt hình cho toàn bộ trang web.

  - [Xem thêm](https://alvarotrigo.com/fullPage/)

- AniJS: Thư viện này thêm hiệu ứng hoạt hình khi người dùng thực hiện một hành động cụ thể, chẳng hạn như nhấp vào nút hoặc di chuột qua một phần tử.

  - [Xem thêm](https://anijs.github.io/)

- Hover.css: Thư viện này thêm hiệu ứng hoạt hình khi người dùng di chuột qua một phần tử.

  - [Xem thêm](https://ianlunn.github.io/Hover/)

- Magic.css: Thư viện này thêm hiệu ứng hoạt hình khi người dùng cuộn trang web.

  - [Xem thêm](https://www.minimamente.com/project/magic/)

- Ngoài ra còn rất nhiều thư viện khác...

Mỗi thư viện có những điểm mạnh và điểm yếu riêng. Chúng nên lựa chọn thư viện phù hợp với nhu cầu của mình.
