## Giới thiệu về ngôn ngữ tiền xử lý

Ngôn ngữ tiền xử lý là một ngôn ngữ được sử dụng để xử lý code trước khi nó được thực thi.

Ngôn ngữ tiền xử lý thường được sử dụng để thêm các tính năng mới vào ngôn ngữ gốc, hoặc để tạo ra code có thể dễ đọc và dễ hiểu hơn.

Trong lĩnh vực phát triển web, ngôn ngữ tiền xử lý thường được sử dụng để viết CSS hoặc JS.

CSS là một ngôn ngữ đánh dấu được sử dụng để định kiểu cho các trang web.

Tuy nhiên, CSS có thể khó đọc và khó hiểu, đặc biệt khi chúng ta cần viết một lượng lớn CSS.

Ngôn ngữ tiền xử lý như SCSS có thể giúp chúng ta viết CSS dễ đọc và dễ hiểu hơn bằng cách thêm các tính năng mới và cú pháp mới.

---

## Ngôn ngữ tiền xử lý khác gì ngôn ngữ lập trình và ngôn ngữ đánh dấu?

Ngôn ngữ tiền xử lý khác với ngôn ngữ lập trình ở chỗ ngôn ngữ tiền xử lý không được thiết kế để tạo ra các chương trình.

Ngôn ngữ tiền xử lý được thiết kế để xử lý code trước khi nó được thực thi.

Ngôn ngữ tiền xử lý cũng khác với ngôn ngữ đánh dấu ở chỗ ngôn ngữ tiền xử lý có thể thêm các tính năng mới vào ngôn ngữ gốc. Ngôn ngữ đánh dấu chỉ có thể được sử dụng để đánh dấu dữ liệu.

Ví dụ như, ngôn ngữ tiền xử lý như SCSS có thể thêm các tính năng mới vào CSS. Ngôn ngữ đánh dấu như CSS chỉ có thể được sử dụng để đánh dấu các trang web.

---

## Ưu điểm của việc sử dụng ngôn ngữ tiền xử lý

Ngôn ngữ tiền xử lý có một số ưu điểm như:

- Dễ đọc và dễ hiểu hơn: Ngôn ngữ tiền xử lý có thể giúp chúng ta viết CSS dễ đọc và dễ hiểu hơn bằng cách thêm các tính năng mới và cú pháp mới.

- Tạo ra code có thể tái sử dụng cao hơn: Ngôn ngữ tiền xử lý có thể giúp chúng ta tạo ra code có thể tái sử dụng cao hơn bằng cách cho phép chúng ta định nghĩa các hàm và biến.

- Tạo ra code có thể bảo trì tốt hơn: Ngôn ngữ tiền xử lý có thể giúp chúng ta tạo ra code có thể bảo trì tốt hơn bằng cách cho phép chúng ta nhóm các quy tắc CSS lại với nhau.

---

## Kết luận

Ngôn ngữ tiền xử lý là một công cụ mạnh mẽ có thể giúp chúng ta viết CSS dễ đọc, dễ hiểu và dễ bảo trì hơn.

Vì chúng ta đang học HTML và CSS, chúng ta có thể học SCSS để viết CSS dễ đọc, dễ hiểu và dễ bảo trì hơn.

---

## Các ngôn ngữ tiền xử lý phổ biến hiện nay

Ngôn ngữ tiền xử lý là một công cụ mạnh mẽ có thể giúp chúng ta viết code dễ đọc, dễ hiểu và dễ bảo trì hơn. Có một số ngôn ngữ tiền xử lý phổ biến hiện nay, bao gồm:

- SASS
- SCSS
- LESS
- PUG
- TYPOSCRIPT
- TypeScript
- JSX

---

### SASS

SASS là một ngôn ngữ tiền xử lý CSS được tạo ra bởi Hampton Catlin vào năm 2006. SASS là một ngôn ngữ mạnh mẽ có thể giúp chúng ta viết CSS dễ đọc và dễ hiểu hơn. SASS có một số tính năng hữu ích, bao gồm:

- Kế thừa: SASS cho phép chúng ta kế thừa các giá trị CSS từ các cấp cha mẹ xuống các cấp con.

- Mixins: SASS cho phép chúng ta định nghĩa các nhóm các quy tắc CSS và sử dụng lại chúng trong nhiều nơi khác nhau trong code của chúng ta.

- Functions: SASS cho phép chúng ta định nghĩa các hàm CSS để thực hiện các tác vụ phức tạp.

- Variables: SASS cho phép chúng ta lưu trữ các giá trị CSS trong các biến và sử dụng lại chúng trong nhiều nơi khác nhau trong code của chúng ta.

- Tham khảo thêm tại đây: [sass-lang.com](https://sass-lang.com)

---

### SCSS

SCSS là một ngôn ngữ tiền xử lý CSS được tạo ra bởi Natalie Weizenbaum và Chris Eppstein vào năm 2010. SCSS là một ngôn ngữ mở rộng của SASS và nó có thể được chuyển đổi thành SASS và CSS. SCSS có một số tính năng hữu ích, bao gồm:

- Kế thừa: SCSS cho phép chúng ta kế thừa các giá trị CSS từ các cấp cha mẹ xuống các cấp con.

- Mixins: SCSS cho phép chúng ta định nghĩa các nhóm các quy tắc CSS và sử dụng lại chúng trong nhiều nơi khác nhau trong code của chúng ta.

- Functions: SCSS cho phép chúng ta định nghĩa các hàm CSS để thực hiện các tác vụ phức tạp.

- Variables: SCSS cho phép chúng ta lưu trữ các giá trị CSS trong các biến và sử dụng lại chúng trong nhiều nơi khác nhau trong code của chúng ta.

- Tham khảo thêm tại đây: [sass-lang.com](https://sass-lang.com)

---

### LESS

LESS là một ngôn ngữ tiền xử lý CSS được tạo ra bởi Alexis Sellier vào năm 2010. LESS là một ngôn ngữ mở rộng của CSS và nó có thể được chuyển đổi thành CSS. LESS có một số tính năng hữu ích, bao gồm:

- Kế thừa: LESS cho phép chúng ta kế thừa các giá trị CSS từ các cấp cha mẹ xuống các cấp con.

- Mixins: LESS cho phép chúng ta định nghĩa các nhóm các quy tắc CSS và sử dụng lại chúng trong nhiều nơi khác nhau trong code của chúng ta.

- Functions: LESS cho phép chúng ta định nghĩa các hàm CSS để thực hiện các tác vụ phức tạp.

- Variables: LESS cho phép chúng ta lưu trữ các giá trị CSS trong các biến và sử dụng lại chúng trong nhiều nơi khác nhau trong code của chúng ta.

- Tham khảo thêm tại đây: [lesscss.org](http://lesscss.org)

---

### PUG

PUG là một ngôn ngữ tiền xử lý HTML được tạo ra bởi Jon Sass vào năm 2010. PUG là một ngôn ngữ mạnh mẽ có thể giúp chúng ta viết HTML dễ đọc và dễ hiểu hơn. PUG có một số tính năng hữu ích, bao gồm:

- Mảng: PUG cho phép chúng ta sử dụng các mảng trong HTML.

- Hàm: PUG cho phép chúng ta định nghĩa các hàm HTML.

- Điều kiện: PUG cho phép chúng ta sử dụng các điều kiện trong HTML.

- Lặp: PUG cho phép chúng ta sử dụng các vòng lặp trong HTML.

- Biến: PUG cho phép chúng ta sử dụng các biến trong HTML.

- Tham khảo thêm tại đây: [pugjs.org](https://pugjs.org)

---

## Ưu điểm và nhược điểm của các ngôn ngữ tiền xử lý

Ngôn ngữ tiền xử lý có một số ưu điểm và nhược điểm sau:

**Ưu điểm**

- Dễ đọc và dễ hiểu hơn: Ngôn ngữ tiền xử lý có thể giúp chúng ta viết code dễ đọc và dễ hiểu hơn bằng cách thêm các tính năng mới và cú pháp mới.

- Tạo ra code có thể tái sử dụng cao hơn: Ngôn ngữ tiền xử lý có thể giúp chúng ta tạo ra code có thể tái sử dụng cao hơn bằng cách cho phép chúng ta định nghĩa các hàm và biến.

- Tạo ra code có thể bảo trì tốt hơn: Ngôn ngữ tiền xử lý có thể giúp chúng ta tạo ra code có thể bảo trì tốt hơn bằng cách cho phép chúng ta nhóm các quy tắc lại với nhau.

---

**Nhược điểm**

- Không thể chạy trực tiếp: Ngôn ngữ tiền xử lý không thể chạy trực tiếp. Chúng ta phải chuyển đổi nó thành ngôn ngữ gốc trước khi chúng ta có thể chạy nó.

- Khó học hơn so với ngôn ngữ gốc: Các cú pháp đều mới toàn bộ với người mới học. Vì vậy, nó khó học hơn so với ngôn ngữ gốc.

- Chậm hơn trong quá trình chạy: Vì các ngôn ngữ tiền xử lý phải được chuyển đổi thành ngôn ngữ gốc trước khi chúng ta có thể chạy chúng, nên chúng ta phải chờ đợi lâu hơn trong quá trình chạy.

---

## SCSS là gì?

SCSS là một ngôn ngữ tiền xử lý CSS. Nó được tạo ra bởi Hampton Catlin và Natalie Weizenbaum vào năm 2010. SCSS là một ngôn ngữ mở rộng của CSS, có nghĩa là nó có thể được chuyển đổi thành CSS thông thường.

Tuy nhiên, SCSS cung cấp nhiều tính năng bổ sung giúp chúng ta viết CSS dễ đọc và dễ bảo trì hơn.

---

## Tại sao nên chọn SCSS cho dự án Front-End?

Có nhiều lý do tại sao chúng ta nên chọn SCSS cho dự án Front-End của mình. Dưới đây là một số lý do chính:

- **SCSS dễ đọc và dễ bảo trì hơn CSS thông thường.** SCSS sử dụng cú pháp giống như CSS thông thường, nhưng nó có thêm một số tính năng giúp chúng ta viết CSS dễ đọc và dễ hiểu hơn.

  - Ví dụ: SCSS cho phép chúng ta sử dụng các hàm, biến và class để tổ chức CSS của mình.

- **SCSS có thể được mở rộng.** SCSS cho phép chúng ta tạo các hàm và biến riêng của mình để giúp chúng ta viết CSS dễ dàng hơn. Chúng ta cũng có thể sử dụng các thư viện SCSS có sẵn để mở rộng khả năng của SCSS.

- **SCSS có thể được kết hợp với các công cụ khác.** SCSS có thể được kết hợp với các công cụ khác như SASS, LESS và CSS PreProcessor. Điều này cho phép chúng ta sử dụng các tính năng của các ngôn ngữ tiền xử lý khác trong SCSS.

---

## Cú pháp SCSS

Cú pháp SCSS giống như cú pháp CSS thông thường, nhưng nó có thêm một số tính năng bổ sung. Dưới đây là một số ví dụ về cú pháp SCSS:

- **Sử dụng hàm:**

```scss
$color-red: red;

.container {
	color: $color-red;
}
```

- **Sử dụng biến:**

```scss
$font-size: 16px;

.container {
	font-size: $font-size;
}
```

- **Sử dụng class:**

```scss
.header {
	color: red;
	font-size: 16px;
}

.container {
	class: header;
}
```

---

## Code mẫu SCSS, SASS và CSS tương ứng

Dưới đây là một ví dụ về code SCSS, SASS và CSS tương ứng:

**SCSS:**

```scss
.container {
	color: red;
	font-size: 16px;
	.header {
		color: green;
		font-size: 24px;
	}
	.main {
		color: blue;
		font-size: 32px;
	}
}
```

**SASS:**

```sass
.container
  color: red
  font-size: 16px
  .header
    color: green
    font-size: 24px
  .main
    color: blue
    font-size: 32px
```

**CSS:**

```css
.container {
	color: red;
	font-size: 16px;
}
.container .header {
	color: green;
	font-size: 24px;
}
.container .main {
	color: blue;
	font-size: 32px;
}
```

---

## Kết luận

SCSS là một ngôn ngữ tiền xử lý CSS mạnh mẽ có thể giúp chúng ta viết CSS dễ đọc và dễ bảo trì hơn.

Nếu đang tìm kiếm một ngôn ngữ tiền xử lý CSS để sử dụng cho dự án Front-End của mình, thì SCSS là một lựa chọn tuyệt vời.

---

## Cách làm việc với SCSS

SCSS là một ngôn ngữ tiền xử lý CSS, được tạo ra bởi Hampton Catlin và Natalie Weizenbaum vào năm 2010.

SCSS là một ngôn ngữ mở rộng của CSS, có nghĩa là nó có thể được chuyển đổi thành CSS thông thường.

Tuy nhiên, SCSS cung cấp nhiều tính năng bổ sung giúp chúng ta viết CSS dễ đọc và dễ bảo trì hơn.

---

### **Cách sử dụng các câu lệnh command sass**

Có một số cách để sử dụng các câu lệnh command sass.

Cách đơn giản nhất là sử dụng công cụ `sass` được cài đặt trên máy tính của chúng ta.

Để chuyển đổi một tệp SCSS thành CSS, chúng ta có thể sử dụng câu lệnh sau:

```shell
sass input.scss output.css
```

---

Chúng ta cũng có thể sử dụng công cụ `sass` để chuyển đổi nhiều tệp SCSS thành CSS cùng một lúc.

Để làm điều này, chúng ta có thể sử dụng câu lệnh sau:

```shell
sass *.scss
```

---

**Cách chuyển từ SCSS về CSS**

Để chuyển từ SCSS về CSS, chúng ta có thể sử dụng công cụ `sass` như đã đề cập ở trên.

Ngoài ra, chúng ta cũng có thể sử dụng trình duyệt web của mình để chuyển từ SCSS về CSS.

Để làm điều này, chúng ta có thể thêm tệp SCSS vào trang HTML của mình và sau đó truy cập trang đó trong trình duyệt web của mình.

Trình duyệt web của chúng ta sẽ tự động chuyển đổi tệp SCSS thành CSS và hiển thị kết quả trong trình duyệt.

---

**Đường dẫn map ở trong file css**

Đường dẫn map là một tệp văn bản có chứa các bản đồ giữa các tên class SCSS và các tên class CSS.

Đường dẫn map được sử dụng để giúp trình duyệt web tìm thấy các class SCSS.

Để tạo đường dẫn map, chúng ta có thể sử dụng công cụ `sass` như sau:

```shell
sass --watch input.scss --output-map output.css.map
```

---

**Các câu lệnh build ra file min bằng scss**

Có một số cách để tạo file CSS được tối ưu hóa (minified) từ SCSS.

Cách đơn giản nhất là sử dụng công cụ `sass` với tùy chọn `--style`.

Để tạo file CSS được tối ưu hóa từ SCSS, chúng ta có thể sử dụng câu lệnh sau:

```shell
sass --style compressed input.scss output.css
```

---

### **HTML link file css**

Có một số cách để liên kết tệp CSS với HTML.

Cách đơn giản nhất là sử dụng thẻ `link`. Để liên kết một tệp CSS với HTML, chúng ta có thể sử dụng thẻ `link` như sau:

```html
<link rel="stylesheet" href="style.css" />
```

---

Chúng ta cũng có thể liên kết một thư mục CSS với HTML. Để làm điều này, chúng ta có thể sử dụng thẻ `link` như sau:

```html
<link rel="stylesheet" href="css/" />
```

---

**BEM khi sử dụng trong SCSS**

BEM là một phương pháp tổ chức CSS dựa trên ba thành phần: block, element và modifier.

BEM có thể giúp chúng ta viết CSS dễ đọc, dễ bảo trì và dễ mở rộng.

Để sử dụng BEM trong CSS, chúng ta có thể sử dụng cú pháp sau:

```css
.block {
	/* Style cho khối block */
}

.block__element {
	/* Styles cho element của block */
}

.block__element--modifier {
	/* Styles cho trạng thái, thuộc tính của element */
}
```

---

Để sử dụng BEM trong SCSS, chúng ta có thể sử dụng cú pháp sau:

```scss
.block {
	/* Style cho khối block */
	&__element {
		/* Styles cho element của block */
		&--modifier {
			/* Styles cho trạng thái, thuộc tính của element */
		}
	}
}
```

---

**Các cú pháp của SCSS như &, &&, :, >, #{}, $,...**

SCSS cung cấp một số cú pháp bổ sung giúp chúng ta viết CSS dễ đọc và dễ bảo trì hơn.

Một số cú pháp phổ biến nhất của SCSS bao gồm:

- &: Tham chiếu đến class hiện tại.
- &&: Tham chiếu đến class cha của class hiện tại.
- #{}: Định nghĩa một biến.
- ${}: Định nghĩa một hằng số.
- $: Tham chiếu đến một biến.
- @: Tham chiếu đến một hằng số.
- %: Định nghĩa một placeholder.
- @if: Định nghĩa một điều kiện.
- @for: Định nghĩa một vòng lặp.
- @each: Định nghĩa một vòng lặp.
- @while: Định nghĩa một vòng lặp.
- @mixin: Định nghĩa một mixin.
- @include: Sử dụng một mixin.
- @extend: Kế thừa một class.
- @import: Nhập một tệp SCSS.

---

## Cài đặt SASS:

1. Trước tiên, chúng ta phải có Node.js và NPM.

- Nếu chưa cài đặt, hãy cài đặt theo hướng dẫn tại đây: [nodejs.org](https://nodejs.org)

  - Hoặc với **Windows**, có thể tải luôn khi bấm vào **[đây](https://nodejs.org/dist/v18.16.1/node-v18.16.1-x64.msi)**

  - Hoặc với **MacOS**, có thể tải luôn khi bấm vào **[đây](https://nodejs.org/dist/v18.16.1/node-v18.16.1.pkg)**

- Sau khi cài đặt xong, mở **cmd** hoặc **terminal** lên và kiểm tra phiên bản của **nodejs** và **npm** bằng lệnh:

```bash
    node -v
    npm -v
```

- Nếu hiện ra phiên bản của **nodejs** và **npm** thì đã cài đặt thành công.

---

2. Tiếp theo, chúng ta cài đặt **SASS** bằng lệnh:

```bash
    npm install -g sass

    # Với MacOS, có thể cần thêm sudo
    sudo npm install -g sass # Nhập mật khẩu máy tính
```

- Nếu hiện ra phiên bản của **sass** thì đã cài đặt thành công.

---

3. Kiểm tra lại phiên bản của **sass** bằng lệnh:

```bash
    sass -v
```

- Nếu hiện ra phiên bản của **sass** thì đã cài đặt thành công.

---

4. Vì một số máy **Windows** sẽ bị lỗi biến môi trường. Chúng ta có thể fix bằng các bước sau:

Mở **Powershell** dưới quyền **Admin**

Lưu ý: Phải là **Powershell** chứ không phải **cmd**, phải là **Admin** chứ không phải **User**

```bash
    Set-ExecutionPolicy -ExecutionPolicy RemoteSigned
```

Sau đó nhấn `y` để xác nhận

```bash
    [Y] Yes  [A] Yes to All  [N] No  [L] No to All  [S] Suspend  [?] Help (default is "N"):
```

---

## Các cách biên dịch SCSS thành CSS

Có nhiều cách để biên dịch SCSS thành CSS.

Cách đơn giản nhất là sử dụng công cụ `sass` được cài đặt trên máy tính của chúng ta.

---

Để chuyển đổi một tệp SCSS thành CSS, chúng ta có thể sử dụng câu lệnh sau:

```bash
    sass input.scss output.css
```

Ở đây, chúng ta chuyển đổi một tệp SCSS có tên là `input.scss` thành một tệp CSS có tên là `output.css`.

---

Chúng ta cũng có thể sử dụng công cụ `sass` để chuyển đổi nhiều tệp SCSS thành CSS cùng một lúc.

Để làm điều này, chúng ta có thể sử dụng câu lệnh sau:

```bash
    sass *.scss
```

Ở đây, chúng ta chuyển đổi tất cả các tệp SCSS trong thư mục hiện tại thành các tệp CSS.

---

Cũng có thể chuyển đổi từ một folder chứa các file code SCSS thành một folder chứa các file code CSS.

Để làm điều này, chúng ta có thể sử dụng câu lệnh sau:

```bash
    sass scss:css
```

Ở đây, chúng ta chuyển đổi tất cả các tệp SCSS trong thư mục `scss` thành các tệp CSS trong thư mục `css`.

---

Cách biên dịch thành file min trong SCSS

Có một số cách để tạo file CSS được tối ưu hóa (minified) từ SCSS.

Cách đơn giản nhất là sử dụng công cụ `sass` với tùy chọn `--output-style`.

Để tạo file CSS được tối ưu hóa từ SCSS, chúng ta có thể sử dụng câu lệnh sau:

```bash
    sass --output-style compressed input.scss output.css
```

Ở đây, chúng ta tạo một tệp CSS được tối ưu hóa từ một tệp SCSS.

---

## Cú pháp của SCSS

- **Mixins:** Mixins là một cách để tái sử dụng các khối code CSS. Chúng ta có thể định nghĩa một mixin và sau đó gọi mixin đó từ nhiều nơi khác nhau trong code của mình.

- **Nesting:** Nesting là một cách để nhóm các quy tắc CSS lại với nhau. Chúng ta có thể sử dụng nesting để làm cho code của mình dễ đọc hơn.

- **Operators:** Operators là một cách để thực hiện các phép tính trong CSS. Chúng ta có thể sử dụng các toán tử để thực hiện các phép tính phức tạp trong CSS.

- **Partials:** Partials là một cách để chia nhỏ code CSS của chúng ta thành các tệp nhỏ hơn. Chúng ta có thể sử dụng các tệp nhỏ để làm cho code của mình dễ đọc và dễ bảo trì hơn.

- **Import:** Import là một cách để nhập các tệp CSS vào code của chúng ta. Chúng ta có thể sử dụng import để tạo code CSS động.

- **Extend:** Extend là một cách để kế thừa các quy tắc CSS từ một class khác. Chúng ta có thể sử dụng extend để tạo code CSS động.

- **Control Directives:** Control directives là một cách để thực hiện các tác vụ phức tạp trong CSS. Chúng ta có thể sử dụng control directives để tạo code CSS động.

- **Comments:** Comments là một cách để thêm chú thích vào code CSS của chúng ta. Comments có thể giúp chúng ta giải thích code của mình cho người khác.

- **Variables:** Variables là một cách để lưu trữ các giá trị CSS. Chúng ta có thể sử dụng các biến để làm cho code của mình dễ đọc và dễ bảo trì hơn.

- **Functions:** Functions là một cách để thực hiện các tác vụ phức tạp trong CSS. Chúng ta có thể sử dụng các hàm để làm cho code của mình ngắn gọn và dễ đọc hơn.

- **Interpolation:** Interpolation là một cách để chèn giá trị của một biến hoặc hàm vào chuỗi văn bản. Chúng ta có thể sử dụng interpolation để tạo code CSS động.

- **Comments:** Comments là một cách để thêm chú thích vào code CSS của chúng ta. Comments có thể giúp chúng ta giải thích code của mình cho người khác.

- **At-rules:** At-rules là một cách để thêm các chức năng bổ sung vào CSS của chúng ta. Có một số at-rules phổ biến, chẳng hạn như `@import`, `@media` và `@font-face`.

---

## Các cú pháp của SCSS phổ biến

Một số cú pháp SCSS phổ biến nhất bao gồm:

- &: Tham chiếu đến class hiện tại.

- &&: Tham chiếu đến class cha của class hiện tại.

- #{}: Định nghĩa một biến.

- ${}: Định nghĩa một hằng số.

- $: Tham chiếu đến một biến.

- @: Tham chiếu đến một hằng số.

- %: Định nghĩa một placeholder.

- @if: Định nghĩa một điều kiện.

- @for: Định nghĩa một vòng lặp.

- @each: Định nghĩa một vòng lặp.

- @while: Định nghĩa một vòng lặp.

- @mixin: Định nghĩa một mixin.

- @include: Sử dụng một mixin.

- @extend: Kế thừa một class.

- @import: Nhập một tệp SCSS.

---

## Ví dụ về cú pháp SCSS

Dưới đây là một số ví dụ về cú pháp SCSS:

- **Sử dụng biến:**

```scss
$font-size: 16px;

.container {
	font-size: $font-size;
}
```

Ở css sẽ biên dịch thành:

```css
.container {
	font-size: 16px;
}
```

---

- **Sử dụng mixin:**

```scss
@mixin size($width, $height: $width) {
	width: $width;
	height: $height;
}
.box {
	@include size(100px);
}
.box2 {
	@include size(100px, 200px);
}
```

Ở ví dụ trên, chúng ta định nghĩa một mixin có tên là `size`. Ví dụ này có hai tham số: `width` và `height`. Tham số `height` có giá trị mặc định là `width`.

Nếu chỉ truyền một tham số cho mixin, thì tham số `width` sẽ có giá trị là tham số đó và tham số `height` sẽ có giá trị là tham số `width`.

Nếu truyền hai tham số cho mixin, thì tham số `width` sẽ có giá trị là tham số đầu tiên và tham số `height` sẽ có giá trị là tham số thứ hai.

Ở css sẽ biên dịch thành:

```css
.box {
	width: 100px;
	height: 100px;
}
.box2 {
	width: 100px;
	height: 200px;
}
```

---

- **Sử dụng placeholder:**

```scss
%box {
	width: 100px;
	height: 100px;
}
.box {
	@extend %box;
}
```

Ở ví dụ trên, chúng ta định nghĩa một placeholder có tên là `box`. Sau đó, chúng ta kế thừa placeholder đó trong một class có tên là `box`.

Nó khác gì với mixin?

- Nếu chúng ta sử dụng mixin, thì mixin sẽ được chuyển đổi thành CSS và được thêm vào code của chúng ta.

- Nếu chúng ta sử dụng placeholder, thì placeholder sẽ không được chuyển đổi thành CSS và sẽ được thêm vào code của chúng ta.

Ở css sẽ biên dịch thành:

```css
.box {
	width: 100px;
	height: 100px;
}
```

---

- **Sử dụng điều kiện:**

```scss
$color: red;

.container {
	@if $color == red {
		color: red;
	} @else if $color == green {
		color: green;
	} @else {
		color: blue;
	}
}
```

Ở ví dụ trên, chúng ta sử dụng câu lệnh `@if` để kiểm tra giá trị của biến `$color`.
Nếu giá trị của biến `$color` là `red`, thì chúng ta sẽ đặt màu chữ là `red`.
Nếu giá trị của biến `$color` là `green`, thì chúng ta sẽ đặt màu chữ là `green`.
Nếu giá trị của biến `$color` không phải là `red` hoặc `green`, thì chúng ta sẽ đặt màu chữ là `blue`.

Ở css sẽ biên dịch thành:

```css
.container {
	color: red;
}
```

---

- **Sử dụng vòng lặp each:**

```scss
$colors: red, green, blue;

@each $color in $colors {
	.#{$color} {
		color: $color;
	}
}
```

Ở ví dụ trên, chúng ta sử dụng câu lệnh `@each` để lặp qua một danh sách các giá trị.

Trong mỗi lần lặp, chúng ta sẽ đặt màu chữ là giá trị hiện tại.

Ở css sẽ biên dịch thành:

```css
.red {
	color: red;
}
.green {
	color: green;
}
.blue {
	color: blue;
}
```

---

- **Sử dụng vòng lặp for through:**

```scss
@for $i from 1 through 3 {
	.box-#{$i} {
		width: 100px * $i;
	}
}
```

Ở ví dụ trên, chúng ta sử dụng câu lệnh `@for` để lặp qua một danh sách các giá trị.

Trong mỗi lần lặp, chúng ta sẽ đặt chiều rộng là giá trị hiện tại nhân với `100px`.

Ở css sẽ biên dịch thành:

```css
.box-1 {
	width: 100px;
}
.box-2 {
	width: 200px;
}
.box-3 {
	width: 300px;
}
```

---

- **Sử dụng vòng lặp for to:**

```scss
@for $i from 1 to 3 {
	.box-#{$i} {
		width: 100px * $i;
	}
}
```

Ở ví dụ trên, chúng ta sử dụng câu lệnh `@for` để lặp qua một danh sách các giá trị.

Trong mỗi lần lặp, chúng ta sẽ đặt chiều rộng là giá trị hiện tại nhân với `100px`.

- Vậy nó khác gì với vòng lặp `for through`?

  - Nếu chúng ta sử dụng vòng lặp `for through`, thì chúng ta sẽ lặp qua tất cả các giá trị trong danh sách.

  - Nếu chúng ta sử dụng vòng lặp `for to`, thì chúng ta sẽ lặp qua tất cả các giá trị trong danh sách trừ giá trị cuối cùng.

Ở css sẽ biên dịch thành:

```css
.box-1 {
	width: 100px;
}
.box-2 {
	width: 200px;
}
```

---

- **Sử dụng vòng lặp while:**

```scss
$i: 1;

@while $i < 3 {
	.box-#{$i} {
		width: 100px * $i;
	}
	$i: $i + 1;
}
```

Ở ví dụ trên, chúng ta sử dụng câu lệnh `@while` để lặp qua một danh sách các giá trị.

Trong mỗi lần lặp, chúng ta sẽ đặt chiều rộng là giá trị hiện tại nhân với `100px`.

- Vậy nó khác gì so với các vòng lặp trên?

  - Nếu chúng ta sử dụng vòng lặp `for through` hoặc `for to`, thì chúng ta sẽ lặp qua tất cả các giá trị trong danh sách.

  - Nếu chúng ta sử dụng vòng lặp `while`, thì chúng ta sẽ lặp qua các giá trị trong danh sách cho đến khi một điều kiện nhất định được đáp ứng.

Ở css sẽ biên dịch thành:

```css
.box-1 {
	width: 100px;
}
.box-2 {
	width: 200px;
}
```

---

- **Sử dụng hàm:**

```scss
@function size($width, $height: $width) {
	@return $width + $height;
}
.box {
	width: size(100px);
}
.box2 {
	width: size(100px, 200px);
}
```

Ở ví dụ trên, chúng ta định nghĩa một hàm có tên là `size`. Ví dụ này có hai tham số: `width` và `height`.

Tham số `height` có giá trị mặc định là `width`.

Nếu chỉ truyền một tham số cho hàm, thì tham số `width` sẽ có giá trị là tham số đó và tham số `height` sẽ có giá trị là tham số `width`.

Nếu truyền hai tham số cho hàm, thì tham số `width` sẽ có giá trị là tham số đầu tiên và tham số `height` sẽ có giá trị là tham số thứ hai.

Ở ví dụ trên, chúng ta sử dụng hàm `size` để tính toán chiều rộng của một box.

Ở css sẽ biên dịch thành:

```css
.box {
	width: 200px;
}
.box2 {
	width: 300px;
}
```

---

- **Sử dụng biểu thức:**

```scss
.container {
	width: 100px + 200px;
}
```

Ở ví dụ trên, chúng ta sử dụng biểu thức để tính toán chiều rộng của một box.

---

- **Sử dụng nesting:**

```scss
.container {
	color: red;
	.header {
		color: green;
		.main {
			color: blue;
		}
	}
}
```

Ở ví dụ trên, chúng ta sử dụng nesting để nhóm các quy tắc CSS lại với nhau.

Ở css sẽ biên dịch thành:

```css
.container {
	color: red;
}
.container .header {
	color: green;
}
.container .header .main {
	color: blue;
}
```

---

- **Sử dụng import:**

```scss
@import 'variables';

.container {
	color: $color;
}
```

Ở ví dụ trên, chúng ta sử dụng import để nhập một tệp SCSS vào code của chúng ta.

Ở css sẽ biên dịch thành:

```css
/* 
file variable không được biên dịch. 
Trong file variable có định nghĩa biến $color = red
*/
.container {
	color: red;
}
```

- **Sử dụng extend:**

```scss
.box {
	width: 100px;
	height: 100px;
}
.box2 {
	@extend %box;
}
```

Ở ví dụ trên, chúng ta sử dụng extend để kế thừa các quy tắc CSS từ một class khác.

Ở css sẽ biên dịch thành:

```css
.box {
	width: 100px;
	height: 100px;
}
.box2 {
	width: 100px;
	height: 100px;
}
```

---

- **Sử dụng comments:**

```scss
// This is a single-line comment.

/*
This is a multi-line comment.
*/
```

Ở ví dụ trên, chúng ta sử dụng comments để thêm chú thích vào code của chúng ta.

Ở css sẽ biên dịch thành:

```css
/* This is a multi-line comment. */
```

Vì comment bằng `//` là comment trong SCSS, nên nó sẽ không được biên dịch thành CSS.

---

## Biến trong SCSS

SCSS là một ngôn ngữ tiền xử lý CSS, có nghĩa là nó có thể được chuyển đổi thành CSS thông thường.

Tuy nhiên, SCSS cung cấp nhiều tính năng bổ sung giúp chúng ta viết CSS dễ đọc và dễ bảo trì hơn.

Một trong những tính năng bổ sung của SCSS là biến.

Biến là một cách để lưu trữ các giá trị CSS.

Chúng ta có thể sử dụng biến để làm cho code của mình dễ đọc và dễ bảo trì hơn.

---

### Định nghĩa biến

Biến trong SCSS được định nghĩa bằng cú pháp sau:

```scss
$key: value;
```

Trong đó:

- `key`: là tên của biến.
- `value`: là giá trị của biến.

---

### Ví dụ

Dưới đây là một ví dụ về cách định nghĩa một biến trong SCSS:

```scss
$color-red: red;
```

Biến `color-red` có giá trị là `red`.

---

### Sử dụng biến

Chúng ta có thể sử dụng biến trong SCSS bằng cách sử dụng cú pháp sau:

```scss
.container {
	color: $color-red;
}
```

Trong ví dụ trên, biến `color-red` được sử dụng để đặt màu cho phần tử `.container` thành đỏ.

---

## Biến cục bộ và biến toàn cục

Trong SCSS, có hai loại biến: biến cục bộ và biến toàn cục.

- Biến cục bộ được giới hạn trong một khối code.
- Biến toàn cục có thể được sử dụng trong bất kỳ khối code nào.

---

### Ví dụ

Dưới đây là một ví dụ về cách sử dụng biến cục bộ trong SCSS:

```scss
.container {
	$color-red: #f00;
	color: $color-red;
}
```

Biến `color-red` chỉ có thể được sử dụng trong khối code của phần tử `.container`.

Sau khi biên dịch, đoạn code css sẽ thành:

```css
.container {
	color: #f00;
}
```

---

Dưới đây là một ví dụ về cách sử dụng biến toàn cục trong SCSS:

```scss
$color-red: red;

.container {
	color: $color-red;
}

.box {
	color: $color-red;
}
```

Biến `color-red` có thể được sử dụng trong cả hai khối code của phần tử `.container` và phần tử `.box`.

Sau khi biên dịch, đoạn code css sẽ thành:

```css
.container {
	color: red;
}

.box {
	color: red;
}
```

---

## Phân biệt biến trong SCSS và biến trong CSS

Biến trong SCSS và biến trong CSS đều có thể được sử dụng để lưu trữ các giá trị CSS.
Tuy nhiên, có một số điểm khác biệt giữa hai loại biến này:

- Biến trong SCSS có thể được sử dụng trong các khối code CSS và Sass.

- Biến trong CSS chỉ có thể được sử dụng trong các khối code CSS.

- Biến trong SCSS có thể được sử dụng để lưu trữ các giá trị, thuộc tính, tên selector,...

- Biến trong CSS chỉ có thể được sử dụng để lưu trữ các giá trị.

- Biến trong SCSS có thể được sử dụng để lưu trữ các giá trị CSS.

- Sử dụng biến trong file khác nhau:

  - SCSS cần import file chứa biến để sử dụng biến trong file khác.

  - CSS không cần import file chứa biến để sử dụng biến trong file khác.

- Sau khi biên dịch:

  - Biến của SCSS sẽ thành giá trị của biến.

  - Biến của CSS sẽ không thay đổi.

---

## Kết luận

Biến là một tính năng mạnh mẽ của SCSS có thể giúp chúng ta viết CSS dễ đọc và dễ bảo trì hơn.

Chúng ta có thể sử dụng biến để lưu trữ các giá trị CSS, làm cho code của mình ngắn gọn và dễ hiểu hơn.

---

## Toán tử trong SCSS

- **Toán tử số học:**
  - `+` - Cộng
  - `-` - Trừ
  - `*` - Nhân
  - `/` - Chia
  - `%` - Chia lấy phần dư
  ***
- **Toán tử logic:**
  - `and` - Và
  - `or` - Hoặc
  - `!` - Phủ định (not)
  ***
- **Toán tử so sánh:**
  - `==` - Bằng
  - `!=` - Khác
  - `<` - Nhỏ hơn
  - `>` - Lớn hơn
  - `<=` - Nhỏ hơn hoặc bằng
  - `>=` - Lớn hơn hoặc bằng
  ***

## Ví dụ về toán tử trong SCSS

Dưới đây là một số ví dụ về toán tử trong SCSS:

- **Toán tử số học:**

```scss
.container {
	width: 100px + 200px;
	height: 100px - 50px;
	font-size: 16px * 2;
	line-height: 1px / 2;
	margin: 10px % 3;
}
```

Ở ví dụ trên, chúng ta sử dụng các toán tử số học để tính toán các giá trị CSS.

Ở css sẽ biên dịch thành:

```css
.container {
	width: 300px;
	height: 50px;
	font-size: 32px;
	line-height: 0.5px;
	margin: 1px;
}
```

---

- **Toán tử logic:**

```scss
$color-red: red;
$color-green: green;
$color-blue: blue;
.container {
	@if $color-red == red and $color-green == blue {
		color: $color-blue;
	}
	.box {
		@if $color-red == red and $color-green == blue {
			color: $color-blue;
		}
		.item {
			@if not $color-blue == red {
				color: $color-red;
			}
		}
	}
}
```

Ở ví dụ trên, chúng ta sử dụng các toán tử logic để kiểm tra giá trị của biến.

- `.container`: Nếu giá trị của biến `$color-red` là `red` và giá trị của biến `$color-green` là `blue`, thì chúng ta sẽ đặt màu chữ là giá trị của biến `$color-blue`.

- `.box`: Nếu giá trị của biến `$color-red` là `red` và giá trị của biến `$color-green` là `blue`, thì chúng ta sẽ đặt màu chữ là giá trị của biến `$color-blue`.

- `.item`: Nếu giá trị của biến `$color-blue` không phải là `red`, thì chúng ta sẽ đặt màu chữ là giá trị của biến `$color-red`.

Ở css sẽ biên dịch thành:

```css
.container {
	color: blue;
}
.container .box {
	color: blue;
}
.container .box .item {
	color: red;
}
```

---

- **Toán tử so sánh:**

```scss
$color-red: red;
$color-green: green;
$color-blue: blue;
$max-width: 1000px;
$min-width: 500px;
.container {
	@if $color-red == red {
		color: $color-red;
	}
	.box {
		@if $color-red != red {
			color: $color-green;
		}
		.item {
			@if $min-width > 500px and $max-width < 1000px {
				color: $color-blue;
			}
			&:hover {
				@if $max-width <= 1000px and $min-width >= 500px {
					color: $color-red;
				}
			}
		}
	}
}
```

Ở ví dụ trên, chúng ta sử dụng các toán tử so sánh để kiểm tra giá trị của biến.

- `.container`: Nếu giá trị của biến `$color-red` là `red`, thì chúng ta sẽ đặt màu chữ là giá trị của biến `$color-red`.

- `.box`: Nếu giá trị của biến `$color-red` không phải là `red`, thì chúng ta sẽ đặt màu chữ là giá trị của biến `$color-green`.

- `.item`: Nếu giá trị của biến `$min-width` lớn hơn `500px` và giá trị của biến `$max-width` nhỏ hơn `1000px`, thì chúng ta sẽ đặt màu chữ là giá trị của biến `$color-blue`.

- `.item:hover`: Nếu giá trị của biến `$max-width` nhỏ hơn hoặc bằng `1000px` và giá trị của biến `$min-width` lớn hơn hoặc bằng `500px`, thì chúng ta sẽ đặt màu chữ là giá trị của biến `$color-red`.

Ở css sẽ biên dịch thành:

```css
.container {
	color: red;
}
.container .box {
	color: green;
}
.container .box .item {
	color: blue;
}
.container .box .item:hover {
	color: red;
}
```

---

## Kết luận

Toán tử là một tính năng mạnh mẽ của SCSS có thể giúp chúng ta viết CSS dễ đọc và dễ bảo trì hơn.

Chúng ta có thể sử dụng toán tử để tính toán các giá trị CSS, làm cho code của mình ngắn gọn và dễ hiểu hơn.

---

## Phân cấp trong SCSS (nesting)

Phân cấp trong SCSS là một tính năng cho phép chúng ta lồng các quy tắc CSS bên trong nhau.

Điều này có thể giúp chúng ta tổ chức code CSS của mình và dễ dàng áp dụng các kiểu cho các phần tử con của một phần tử.

---

## Cách sử dụng phân cấp

Để sử dụng phân cấp, chúng ta chỉ cần đặt các quy tắc CSS bên trong nhau. Ví dụ:

```scss
.container {
	width: 100px;
	height: 100px;

	.child {
		color: red;
	}
}
```

Trong ví dụ trên, quy tắc `.child` được lồng bên trong quy tắc `.container`. Điều này có nghĩa là quy tắc `.child` sẽ được áp dụng cho các phần tử con của phần tử `.container`.

Ở css sẽ biên dịch thành:

```css
.container {
	width: 100px;
	height: 100px;
}
.container .child {
	color: red;
}
```

---

## Cách lồng cấp

Chúng ta có thể lồng các quy tắc CSS ở bất kỳ cấp độ nào. Ví dụ:

```scss
.container {
	width: 100px;
	height: 100px;

	.child {
		color: red;

		.grandchild {
			font-size: 16px;
		}
	}
}
```

Trong ví dụ trên, quy tắc `.grandchild` được lồng bên trong quy tắc `.child` và quy tắc `.child` được lồng bên trong quy tắc `.container`.

Điều này có nghĩa là quy tắc `.grandchild` sẽ được áp dụng cho các phần tử con của phần tử `.child` và các phần tử con của phần tử `.child` sẽ là các phần tử con của phần tử `.container`.

Ở css sẽ biên dịch thành:

```css
.container {
	width: 100px;
	height: 100px;
}
.container .child {
	color: red;
}
.container .child .grandchild {
	font-size: 16px;
}
```

---

## Cách sử dụng `&` trong phân cấp

Chúng ta có thể sử dụng ký hiệu `&` trong phân cấp để tham chiếu đến class hiện tại. Ví dụ:

```scss
.container {
	width: 100px;
	height: 100px;

	.child {
		color: red;

		&:hover {
			color: blue;
		}
	}
}
```

Trong ví dụ trên, quy tắc `.child:hover` sẽ áp dụng cho các phần tử `.child` khi chúng được di chuột qua.

Điều này là do ký hiệu `&` được sử dụng để tham chiếu đến class hiện tại, trong trường hợp này là `.child`.

Ở css sẽ biên dịch thành:

```css
.container {
	width: 100px;
	height: 100px;
}

.container .child {
	color: red;
}

.container .child:hover {
	color: blue;
}
```

---

Nếu muốn nối từ phần tử cha vào phần tử con, chúng ta có thể sử dụng ký hiệu `&` như sau:

```scss
.header__navbar {
	width: 100px;
	height: 100px;

	&--active {
		color: red;
	}
}
```

Ở đây, class của cha là `.header__navbar`, class của con sẽ nối từ cha vào là `.header__navbar--active`.

Ở css sẽ biên dịch thành:

```css
.header__navbar {
	width: 100px;
	height: 100px;
}

.header__navbar--active {
	color: red;
}
```

---

## Cách sử dụng các toán tử nối vào trong phân cấp

Chúng ta có thể sử dụng các toán tử nối vào trong phân cấp để áp dụng các kiểu cho các phần tử con của một phần tử theo một cách cụ thể. Ví dụ:

```scss
.container {
	width: 100px;
	height: 100px;

	.child {
		color: red;

		> .grandchild {
			font-size: 16px;
		}
	}
}
```

Trong ví dụ trên, quy tắc `.grandchild` sẽ chỉ được áp dụng cho các phần tử con trực tiếp của phần tử `.child`. Điều này là do toán tử `>` được sử dụng để chỉ định các phần tử con trực tiếp.

Ở css sẽ biên dịch thành:

```css
.container {
	width: 100px;
	height: 100px;
}
.container .child {
	color: red;
}
.container .child > .grandchild {
	font-size: 16px;
}
```

---

Chúng ta có thể sử dụng các toán tử nối khác như:

- Nối bằng dấu cách: ` `

```scss
.container {
	width: 100px;
	height: 100px;

	.child {
		color: red;

		.grandchild {
			font-size: 16px;
		}
	}
}
```

Ở đây, class của cha là `.container`, class của con sẽ nối từ cha vào là `.container .child`.

Ở css sẽ biên dịch thành:

```css
.container {
	width: 100px;
	height: 100px;
}

.container .child {
	color: red;
}

.container .child .grandchild {
	font-size: 16px;
}
```

---

- Nối bằng dấu `+`

```scss
.container {
	width: 100px;
	height: 100px;

	.child {
		color: red;

		&:hover {
			+ .next-child {
				font-size: 16px;
			}
		}
	}
}
```

Ở đây, class của cha là `.container`, class của con sẽ nối từ cha vào là `.container .child`.

- Sau khi hover vào phần tử `.child`, class của phần tử tiếp theo sẽ nối từ phần tử `.child` vào là `.container .child + .next-child`.

Ở css sẽ biên dịch thành:

```css
.container {
	width: 100px;
	height: 100px;
}

.container .child {
	color: red;
}

.container .child:hover + .next-child {
	font-size: 16px;
}
```

---

- Nối bằng dấu `~`

```scss
.container {
	width: 100px;
	height: 100px;

	.child {
		color: red;

		&:hover {
			~ .next-child {
				font-size: 16px;
			}
		}
	}
}
```

Ở đây, class của cha là `.container`, class của con sẽ nối từ cha vào là `.container .child`.

- Sau khi hover vào phần tử `.child`, class của phần tử tiếp theo sẽ nối từ phần tử `.child` vào là `.container .child ~ .next-child`.

Ở css sẽ biên dịch thành:

```css
.container {
	width: 100px;
	height: 100px;
}

.container .child {
	color: red;
}

.container .child:hover ~ .next-child {
	font-size: 16px;
}
```

---

## Lưu ý khi sử dụng phân cấp(nesting)

- Nếu lồng nhiều cấp quá sâu, thì sẽ làm cho code css của chúng ta dài và khó đọc.

- Nếu sử dụng BEM, có thể hạn chế nối nhiều cấp quá sâu.

## Kết luận

Phân cấp là một tính năng mạnh mẽ của SCSS có thể giúp chúng ta viết CSS dễ đọc và dễ bảo trì hơn.

Chúng ta có thể sử dụng phân cấp để tổ chức code CSS của mình và dễ dàng áp dụng các kiểu cho các phần tử con của một phần tử.

> Nếu cảm thấy khó tiếp cận quá thì hãy coi nó như cấu trúc bọc cha con của HTML nhé :3

---

## Các cách kế thừa trong SCSS: extends, mixin, placeholder,...

Kế thừa trong SCSS là một tính năng cho phép chúng ta sử dụng lại các định nghĩa CSS từ một nơi khác.

Điều này có thể giúp chúng ta tiết kiệm thời gian và code của chúng ta cũng sẽ dễ đọc và bảo trì hơn.

Có một số cách khác nhau để kế thừa trong SCSS, bao gồm:

- **Extends:** extends cho phép chúng ta kế thừa các định nghĩa CSS từ một class khác.
- **Mixins:** mixins cho phép chúng ta tạo các định nghĩa CSS có thể được sử dụng lại trong nhiều nơi khác nhau.
- **Placeholders:** placeholders cho phép chúng ta sử dụng các biến trong định nghĩa CSS của mình.
- **Includes:** includes cho phép chúng ta đưa các tệp CSS khác vào tệp CSS của mình.

---

### Công dụng của kế thừa trong các hàm của SCSS

Kế thừa trong SCSS có thể được sử dụng để:

- Tiết kiệm thời gian bằng cách sử dụng lại các định nghĩa CSS từ một nơi khác.
- Làm cho code của chúng ta dễ đọc và bảo trì hơn.
- Tạo các định nghĩa CSS linh hoạt hơn.
- Tạo các định nghĩa CSS có thể tùy chỉnh hơn.

---

## Extends

Extends là một tính năng trong SCSS cho phép chúng ta kế thừa các định nghĩa CSS từ một class khác. Cú pháp của extends là:

```scss
.parent {
	color: red;
}
.child {
	@extend .parent;
}
```

Trong ví dụ trên, class `.child` sẽ kế thừa các định nghĩa CSS từ class `.parent`. Điều này có nghĩa là các thuộc tính CSS được định nghĩa trong class `.parent` cũng sẽ được áp dụng cho class `.child`.

Ở css sẽ biên dịch thành:

```css
.parent,
.child {
	color: red;
}
```

---

Ngoài ra extend còn được sử dụng với placeholder như sau:

```scss
%color-red {
	color: red;
}
.child {
	@extend %color-red;
}
```

Ở ví dụ trên, class `.child` sẽ kế thừa các định nghĩa CSS từ placeholder `%color-red`. Điều này có nghĩa là các thuộc tính CSS được định nghĩa trong placeholder `%color-red` cũng sẽ được áp dụng cho class `.child`.

Ở css sẽ biên dịch thành:

```css
.child {
	color: red;
}
```

---

## Mixins

Mixins là một tính năng trong SCSS cho phép chúng ta tạo các định nghĩa CSS có thể được sử dụng lại trong nhiều nơi khác nhau. Cú pháp của mixins là:

```scss
@mixin mixin {
	color: red;
	&:hover {
		color: blue;
	}
}
```

Sau khi chúng ta đã tạo một mixin, chúng ta có thể sử dụng nó bằng cách gọi nó như sau:

```scss
.element {
	@include mixin;
}
```

Trong ví dụ trên, định nghĩa CSS của mixin `mixin` sẽ được áp dụng cho class `.element`.

Ở css sẽ biên dịch thành:

```css
.element {
	color: red;
}
.element:hover {
	color: blue;
}
```

---

## Placeholders

Placeholders là một tính năng trong SCSS cho phép chúng ta sử dụng các biến trong định nghĩa CSS của mình. Cú pháp của placeholders là:

```scss
$color: red;
$background-color: blue;
%placeholder {
	color: $color;
	background-color: $background-color;
}
.element {
	@extend %placeholder;
}
```

Trong ví dụ trên, định nghĩa CSS của placeholder `%placeholder` sẽ được áp dụng cho class `.element`.

- Các biến `$color` và `$background-color` đã được định nghĩa trước đó. Và giá trị của chúng sẽ được sử dụng trong định nghĩa CSS của placeholder `%placeholder`.

Ở css sẽ biên dịch thành:

```css
.element {
	color: red;
	background-color: blue;
}
```

---

## Includes

Includes thường được sử dụng kèm với mixins để tạo ra các định nghĩa CSS có thể được sử dụng lại trong nhiều nơi khác nhau.

Cú pháp của includes là:

```scss
@mixin mixin {
	color: red;
	&:hover {
		color: blue;
	}
}
.element {
	@include mixin;
}
```

Ở ví dụ trên, chúng ta sử dụng includes để đưa định nghĩa CSS của mixin `mixin` vào class `.element`.

Ở css sẽ biên dịch thành:

```css
.element {
	color: red;
}
.element:hover {
	color: blue;
}
```

---

## Import

Import có một tính năng trong SCSS cho phép chúng ta đưa các file SCSS khác vào file CSS của mình.

Cú pháp của includes là:

```scss
@import file-name;
```

Trong ví dụ trên, file SCSS có tên `file-name.scss` sẽ được đưa vào file SCSS hiện tại.

Điều này có nghĩa là các định nghĩa CSS trong file `file-name.scss` cũng sẽ được áp dụng cho file CSS hiện tại.

---

Ví dụ:

Ở file `style.scss` chúng ta có đoạn code sau:

```scss
@import background;
p {
	color: red;
}
```

Và ở file `background.scss` chúng ta có đoạn code sau:

```scss
body {
	background-color: red;
}
```

Ở css sẽ biên dịch thành:

```css
/* 
File background.scss sẽ được đưa vào file style.scss
Và đây là file style.scss
*/
body {
	background-color: red;
}
p {
	color: red;
}
```

---

## Kết luận

Kế thừa là một tính năng mạnh mẽ của SCSS có thể giúp chúng ta viết CSS dễ đọc và dễ bảo trì hơn.

Chúng ta có thể sử dụng kế thừa để tiết kiệm thời gian và code của chúng ta cũng sẽ dễ đọc và bảo trì hơn.

---

## Functions trong SCSS

Functions trong SCSS là một cách để tái sử dụng các khối code CSS.

Chúng ta có thể định nghĩa một hàm và sau đó gọi nó từ nhiều nơi khác nhau trong code của mình.

Điều này có thể giúp chúng ta tiết kiệm thời gian và code của chúng ta cũng sẽ dễ đọc và bảo trì hơn.

---

## Phân biệt function và mixin trong scss.

Functions và mixins đều là các cách để tái sử dụng các khối code CSS.

Tuy nhiên, có một số điểm khác biệt chính giữa hai tính năng này.

- **Functions** trả về một giá trị, trong khi **mixins** không.

- **Functions** có thể được gọi với các tham số, trong khi **mixins** không.

- **Functions** có thể được sử dụng để tạo các khối code CSS có độ phức tạp cao hơn, trong khi **mixins** thường được sử dụng để tạo các khối code CSS đơn giản hơn.

---

### So sánh mặt khác nhau hoàn toàn giữa function và mixin.

| Tính năng      | Function                                 | Mixin                              |
| -------------- | ---------------------------------------- | ---------------------------------- |
| Trả về giá trị | Có                                       | Không                              |
| Có tham số     | Có hoặc không                            | Không                              |
| Độ phức tạp    | Có thể cao                               | Thường thấp                        |
| Sử dụng        | Tạo các khối code CSS có độ phức tạp cao | Tạo các khối code CSS đơn giản hơn |

---

Ví dụ:

- **Functions** trả về một giá trị, trong khi **mixins** không.

```scss
@function getSize($width: 100px, $height: 100px) {
  $size = ($width * $height) / 2;
  @return $size;
}

@mixin size($width: 100px, $height: 100px) {
  area: ($width * $height) / 2;
}

.box1 {
  area: getSize();
  width: getSize(10px, 10px);
  height: getSize(20px, 20px);
}
.box2 {
  @include size();
  width: 50px;
  height: 200px;
}
```

Ở ví dụ trên, chúng ta định nghĩa một function `getSize()` và một mixin `size()`.

- Function `getSize()` trả về giá trị của biến `$size`. Và chúng ta có thể sử dụng nó cho bất kỳ thuộc tính nào có thể kết hợp.

- Mixin `size()` không trả về giá trị nào cả. Và chúng ta chỉ có thể sử dụng nó cho thuộc tính `area`.

Ở css sẽ biên dịch thành:

```css
.box1 {
	area: 500px;
	width: 50px;
	height: 200px;
}
.box2 {
	area: 500px;
	width: 50px;
	height: 200px;
}
```

---

## Function không return và có return.

- **Functions** không return trả về giá trị nào cả.

Chúng chỉ được sử dụng để thực hiện một số tác vụ và không trả về bất kỳ giá trị nào.

Ví dụ:

```scss
@function getSize($width: 100px, $height: 100px) {
  $size = ($width * $height) / 2;
  @debug $size;
}
```

Ở ví dụ trên, chúng ta định nghĩa một function `getSize()`.

- Function `getSize()` không trả về giá trị nào cả. Và chúng ta chỉ có thể sử dụng nó để in ra giá trị của biến `$size`.

Ở css sẽ biên dịch thành:

```css
/*
Đoạn code này sẽ được in ra trong console của trình duyệt
*/
getsize: 500px;
```

---

- **Functions** có return trả về một giá trị.

Giá trị này có thể được sử dụng trong phần còn lại của code CSS của chúng ta.

Ví dụ:

```scss
@function getSize($width: 100px, $height: 100px) {
  $size = ($width * $height) / 2;
  @return $size;
}
.box {
  width: getSize(10px, 10px);
  height: getSize(20px, 20px);
}
```

Ở ví dụ trên, chúng ta định nghĩa một function `getSize()`. Function `getSize()` trả về giá trị của biến `$size`. Và chúng ta có thể sử dụng nó cho bất kỳ thuộc tính nào có thể kết hợp.

Ở css sẽ biên dịch thành:

```css
.box {
	width: 50px;
	height: 200px;
}
```

### Cách sử dụng function có tham số và không có tham số.

- **Functions** không có tham số có thể được gọi mà không cần cung cấp bất kỳ giá trị nào cho chúng.

Ví dụ:

```scss
@function getSize() {
  @if $width > 100px {
    $size = ($width * $height) / 2;
    @return $size;
  }
  @return $size;
}
.box {
  $width: 100px;
  $height: 100px;
  width: getSize();
  height: getSize();
}
```

Ở đây, chúng ta định nghĩa một function `getSize()`. Function `getSize()` không có tham số. Và chúng ta có thể gọi nó mà không cần cung cấp bất kỳ giá trị nào cho nó.

Ở css sẽ biên dịch thành:

```css
.box {
	width: 50px;
	height: 200px;
}
```

---

- **Functions** có tham số phải được gọi bằng cách cung cấp các giá trị cho các tham số của chúng. Giá trị của các tham số được đặt trong cặp ngoặc vuông sau tên của hàm.

Ví dụ:

```scss
@function getSize($width: 100px, $height: 100px) {
  $size = ($width * $height) / 2;
  @return $size;
}
.box {
  width: getSize(10px, 10px);
  height: getSize(20px, 20px);
}
```

Ở đây, chúng ta định nghĩa một function `getSize()`. Function `getSize()` có hai tham số là `$width` và `$height`. Và chúng ta có thể gọi nó bằng cách cung cấp các giá trị cho các tham số của nó.

Ở css sẽ biên dịch thành:

```css
.box {
	width: 50px;
	height: 200px;
}
```

### Lưu ý khi sử dụng function.

- Khi sử dụng functions, điều quan trọng là phải đặt tên cho chúng một cách rõ ràng và mô tả. Điều này sẽ giúp chúng ta dễ dàng tìm thấy và sử dụng chúng trong code của mình.

- Chúng ta cũng nên tránh sử dụng các functions quá phức tạp. Functions phức tạp có thể khó đọc và bảo trì.

---

## Các điểm lợi khi sử dụng hàm.

- **Functions** có thể giúp chúng ta tiết kiệm thời gian bằng cách tái sử dụng các khối code CSS.

- **Functions** có thể giúp chúng ta làm cho code của mình dễ đọc và bảo trì hơn.

- **Functions** có thể giúp chúng ta tạo các khối code CSS có độ phức tạp cao hơn.

---

## Kết luận

Functions là một tính năng mạnh mẽ của SCSS có thể giúp chúng ta tiết kiệm thời gian và làm cho code của mình dễ đọc và bảo trì hơn.

---

## Câu lệnh rẽ nhánh `@if` `@else`

`@if` là một câu lệnh rẽ nhánh trong SCSS cho phép chúng ta kiểm tra một điều kiện và thực thi một khối code nếu điều kiện đó đúng, hoặc một khối code khác nếu điều kiện đó sai.

Cú pháp của câu lệnh `@if` là:

```scss
@if <condition> {
  <code to be executed if condition is true>
}
@else {
  <code to be executed if condition is false>
}
```

---

Trong đó, `<condition>` là một biểu thức boolean, và `<code>` là code CSS.

Ví dụ:

```scss
@if $color == 'red' {
	.container {
		color: red;
	}
} @else {
	.container {
		color: blue;
	}
}
```

Trong ví dụ trên, code CSS `.container { color: red; }` sẽ được thực thi nếu biến `$color` có giá trị là `red`, và code CSS `.container { color: blue; }` sẽ được thực thi nếu biến `$color` có giá trị khác `red`.

Ở css sẽ biên dịch thành:

```css
.container {
	color: red;
}
```

---

Chúng ta cũng có thể sử dụng câu lệnh `@if` để thực thi nhiều khối code CSS nếu điều kiện đó đúng.

Cú pháp của câu lệnh `@if` với nhiều khối code CSS là:

```scss
@if <condition> {
  <code to be executed if condition is true>
  <code to be executed if condition is true>
  ...
}
```

Ví dụ:

```scss
@if $color == 'red' {
	.container {
		color: red;
	}
	.box {
		color: blue;
	}
}
```

Trong ví dụ trên, code CSS `.container { color: red; }` và `.box { color: blue; }` sẽ được thực thi nếu biến `$color` có giá trị là `red`.

Ở css sẽ biên dịch thành:

```css
.container {
	color: red;
}
.box {
	color: blue;
}
```

---

## Cách sử dụng với các toán tử

- Toán tử so sánh lớn hơn `>`

`@if` có thể được sử dụng với tất cả các toán tử có trong SCSS, bao gồm các toán tử số học, logic và so sánh.

Ví dụ:

```scss
@if $number > 10 {
	.container {
		color: red;
	}
} @else {
	.container {
		color: blue;
	}
}
```

Trong ví dụ trên, code CSS `.container { color: red; }` sẽ được thực thi nếu biến `$number` có giá trị lớn hơn 10, và code CSS `.container { color: blue; }` sẽ được thực thi nếu biến `$number` có giá trị nhỏ hơn hoặc bằng 10.

Ở css sẽ biên dịch thành:

```css
.container {
	color: red;
}
```

---

- Toán tử so sánh nhỏ hơn `<`

```scss
$number: 5;
@if $number < 10 {
	.container {
		color: red;
	}
} @else {
	.container {
		color: blue;
	}
}
```

Ở đây, code CSS `.container { color: red; }` sẽ được thực thi nếu biến `$number` có giá trị nhỏ hơn 10, và code CSS `.container { color: blue; }` sẽ được thực thi nếu biến `$number` có giá trị lớn hơn hoặc bằng 10.

Ở css sẽ biên dịch thành:

```css
.container {
	color: red;
}
```

---

- Toán tử so sánh lớn hơn hoặc bằng `>=`

```scss
$number: 10;
@if $number >= 10 {
	.container {
		color: red;
	}
} @else {
	.container {
		color: blue;
	}
}
```

Ở đây, code CSS `.container { color: red; }` sẽ được thực thi nếu biến `$number` có giá trị lớn hơn hoặc bằng 10, và code CSS `.container { color: blue; }` sẽ được thực thi nếu biến `$number` có giá trị nhỏ hơn 10.

Ở css sẽ biên dịch thành:

```css
.container {
	color: red;
}
```

---

- Toán tử so sánh nhỏ hơn hoặc bằng `<=`

```scss
$number: 10;
@if $number <= 10 {
	.container {
		color: red;
	}
} @else {
	.container {
		color: blue;
	}
}
```

Ở đây, code CSS `.container { color: red; }` sẽ được thực thi nếu biến `$number` có giá trị nhỏ hơn hoặc bằng 10, và code CSS `.container { color: blue; }` sẽ được thực thi nếu biến `$number` có giá trị lớn hơn 10.

Ở css sẽ biên dịch thành:

```css
.container {
	color: red;
}
```

---

- Toán tử so sánh bằng `==`

```scss
$color: 'red';
@if $color == 'red' {
	.container {
		color: red;
	}
} @else {
	.container {
		color: blue;
	}
}
```

Ở đây, code CSS `.container { color: red; }` sẽ được thực thi nếu biến `$color` có giá trị là `red`, và code CSS `.container { color: blue; }` sẽ được thực thi nếu biến `$color` có giá trị khác `red`.

Ở css sẽ biên dịch thành:

```css
.container {
	color: red;
}
```

---

- Toán tử so sánh khác `!=`

```scss
$color: 'blue';
@if $color != 'red' {
	.container {
		color: red;
	}
} @else {
	.container {
		color: blue;
	}
}
```

Ở đây, code CSS `.container { color: red; }` sẽ được thực thi nếu biến `$color` có giá trị khác `red`, và code CSS `.container { color: blue; }` sẽ được thực thi nếu biến `$color` có giá trị là `red`.

Ở css sẽ biên dịch thành:

```css
.container {
	color: blue;
}
```

---

- Toán tử logic `and`

```scss
$color: 'red';
$number: 10;
@if $color == 'red' and $number == 10 {
	.container {
		color: red;
	}
} @else {
	.container {
		color: blue;
	}
}
```

Ở đây, code CSS `.container { color: red; }` sẽ được thực thi nếu biến `$color` có giá trị là `red` và biến `$number` có giá trị là 10, và code CSS `.container { color: blue; }` sẽ được thực thi nếu biến `$color` có giá trị khác `red` hoặc biến `$number` có giá trị khác 10.

Ở css sẽ biên dịch thành:

```css
.container {
	color: red;
}
```

---

- Toán tử logic `or`

```scss
$color: 'blue';
$number: 10;
@if $color == 'red' or $number == 10 {
	.container {
		color: red;
	}
} @else {
	.container {
		color: blue;
	}
}
```

Ở đây, code CSS `.container { color: red; }` sẽ được thực thi nếu biến `$color` có giá trị là `red` hoặc biến `$number` có giá trị là 10, và code CSS `.container { color: blue; }` sẽ được thực thi nếu biến `$color` có giá trị khác `red` và biến `$number` có giá trị khác 10.

Ở css sẽ biên dịch thành:

```css
.container {
	color: red;
}
```

---

- Toán tử logic `not`

```scss
$color: 'blue';
@if not $color == 'red' {
	.container {
		color: red;
	}
} @else {
	.container {
		color: blue;
	}
}
```

Ở đây, code CSS `.container { color: red; }` sẽ được thực thi nếu biến `$color` có giá trị khác `red`, và code CSS `.container { color: blue; }` sẽ được thực thi nếu biến `$color` có giá trị là `red`.

Ở css sẽ biên dịch thành:

```css
.container {
	color: red;
}
```

---

## Kết luận

`@if` là một tính năng mạnh mẽ của SCSS cho phép chúng ta kiểm tra một điều kiện và thực thi một khối code nếu điều kiện đó đúng, hoặc một khối code khác nếu điều kiện đó sai.

Chúng ta có thể sử dụng `@if` với tất cả các toán tử có trong SCSS để tạo ra các code CSS phức tạp và linh hoạt hơn.

---

## Các loại vòng lặp

Dưới đây là các loại vòng lặp trong SCSS:

- **For through:** Vòng lặp `@for` lặp lại một khối code một số lần.

- **For to:** Vòng lặp `@for` lặp lại một khối code với một số bước xác định.

- **While:** Vòng lặp `@while` lặp lại một khối code cho đến khi một điều kiện được thỏa mãn.

- **Each with variable 1D:** Vòng lặp `@each` lặp lại một khối code cho mỗi phần tử trong một mảng.

- **Each with variable 2D:** Vòng lặp `@each` lặp lại một khối code cho mỗi phần tử trong một mảng 2 chiều.

- **Each with variable key-value:** Vòng lặp `@each` lặp lại một khối code cho mỗi phần tử trong một mảng key-value.

- **Sử dụng rẽ nhánh if else trong vòng lặp:** Vòng lặp `@if` có thể được sử dụng để kiểm tra một điều kiện và thực thi một khối code nếu điều kiện đó đúng, hoặc một khối code khác nếu điều kiện đó sai.

---

## Vòng lặp

Vòng lặp là một cấu trúc điều khiển cho phép chúng ta thực thi một khối code nhiều lần. SCSS cung cấp ba loại vòng lặp:

- `@for`
- `@while`
- `@each`

---

### @for

#### @for to

`@for to` là một vòng lặp lặp lại một khối code một số lần và số cuối cùng sẽ bị loại trừ. Cú pháp của vòng lặp `@for to` là:

```scss
@for $i from 1 to 10 {
	// Code sẽ được thực thi 9 lần
}
```

Trong đó, `$i` là một biến đếm và `from 1 to 10` là điều kiện của vòng lặp.

Ví dụ:

```scss
@for $i from 1 to 5 {
	.box-#{$i} {
		width: 10px * $i;
	}
}
```

Ở đây, chúng ta định nghĩa một vòng lặp `@for to` lặp lại một khối code 4 lần với các giá trị của biến `$i` lần lượt là 1, 2, 3 và 4.

Ở css sẽ biên dịch thành:

```css
.box-1 {
	width: 10px;
}
.box-2 {
	width: 20px;
}
.box-3 {
	width: 30px;
}
.box-4 {
	width: 40px;
}
```

---

#### @for through

`@for through` là một vòng lặp lặp lại một khối code một số lần và số cuối cùng không bị loại trừ. Cú pháp của vòng lặp `@for through` là:

```scss
@for $i from 1 through 10 {
	// Code sẽ được thực thi 10 lần
}
```

Trong đó, `$i` là một biến đếm và `from 1 through 10` là điều kiện của vòng lặp.

Ví dụ:

```scss
@for $i from 1 through 5 {
	.box-#{$i} {
		width: 10px * $i;
	}
}
```

Ở đây, chúng ta định nghĩa một vòng lặp `@for through` lặp lại một khối code 5 lần với các giá trị của biến `$i` lần lượt là 1, 2, 3, 4 và 5.

Ở css sẽ biên dịch thành:

```css
.box-1 {
	width: 10px;
}
.box-2 {
	width: 20px;
}
.box-3 {
	width: 30px;
}
.box-4 {
	width: 40px;
}
.box-5 {
	width: 50px;
}
```

---

### @while

`@while` là một vòng lặp lặp lại một khối code cho đến khi một điều kiện được thỏa mãn. Cú pháp của vòng lặp `@while` là:

```scss
@while $i < 10 {
	// Code sẽ được thực thi 10 lần
}
```

Trong đó, `$i` là một biến đếm và `< 10` là điều kiện của vòng lặp.

Ví dụ:

```scss
$i: 1;
@while $i < 5 {
	.box-#{$i} {
		width: 10px * $i;
	}
	$i: $i + 1;
}
```

Ở đây, chúng ta định nghĩa một vòng lặp `@while` lặp lại một khối code 4 lần với các giá trị của biến `$i` lần lượt là 1, 2, 3 và 4.

Ở css sẽ biên dịch thành:

```css
.box-1 {
	width: 10px;
}
.box-2 {
	width: 20px;
}
.box-3 {
	width: 30px;
}
.box-4 {
	width: 40px;
}
```

---

### @each

`@each` là một vòng lặp lặp lại một khối code cho mỗi phần tử trong một mảng. Cú pháp của vòng lặp `@each` là:

```scss
@each $item in $array {
	// Code sẽ được thực thi cho mỗi phần tử trong mảng
}
```

Trong đó, `$array` là một mảng và `$item` là một biến đại diện cho từng phần tử trong mảng.

Ví dụ:

- Vòng lặp `@each` với mảng 1 chiều.

```scss
$colors: red, blue, green;
@each $color in $colors {
	.box-#{$color} {
		color: $color;
	}
}
```

Ở đây, chúng ta định nghĩa một vòng lặp `@each` lặp lại một khối code 3 lần với các giá trị của biến `$color` lần lượt là `red`, `blue` và `green`.

Ở css sẽ biên dịch thành:

```css
.box-red {
	color: red;
}
.box-blue {
	color: blue;
}
.box-green {
	color: green;
}
```

---

- Vòng lặp `@each` với mảng 2 chiều.

```scss
$colors: (red blue), (yellow orange);

@each $color1, $color2 in $colors {
	.box-#{$color} {
		color: $color;
		background-color: $color2;
	}
}
```

Ở đây, chúng ta định nghĩa một vòng lặp `@each` lặp lại một khối code 2 lần với các giá trị của biến `$color1` và `$color2` lần lượt là `red` và `blue`, và `yellow` và `orange`.

Ở css sẽ biên dịch thành:

```css
.box-red {
	color: red;
	background-color: blue;
}
.box-yellow {
	color: yellow;
	background-color: orange;
}
```

---

- Vòng lặp `@each` với mảng key-value.

```scss
$colors: (
	red: #f00,
	blue: #00f,
	green: #0f0,
);

@each $color, $value in $colors {
	.box-#{$color} {
		color: $value;
	}
}
```

Ở đây, chúng ta định nghĩa một vòng lặp `@each` lặp lại một khối code 3 lần với các giá trị của biến `$color` và `$value` lần lượt là `red` và `#f00`, `blue` và `#00f`, và `green` và `#0f0`.

Ở css sẽ biên dịch thành:

```css
.box-red {
	color: #f00;
}
.box-blue {
	color: #00f;
}
.box-green {
	color: #0f0;
}
```

---

### Sử dụng rẽ nhánh if else trong vòng lặp

Vòng lặp `@if` có thể được sử dụng để kiểm tra một điều kiện và thực thi một khối code nếu điều kiện đó đúng, hoặc một khối code khác nếu điều kiện đó sai.

Ví dụ:

```scss
$styles: (16px, italic), (18px, bold), (20px, normal);

@each $size, $style in $styles {
	.box-#{$size} {
		font-size: $size;
		@if $style != bold {
			font-style: $style;
		} @else {
			font-weight: $style;
		}
	}
}
```

Ở đây, chúng ta định nghĩa một vòng lặp `@each` lặp lại một khối code 3 lần với các giá trị của biến `$size` và `$style` lần lượt là `16px` và `italic`, `18px` và `bold`, và `20px` và `normal`.

Nếu lặp tới bất kỳ phần tử nào, nếu giá trị của biến `$style` khác `bold`, code CSS `font-style: $style;` sẽ được thực thi, và nếu giá trị của biến `$style` là `bold`, code CSS `font-weight: $style;` sẽ được thực thi.

Ở css sẽ biên dịch thành:

```css
.box-16px {
	font-size: 16px;
	font-style: italic;
}
.box-18px {
	font-size: 18px;
	font-weight: bold;
}
.box-20px {
	font-size: 20px;
	font-style: normal;
}
```

---

## Kết luận

Vòng lặp là một tính năng mạnh mẽ của SCSS có thể được sử dụng để tạo ra các code CSS phức tạp và linh hoạt hơn.

Chúng ta có thể sử dụng các loại vòng lặp khác nhau để thực hiện các nhiệm vụ khác nhau, chẳng hạn như lặp lại một khối code một số lần, lặp lại một khối code cho mỗi phần tử trong một mảng, hoặc lặp lại một khối code cho đến khi một điều kiện được thỏa mãn.

---

## Import

`import` là một cú pháp trong SCSS cho phép chúng ta nhập nội dung của một tệp SCSS vào tệp SCSS hiện tại.

Điều này có thể hữu ích khi chúng ta muốn sử dụng lại các định nghĩa CSS trong nhiều tệp SCSS.

Cú pháp của `import` là:

```scss
@import 'file.scss';
```

Trong đó, `file.scss` là tên của tệp SCSS mà chúng ta muốn nhập.

---

## Use

`use` là một cú pháp trong SCSS cho phép chúng ta sử dụng lại một định nghĩa CSS trong nhiều tệp SCSS.

Điều này có thể hữu ích khi chúng ta muốn định nghĩa một định nghĩa CSS chỉ một lần và sử dụng định nghĩa đó trong nhiều nơi khác nhau.

Cú pháp của `use` là:

```scss
@use 'file.scss';
```

Trong đó, `file.scss` là tên của tệp SCSS mà chúng ta muốn sử dụng định nghĩa CSS từ.

---

## Forward

`forward` là một cú pháp trong SCSS cho phép chúng ta chuyển một định nghĩa CSS từ một tệp SCSS sang một tệp SCSS khác.

Điều này có thể hữu ích khi chúng ta muốn sử dụng lại một định nghĩa CSS trong nhiều tệp SCSS, nhưng chúng ta không muốn định nghĩa lại định nghĩa CSS đó trong mỗi tệp SCSS.

Cú pháp của `forward` là:

```scss
@forward 'file.scss';
```

Trong đó, `file.scss` là tên của tệp SCSS mà chúng ta muốn chuyển định nghĩa CSS đến.

---

## Lý do sử dụng

Có một số lý do tại sao chúng ta có thể muốn sử dụng các phương thức `import`, `use` và `forward` trong SCSS. Một số lý do phổ biến bao gồm:

- **Tiết kiệm thời gian**: Sử dụng các phương thức này có thể giúp chúng ta tiết kiệm thời gian bằng cách cho phép chúng ta sử dụng lại các định nghĩa CSS trong nhiều tệp SCSS.

- **Tăng tính nhất quán**: Sử dụng các phương thức này có thể giúp chúng ta tăng tính nhất quán trong code CSS của mình bằng cách cho phép chúng ta sử dụng cùng một định nghĩa CSS trong nhiều nơi khác nhau.

- **Tăng tính linh hoạt**: Sử dụng các phương thức này có thể giúp chúng ta tăng tính linh hoạt trong code CSS của mình bằng cách cho phép chúng ta định nghĩa một định nghĩa CSS chỉ một lần và sử dụng định nghĩa đó trong nhiều nơi khác nhau.

---

## Bài toán thực tế

Một bài toán thực tế mà chúng ta có thể phải sử dụng các phương thức `import`, `use` và `forward` là khi chúng ta đang làm việc trên một dự án có nhiều người tham gia.

Trong trường hợp này, chúng ta có thể muốn sử dụng các phương thức này để đảm bảo rằng mọi người đều sử dụng cùng một định nghĩa CSS.

Chúng ta cũng có thể muốn sử dụng các phương thức này để dễ dàng thay đổi các định nghĩa CSS mà không cần phải thay đổi code CSS trong nhiều tệp.

---

## Kỹ thuật chia file, folder khi xây dựng dự án với SCSS

Việc chia file, folder hợp lý, đơn giản, hiệu quả trong bất kỳ dự án nào là một yếu tố quan trọng để phát triển một dự án tốt. Việc chia file, folder giúp quản lý source code, quản lý tổng thể dự án, sửa lỗi, thay thế, phát triển một cách nhanh chóng.

Tuy nhiên việc chia file, folder hợp lý, đơn giản, hiệu quả trong một dự án không phải lúc nào cũng giống nhau, mà phụ thuộc vào nhiều yếu tố khác nhau như: kích thước dự án, số lượng thành viên trong dự án, thời gian thực hiện dự án, tính chất dự án,...

Nhưng hầu hết, khi xây dựng một dự án với SCSS, chúng ta thường chia file, folder theo chức năng và cấp độ của từng thành phần trong dự án.

Dưới đây là một số kỹ thuật chia file, folder khi xây dựng dự án với HTML, SCSS cơ bản:

- Chia file, folder theo chức năng: Chúng ta có thể chia file, folder theo chức năng của từng thành phần trong dự án, ví dụ như:

  - Thư mục assets: Thư mục này chứa các tài nguyên như hình ảnh, icon, video, audio,...

  - Thư mục styles: Thư mục này chứa các file CSS hoặc SCSS

  - Thư mục pages: Thư mục này chứa các file HTML

- Chia file, folder theo cấp độ: Chúng ta có thể chia file, folder theo cấp độ của từng thành phần trong dự án, ví dụ như:

  - Thư mục styles/scss/layout: Thư mục này chứa các file SCSS định nghĩa bố cục chung cho toàn bộ dự án như: header, footer, sidebar,...

  - Thư mục styles/scss/parts: Thư mục này chứa các file SCSS định nghĩa các css chung cho toàn bộ dự án như: reset, normalize,...

  - Thư mục styles/scss/pages: Thư mục này chứa các file SCSS định nghĩa kiểu dáng cho từng trang trong dự án như: trang chủ, trang chi tiết, trang giới thiệu,...

Chúng ta có thể linh hoạt áp dụng các kỹ thuật chia file, folder khác nhau để phù hợp với nhu cầu của từng dự án. Tuy nhiên, điều quan trọng là phải đảm bảo rằng việc chia file, folder hợp lý và hiệu quả, giúp chúng ta quản lý và phát triển dự án một cách dễ dàng.

Ví dụ ở đây là một cách chia file, folder khi xây dựng dự án với HTML, SCSS cơ bản:

```
├── assets
│   ├── images
│   ├───── logo
│   ├────────── logo.png
│   ├────────── logo.jpg
│   ├────────── logo-transparent.png
│   ├────────── logo...
│   ├───── pages
│   ├────────── home
│   ├────────── about
│   ├────────── ...
│   ├── icons
│   ├───── cart.svg
│   ├───── search.svg
│   ├───── ...
│   ├── videos
│   ├───── video-1.mp4
│   ├───── video-2.mp4
│   ├───── ...
│   ├── audios
│   ├───── audio-1.mp3
│   ├───── audio-2.mp3
│   ├───── ...
│   ├── fonts
│   ├───── font-1.ttf
│   ├───── font-2.ttf
│   ├───── ...
├── styles
│   ├── scss
│   ├───── layout
│   ├────────── _header.scss
│   ├────────── _footer.scss
│   ├────────── _sidebar.scss
│   ├────────── ...
│   ├───── parts
│   ├────────── _reset.scss
│   ├────────── _base.scss
│   ├────────── _variables.scss
│   ├────────── _mixins.scss
│   ├────────── ...
│   ├───── pages
│   ├────────── home.scss
│   ├────────── about.scss
│   ├────────── ...
│   ├───── styles.scss
│   ├── css (Bản biên dịch của file SCSS)
│   ├───── pages
│   ├────────── home.css
│   ├────────── about.css
│   ├────────── ...
│   ├───── styles.css
├── pages
│   ├── about.html
│   ├── contact.html
│   ├── ...
├── index.html
```

Ở đây, chúng ta chia làm 3 thư mục chính là `assets`, `styles` và `pages`.

- Thư mục `assets` chứa các tài nguyên như hình ảnh, icon, video, audio,...

- Thư mục `styles` chứa các file CSS và SCSS

  - Thư mục `styles/scss/layout` chứa các file SCSS định nghĩa bố cục chung cho toàn bộ dự án như: header, footer, sidebar,...

  - Thư mục `styles/scss/parts` chứa các file SCSS định nghĩa các css chung cho toàn bộ dự án như: reset, normalize,...

  - Thư mục `styles/scss/pages` chứa các file SCSS định nghĩa kiểu dáng cho từng trang trong dự án như: trang chủ, trang chi tiết, trang giới thiệu,...

  - File `styles/styles.scss` là file SCSS chính, nơi chúng ta import các file SCSS khác

  - Thư mục `styles/css` chứa các file CSS biên dịch từ các file SCSS

- Thư mục `pages` chứa các file HTML

- File `index.html` là file HTML chính

---

## Kết luận

Việc chia file, folder hợp lý là một trong những yếu tố quan trọng nhất để phát triển một dự án tốt. Chúng ta có thể linh hoạt áp dụng các kỹ thuật chia file, folder khác nhau để phù hợp với nhu cầu của từng dự án.

Khi chia folder hợp lý, việc quản lý source code, thay đổi, sửa lỗi và phát triển dự án sẽ trở nên dễ dàng hơn rất nhiều.

---

## Thực hành: Xây dựng Grid System bằng cách sử dụng SCSS

Sau khi xây dựng Grid System bằng cách sử dụng CSS, chúng ta sẽ thấy việc copy và paste code CSS để tạo ra các Grid System khác nhau là một việc làm rất tốn thời gian và công sức.

Để giải quyết vấn đề này, chúng ta có thể sử dụng SCSS để tạo ra các Grid System khác nhau một cách nhanh chóng dễ dàng và ngắn gọn, thay vì phải copy và paste code CSS.

Dưới đây là một ví dụ về việc xây dựng Grid System đơn giản hỗ trợ responsive bằng cách sử dụng SCSS:

1: Grid system bằng css

```css
* {
	padding: 0;
	margin: 0;
	box-sizing: border-box;
	outline: 0;
}

:root {
	--container-width: 1200px;
	--container-padding: 15px;
	--max-column: 12;
	--column-space: 20px;
	--spacer: 1rem;
}

.container {
	max-width: var(--container-width);
	margin: 0 auto;
	padding: 0 var(--container-padding);
}

.justify-content-start {
	justify-content: flex-start;
}
... .align-items-end {
	align-items: flex-end;
}

.row {
	display: flex;
	flex-wrap: wrap;
	margin: 0 calc(-1 * var(--column-space) / 2);
}

.row.g-0 {
	margin: 0;
}

.row.g-0 > [class^='col-'] {
	padding: 0;
	margin: 0;
}

.row.g-1,
... .row.g-5 {
	margin: 0 calc(-1 * var(--column-space) / 2);
}

.row.g-1 {
	--column-space: calc(0.25 * var(--spacer));
}
... .row.g-5 {
	--column-space: calc(3 * var(--spacer));
}

.row.g-1 > [class^='col-'],
...,
.row.g-5 > [class^='col-'] {
	padding: 0 calc(var(--column-space) / 2);
	margin-bottom: var(--column-space);
}

.row.g-1 > [class^='col-'] {
	--column-space-gutter: calc(0.25 * var(--spacer));
}
... .row.g-5 > [class^='col-'] {
	--column-space-gutter: calc(3 * var(--spacer));
}

.row [class^='col-'] {
	--column-width: calc(100% / (var(--max-column) / var(--column-number)));
	flex-basis: var(--column-width);
	max-width: var(--column-width);
	padding: 0 calc(var(--column-space) / 2);
	margin-bottom: var(--column-space);
}

.col-1 {
	--column-number: 1;
}
... .col-12 {
	--column-number: 12;
}

@media screen and (min-width: 576px) {
	.col-sm-1 {
		--column-number: 1;
	}
	... .col-sm-12 {
		--column-number: 12;
	}
}

@media screen and (min-width: 768px) {
	.col-md-1 {
		--column-number: 1;
	}
	... .col-md-12 {
		--column-number: 12;
	}
}

@media screen and (min-width: 992px) {
	.col-lg-1 {
		--column-number: 1;
	}
	... .col-lg-12 {
		--column-number: 12;
	}
}

@media screen and (min-width: 1200px) {
	.col-xl-1 {
		--column-number: 1;
	}
	... .col-xl-12 {
		--column-number: 12;
	}
}

@media screen and (min-width: 1400px) {
	.container {
		padding: 0;
	}
	.col-xxl-1 {
		--column-number: 1;
	}
	... .col-xxl-12 {
		--column-number: 12;
	}
}
```

---

2: Grid system bằng scss

```scss
:root {
	--container-width: 1200px;
	--container-padding: 15px;
	--max-column: 12;
	--column-space: 20px;
	--spacer: 1rem;
}
// Mixins

// Mixin tạo ra các thuộc tính flexbox
// Nhận vào 2 tham số: thuộc tính và giá trị

@mixin flex($property, $map) {
	@each $key, $value in $map {
		.#{$property}-#{$key} {
			#{$property}: $value;
		}
	}
}

// Mixin tạo ra các thuộc tính margin và padding cho row và col
// Nhận vào 2 tham số: key và value

@mixin gutter($key, $value) {
	&.g-#{$key} {
		margin: 0 calc(-1 * var(--column-space) / 2);
		--column-space: #{$value};
		> [class^='col-'] {
			padding: 0 calc(var(--column-space) / 2);
			margin-bottom: var(--column-space);
			--column-space-gutter: #{$value};
		}
	}
}

// Mixin tạo ra các thuộc tính d-none
// Nhận vào 2 tham số: key và breakpoint(nếu có)

@mixin d-none($key: null, $breakpoint: null) {
	@if $breakpoint == null {
		.d-none {
			display: none;
		}
	} @else {
		@media screen and (min-width: $breakpoint) {
			.d-#{$key}-none {
				display: none;
			}
		}
	}
}

// Mixin tạo ra các thuộc tính cho col
// Nhận vào 2 tham số: cột và breakpoint(nếu có)

@mixin column($i, $media: null) {
	@if $media == null {
		.col-#{$i} {
			--column-number: #{$i};
		}
	} @else {
		--column-number: #{$i};
	}
}

// Mixin tạo ra các thuộc tính cho col theo breakpoint
// Nhận vào 2 tham số: cột và breakpoint

@mixin column-breakpoint($key, $value) {
	@media screen and (min-width: $value) {
		@for $i from 1 through $columns {
			.col-#{$key}-#{$i} {
				@include column($i, $key);
			}
		}
	}
}

.container {
	max-width: var(--container-width);
	margin: 0 auto;
	padding: 0 var(--container-padding);
}
$flex-value: (
	start: flex-start,
	center: center,
	end: flex-end,
);
$flex-attribute: (justify-content, align-items);

// Khởi tạo các thuộc tính flexbox cho row và col

@each $attribute in $flex-attribute {
	@include flex(#{$attribute}, $flex-value);
}
.row {
	display: flex;
	flex-wrap: wrap;
	margin: 0 calc(-1 * var(--column-space) / 2);
	$gutters: (
		0: 0,
		1: calc(0.25 * var(--spacer)),
		2: calc(0.5 * var(--spacer)),
		3: calc(1 * var(--spacer)),
		4: calc(1.5 * var(--spacer)),
		5: calc(3 * var(--spacer)),
	);

	// Tạo ra các thuộc tính margin và padding cho row và col

	@each $key, $value in $gutters {
		@include gutter($key, $value);
	}
	[class^='col-'] {
		--column-width: calc(100% / (var(--max-column) / var(--column-number)));
		flex-basis: var(--column-width);
		max-width: var(--column-width);
		padding: 0 calc(var(--column-space) / 2);
		margin-bottom: var(--column-space);
	}
}
$columns: 12;
$breakpoints: (
	sm: 576px,
	md: 768px,
	lg: 992px,
	xl: 1200px,
	xxl: 1400px,
);

// Khởi tạo các thuộc tính cho col theo breakpoint

@mixin media-breakpoints($map) {
	@include d-none();
	@for $i from 1 through $columns {
		// Tạo ra các thuộc tính cho col chưa có breakpoint
		@include column($i);
	}
	@each $key, $value in $map {
		// Tạo ra các thuộc tính cho col, d-none theo breakpoint
		@include d-none($key, $value);
		@include column-breakpoint($key, $value);
	}
}
@include media-breakpoints($breakpoints);
```
