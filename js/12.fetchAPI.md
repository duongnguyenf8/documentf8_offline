## Tổng quan về Fetch API

Fetch API là một API mới được giới thiệu trong JavaScript ES2015. Fetch API cho phép chúng ta thực hiện các yêu cầu HTTP đến các tài nguyên web và nhận dữ liệu trả về.

Fetch API là một API được thiết kế để thay thế cho **`XMLHttpRequest (XHR)`**. Fetch API cung cấp một giao diện JavaScript cho việc tương tác với các tài nguyên trên mạng (**network**). Nó cung cấp một phương thức **`fetch()`** để lấy các tài nguyên từ mạng và trả về một promise (**promise**) để xử lý kết quả.

Fetch API cũng giống như **`XMLHttpRequest (XHR)`**, nó cho phép chúng ta tạo các yêu cầu HTTP. Tuy nhiên, Fetch API sử dụng cú pháp mới hơn, dựa trên Promise (**promise**), và cung cấp một giao diện mạnh mẽ hơn cho việc xử lý nhiều loại và luồng dữ liệu.

---

### Fetch API cung cấp những gì?

Fetch API cung cấp một số tính năng, bao gồm:

- Thực hiện các yêu cầu HTTP GET, POST, PUT và DELETE...

- Nhận dữ liệu trả về dưới dạng văn bản, JSON, XML hoặc một định dạng khác.

- Tùy chỉnh các yêu cầu HTTP, chẳng hạn như phương thức, tiêu đề và nội dung, v.v.

- Xử lý các lỗi HTTP.

---

### Fetch API trả ra những gì?

Fetch API trả về một đối tượng Response. Đối tượng Response có một số thuộc tính, bao gồm:

- `status`: Mã trạng thái HTTP của yêu cầu.

- `statusText`: Mô tả mã trạng thái HTTP của yêu cầu.

- `headers`: Các tiêu đề HTTP của yêu cầu.

- `body`: Dữ liệu trả về của yêu cầu.

---

## Cấu trúc và tham số của hàm fetch

Hàm fetch có cấu trúc như sau:

```js
fetch(url, options);
```

- `url`: URL của tài nguyên web mà chúng ta muốn thực hiện yêu cầu.

- `options`: Một Object có các tùy chọn cho yêu cầu.

Các tùy chọn có thể bao gồm:

- `method`: Phương thức HTTP của yêu cầu.

- `headers`: Các tiêu đề HTTP của yêu cầu.

- `body`: Dữ liệu của yêu cầu.

---

## Ví dụ về cách sử dụng Fetch API

Dưới đây là một ví dụ về cách sử dụng Fetch API để lấy dữ liệu từ một tài nguyên web và hiển thị nó trong console:

- url: `https://jsonplaceholder.typicode.com/todos/1`
- method: `GET` (mặc định)
- headers: `Content-Type: application/json` (mặc định)
- body: `null` (mặc định)
- mode: `cors` (mặc định)

```js
(async function getData() {
  const response = await fetch("https://jsonplaceholder.typicode.com/todos/1");
  const json = await response.json();
  console.log(json);
})();
```

Kết quả:

```json
{ "userId": 1, "id": 1, "title": "delectus aut autem", "completed": false }
```

---

## Kết luận

Fetch API là một API mới được giới thiệu trong JavaScript ES2015. Fetch API cho phép chúng ta thực hiện các yêu cầu HTTP đến các tài nguyên web và nhận dữ liệu trả về.

Fetch API cung cấp một phương thức **`fetch()`** để lấy các tài nguyên từ mạng và trả về một promise (**promise**) để xử lý kết quả.

---

## Các thao tác với Fetch API

### 1. Thực hiện yêu cầu GET

Để thực hiện một yêu cầu GET, chúng ta chỉ cần truyền URL của tài nguyên web mà chúng ta muốn lấy dữ liệu:

Method GET là phương thức để lấy dữ liệu từ một tài nguyên web. Nó là phương thức mặc định của hàm fetch, vì vậy chúng ta không cần truyền nó vào hàm fetch.

```js
(async function getData() {
  const response = await fetch("https://jsonplaceholder.typicode.com/todos/1");
  const json = await response.json();
  console.log(json);
})();
```

Ở đây, chúng ta không truyền bất kỳ tùy chọn nào cho hàm fetch, vì vậy nó sẽ sử dụng các giá trị mặc định cho các tùy chọn.

Kết quả:

```json
{ "userId": 1, "id": 1, "title": "delectus aut autem", "completed": false }
```

---

### 2. Thực hiện yêu cầu POST

Để thực hiện một yêu cầu POST, chúng ta cần truyền URL của tài nguyên web mà chúng ta muốn gửi dữ liệu và các tùy chọn cho hàm fetch:

Method POST là phương thức để gửi một dữ liệu mới lên phía server. Nó sẽ tạo một tài nguyên mới hoặc thực hiện một hành động nào đó trên phía server.

```js
const url = "https://jsonplaceholder.typicode.com/todos";
const options = {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    title: "Học lập trình để đi làm",
    completed: false,
  }),
};

(async function postData() {
  const response = await fetch(url, options);
  const json = await response.json();
  console.log(json);
})();
```

Ở đây, chúng ta truyền các tùy chọn cho hàm fetch, bao gồm:

- `method`: Phương thức HTTP của yêu cầu: `POST`.

- `headers`: Các tiêu đề HTTP của yêu cầu: `Content-Type: application/json`.

- `body`: Dữ liệu của yêu cầu:

  ```js
  JSON.stringify({
    title: "Học lập trình để đi làm",
    completed: false,
  });
  ```

Kết quả:

```json
{ "title": "Học lập trình để đi làm", "completed": false, "id": 201 } // Tạo ra một tài nguyên mới với id là 201
```

---

### 3. Thực hiện yêu cầu PUT

Để thực hiện một yêu cầu PUT, chúng ta cần truyền URL của tài nguyên web mà chúng ta muốn gửi dữ liệu và các tùy chọn cho hàm fetch:

Method PUT dùng để cập nhật hoặc thay thế toàn bộ tài nguyên (resource) trên máy chủ bằng dữ liệu gửi kèm trong yêu cầu (request).
Nếu tài nguyên đã tồn tại, nó sẽ được ghi đè bởi dữ liệu mới. Nếu tài nguyên chưa tồn tại, nó sẽ được tạo mới với URI được chỉ định.
PUT method là idempotent, tức là gửi nhiều yêu cầu PUT giống nhau sẽ có cùng hiệu quả như gửi một yêu cầu PUT duy nhất.

Method PUT yêu cầu gửi đầy đủ dữ liệu của tài nguyên, bao gồm cả những thuộc tính không thay đổi.

```js
const url = "https://jsonplaceholder.typicode.com/todos/1";
const options = {
  method: "PUT",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    title: "Học lập trình để đi làm",
  }),
};

(async function putData() {
  const response = await fetch(url, options);
  const json = await response.json();
  console.log(json);
})();
```

Ở đây, chúng ta truyền các tùy chọn cho hàm fetch, bao gồm:

- `method`: Phương thức HTTP của yêu cầu: `PUT`.

- `headers`: Các tiêu đề HTTP của yêu cầu: `Content-Type: application/json`.

- `body`: Dữ liệu của yêu cầu:

  ```js
  JSON.stringify({
    title: "Học lập trình để đi làm",
  });
  ```

Kết quả:

```json
{ "title": "Học lập trình để đi làm", "id": 1 } // Cập nhật lại toàn bộ tài nguyên có id là 1
```

---

### 4. Thực hiện yêu cầu PATCH

Để thực hiện một yêu cầu PATCH, chúng ta cần truyền URL của tài nguyên web mà chúng ta muốn gửi dữ liệu và các tùy chọn cho hàm fetch:

Method PATCH dùng để cập nhật một phần của tài nguyên trên máy chủ bằng dữ liệu gửi kèm trong yêu cầu.
Dữ liệu này thường là một tập hợp các chỉ dẫn về cách sửa đổi tài nguyên hiện có.
Ví dụ: thêm, xóa, thay thế một thuộc tính nào đó của tài nguyên.
PATCH method không phải là idempotent, tức là gửi nhiều yêu cầu PATCH giống nhau có thể có hiệu quả khác nhau tuỳ thuộc vào trạng thái của tài nguyên trước và sau mỗi yêu cầu.

Method PATCH yêu cầu gửi dữ liệu thay đổi của tài nguyên, không cần gửi đầy đủ dữ liệu của tài nguyên.

Sự khác nhau giữa PUT và PATCH:

| Method PUT                  | Method PATCH                 |
| --------------------------- | ---------------------------- |
| Idempotent                  | Non-idempotent               |
| Cập nhật toàn bộ tài nguyên | Cập nhật một phần tài nguyên |
| Gửi dữ liệu đầy đủ          | Gửi dữ liệu thay đổi         |

```js
const url = "https://jsonplaceholder.typicode.com/todos/1";
const options = {
  method: "PATCH",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    title: "Học lập trình để đi làm",
  }),
};

(async function patchData() {
  const response = await fetch(url, options);
  const json = await response.json();
  console.log(json);
})();
```

Ở đây, chúng ta truyền các tùy chọn cho hàm fetch, bao gồm:

- `method`: Phương thức HTTP của yêu cầu: `PATCH`.

- `headers`: Các tiêu đề HTTP của yêu cầu: `Content-Type: application/json`.

- `body`: Dữ liệu của yêu cầu:

  ```js
  JSON.stringify({
    title: "Học lập trình để đi làm",
  });
  ```

Kết quả:

```json
{ "userId": 1, "id": 1, "title": "Học lập trình để đi làm", "completed": false } // Cập nhật lại một phần tài nguyên có id là 1
```

---

### 5. Thực hiện yêu cầu DELETE

Để thực hiện một yêu cầu DELETE, chúng ta cần truyền URL của tài nguyên web mà chúng ta muốn gửi dữ liệu và các tùy chọn cho hàm fetch:

Method DELETE dùng để xóa một tài nguyên trên máy chủ. Nó là một phương thức idempotent, tức là gửi nhiều yêu cầu DELETE giống nhau có cùng hiệu quả như gửi một yêu cầu DELETE duy nhất.

```js
const url = "https://jsonplaceholder.typicode.com/todos/1";
const options = {
  method: "DELETE",
};

(async function deleteData() {
  const response = await fetch(url, options);
  const json = await response.json();
  console.log(json);
})();
```

Ở đây, chúng ta truyền các tùy chọn cho hàm fetch, bao gồm:

- `method`: Phương thức HTTP của yêu cầu: `DELETE`.

Kết quả:

```json
{} // Xóa tài nguyên có id là 1
```

---

### 6. Thực hiện yêu cầu HEAD

Để thực hiện một yêu cầu HEAD, chúng ta cần truyền URL của tài nguyên web mà chúng ta muốn gửi dữ liệu và các tùy chọn cho hàm fetch:

Nó là một phương thức idempotent, tức là gửi nhiều yêu cầu HEAD giống nhau có cùng hiệu quả như gửi một yêu cầu HEAD duy nhất.

Method HEAD dùng để lấy thông tin về tài nguyên trên máy chủ mà không cần lấy dữ liệu của tài nguyên đó.

Method này thường được sử dụng để kiểm tra sự tồn tại của một tài nguyên trên máy chủ.

```js
const url = "https://jsonplaceholder.typicode.com/todos";
const options = {
  method: "HEAD",
};

(async function headData() {
  const response = await fetch(url, options);
  const isOk = await response.ok;
  console.log(isOk);
})();
```

Ở đây, chúng ta truyền các tùy chọn cho hàm fetch, bao gồm:

- `method`: Phương thức HTTP của yêu cầu: `HEAD`.

Kết quả:

```js
true; // Kiểm tra sự tồn tại của tài nguyên
```

---

### 7. Thực hiện yêu cầu UPDATE

Để thực hiện một yêu cầu UPDATE, chúng ta cần truyền URL của tài nguyên web mà chúng ta muốn gửi dữ liệu và các tùy chọn cho hàm fetch:

Method UPDATE dùng để cập nhật một phần của tài nguyên trên máy chủ bằng dữ liệu gửi kèm trong yêu cầu.

Method này thường được sử dụng để cập nhật một phần của tài nguyên trên máy chủ.

Đây không phải một method HTTP chính thức, nó thường được dùng để thay cho PUT và PATCH tùy thuộc vào trạng thái của tài nguyên trước và sau mỗi yêu cầu và nó được sử dụng như một từ khóa để ám chỉ việc cập nhật tài nguyên.

```js
const url = "https://jsonplaceholder.typicode.com/todos/1";
const options = {
  method: "UPDATE",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    title: "Học lập trình để đi làm",
  }),
};

(async function updateData() {
  const response = await fetch(url, options);
  const json = await response.json();
  console.log(json);
})();
```

Ở đây, chúng ta truyền các tùy chọn cho hàm fetch, bao gồm:

- `method`: Phương thức HTTP của yêu cầu: `UPDATE`.

- `headers`: Các tiêu đề HTTP của yêu cầu: `Content-Type: application/json`.

- `body`: Dữ liệu của yêu cầu:

  ```js
  JSON.stringify({
    title: "Học lập trình để đi làm",
  });
  ```

Kết quả:

```json
{ "userId": 1, "id": 1, "title": "Học lập trình để đi làm", "completed": false } // Cập nhật lại một phần tài nguyên có id là 1
```

---

## Kết luận

Thao tác với REST API bằng Fetch API là một cách tốt để tương tác với các tài nguyên web.

Sử dụng Fetch API, chúng ta có thể thực hiện các yêu cầu HTTP GET, POST, PUT, DELETE và HEAD và còn nhiều Method khác không phổ biến bằng.

---

<!-- ##  Fake Server với thư viện JSON Server -->

## Tìm hiểu về thư viện JSON Server

JSON Server là một thư viện Node.js cho phép chúng ta tạo một REST API giả lập (fake REST API), nó sẽ tạo ra một REST API giả lập từ một file JSON.

Chúng ta có thể sử dụng nó để giả lập một môi trường Backend đơn giản để phát triển Frontend trong quá trình học tập hoặc chờ đợi Backend thực sự được hoàn thiện.

### Ưu điểm của JSON Server

Cài đặt nhanh và đơn giản: Với thư viện JSON Server, chúng ta có thể tạo một REST API giả lập chỉ trong vài phút.

- Tất cả những gì chúng ta cần là một file JSON chứa dữ liệu dạng JSON và một vài dòng lệnh để cài đặt JSON Server.

Dễ sử dụng: JSON Server cung cấp một REST API giả lập với các tính năng cơ bản như GET, POST, PUT, PATCH, DELETE, v.v.

- Nó cũng cung cấp một số tính năng nâng cao như lọc, phân trang, sắp xếp, v.v.

- Nó cũng cung cấp một giao diện người dùng đơn giản để xem và chỉnh sửa dữ liệu.

Gọn nhẹ: JSON Server là một thư viện Node.js nhỏ gọn, nó không có phụ thuộc vào bất kỳ thư viện nào khác.

- Nó cũng không cần cài đặt cơ sở dữ liệu nào.

- Nó chỉ cần một file JSON chứa dữ liệu dạng JSON.

- Nó cũng không cần cấu hình nào.

### Nhược điểm của JSON Server

Nó chỉ hỗ trợ một số tính năng cơ bản của REST API.

Nó không hỗ trợ các tính năng nâng cao của REST API như xác thực, bảo mật, v.v.

- Tuy nhiên có thể kết hợp thêm các thư viện ngoài nếu chúng ta biết một chút cơ bản về Node.js.

- Ví dụ như thư viện jsonwebtoken để xác thực người dùng, thư viện bcrypt để mã hóa mật khẩu, v.v.

Nó không hỗ trợ các loại cơ sở dữ liệu phức tạp như MySQL, PostgreSQL, MongoDB, v.v.

Nó không hỗ trợ các loại dữ liệu phức tạp như hình ảnh, video, v.v.

- Tuy nhiên chúng ta có thể lưu các đường dẫn đến các tệp đó trong file JSON.

- Hoặc nếu biết một chút về Node.js, chúng ta có thể tạo một REST API giả lập để lưu các tệp đó.

---

### Cài đặt JSON Server

1. Trước tiên, chúng ta phải có Node.js và NPM.

- Nếu chưa cài đặt, hãy cài đặt theo hướng dẫn tại đây: [nodejs.org](https://nodejs.org)

  - Hoặc với **Windows**, có thể tải luôn khi bấm vào **[đây](https://nodejs.org/dist/v18.16.1/node-v18.16.1-x64.msi)**

  - Hoặc với **MacOS**, có thể tải luôn khi bấm vào **[đây](https://nodejs.org/dist/v18.16.1/node-v18.16.1.pkg)**

- Sau khi cài đặt xong, mở **cmd** hoặc **terminal** lên và kiểm tra phiên bản của **nodejs** và **npm** bằng lệnh:

```bash
    node -v
    npm -v
```

- Nếu hiện ra phiên bản của **nodejs** và **npm** thì đã cài đặt thành công.

---

2. Tiếp theo, chúng ta cài đặt JSON Server bằng lệnh:

```bash
    npm install -g json-server

    # hoặc với MacOS, có thể chúng ta sẽ cần thêm sudo

    sudo npm install -g json-server # nhập mật khẩu của máy
```

3. Sau khi cài đặt xong, chúng ta có thể kiểm tra phiên bản của **json-server** bằng lệnh:

```bash
    json-server -v
```

---

4. Vì một số máy **Windows** sẽ bị lỗi biến môi trường. Chúng ta có thể fix bằng các bước sau:

Mở **Powershell** dưới quyền **Admin**

Lưu ý: Phải là **Powershell** chứ không phải **cmd**, phải là **Admin** chứ không phải **User**

```bash
    Set-ExecutionPolicy -ExecutionPolicy RemoteSigned
```

Sau đó nhấn `y` để xác nhận

```bash
    [Y] Yes  [A] Yes to All  [N] No  [L] No to All  [S] Suspend  [?] Help (default is "N"):
```

---

5. Tiếp theo, chúng ta tạo một file JSON chứa dữ liệu dạng JSON.

- Ví dụ, chúng ta tạo một file **db.json** với nội dung như sau:

```json
{
  "todos": [
    {
      "id": 1,
      "title": "Học lập trình để đi làm",
      "completed": false
    },
    {
      "id": 2,
      "title": "Học tiếng Việt",
      "completed": false
    },
    {
      "id": 3,
      "title": "Học tiếng mẹ đẻ",
      "completed": true
    }
  ]
}
```

---

6. Tiếp theo, chúng ta mở **cmd** hoặc **terminal** lên và chạy lệnh:

```bash
    json-server --watch db.json
```

Câu lệnh này sẽ gọi thư viện **json-server** và tạo một REST API giả lập từ file **db.json** mà chúng ta vừa tạo.

- Nếu chạy thành công, chúng ta sẽ thấy thông báo như sau:

```bash
    \{^_^}/ hi!

    Loading db.json
    Done

    Resources
    http://localhost:3000/todos

    Home
    http://localhost:3000

    Type s + enter at any time to create a snapshot of the database
    Watching...
```

---

7. Tiếp theo, chúng ta mở trình duyệt lên và truy cập vào địa chỉ: [http://localhost:3000/todos](http://localhost:3000/todos)

- Nếu chạy thành công, chúng ta sẽ thấy dữ liệu dạng JSON như sau:

```json
[
  {
    "id": 1,
    "title": "Học lập trình để đi làm",
    "completed": false
  },
  {
    "id": 2,
    "title": "Học tiếng Việt",
    "completed": false
  },
  {
    "id": 3,
    "title": "Học tiếng mẹ đẻ",
    "completed": true
  }
]
```

---

8. Hoàn thành. Chúng ta có thể thao tác với REST API giả lập này như với một REST API thực sự.

## Sử dụng JSON Server để tương tác với REST API

Tương tự như ở bài trước, chúng ta đã tìm hiểu qua về các phương thức Rest API phổ biến như GET, POST, PUT, PATCH, DELETE, HEAD, UPDATE.

Với JSON Server, chúng ta có thể tương tác với một REST API giả lập như với một REST API thực sự của riêng mình.

---

### 1. Thực hiện yêu cầu GET

```js
const url = "http://localhost:3000/todos";
const getTodos = async () => {
  const response = await fetch(url);
  const json = await response.json();
  return json;
};
document.addEventListener("DOMContentLoaded", async () => {
  const todos = await getTodos();
  document.write(JSON.stringify(todos));
});
```

Ở ví dụ này, chúng ta sử dụng hàm **`fetch()`** để thực hiện một yêu cầu GET đến địa chỉ **`http://localhost:3000/todos`** và lấy dữ liệu trả về dưới dạng JSON.

Sau khi cây DOM được tạo, chúng ta gọi hàm **`getTodos()`** để lấy dữ liệu từ REST API giả lập và hiển thị nó trong cây DOM.

Kết quả:

```json
[
  {
    "id": 1,
    "title": "Học lập trình để đi làm",
    "completed": false
  },
  {
    "id": 2,
    "title": "Học tiếng Việt",
    "completed": false
  },
  {
    "id": 3,
    "title": "Học tiếng mẹ đẻ",
    "completed": true
  }
]
```

---

### 2. Thực hiện yêu cầu POST

```js
const url = "http://localhost:3000/todos";
const options = {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    title: "Học JS để đi làm",
    completed: false,
  }),
};
const postTodo = async () => {
  const response = await fetch(url, options);
  const json = await response.json();
  return json;
};

document.addEventListener("DOMContentLoaded", async () => {
  const todo = await postTodo();
  document.write(JSON.stringify(todo));
});
```

Ở ví dụ này, chúng ta sử dụng hàm **`fetch()`** để thực hiện một yêu cầu POST đến địa chỉ **`http://localhost:3000/todos`** và lấy dữ liệu trả về dưới dạng JSON.

Sau khi cây DOM được tạo, chúng ta gọi hàm **`postTodo()`** để gửi dữ liệu đến REST API giả lập và hiển thị dữ liệu trả về trong cây DOM.

Kết quả:

```json
{ "title": "Học JS để đi làm", "completed": false, "id": 4 }
```

Khi đó, dữ liệu trong file **db.json** sẽ được cập nhật như sau:

```json
{
  "todos": [
    {
      "id": 1,
      "title": "Học lập trình để đi làm",
      "completed": false
    },
    {
      "id": 2,
      "title": "Học tiếng Việt",
      "completed": false
    },
    {
      "id": 3,
      "title": "Học tiếng mẹ đẻ",
      "completed": true
    },
    {
      "title": "Học JS để đi làm",
      "completed": false,
      "id": 4
    }
  ]
}
```

---

Cùng với đó, chúng ta sẽ làm tương tự với các phương thức khác như PUT, PATCH, DELETE, HEAD, UPDATE...

---

## Kết luận

Thao tác với JSON Server là một cách tốt để tương tác với các tài nguyên web một cách nhanh, dễ hiểu và dễ dàng.

## Tìm hiểu về XMLHttpRequest()

XMLHttpRequest là một Object trong Javascript được sử dụng để tạo và gửi các yêu cầu HTTP đến một địa chỉ URL cụ thể và nhận dữ liệu trả về.

XMLHttpRequest là một phần của API Web, nó được hỗ trợ bởi tất cả các trình duyệt hiện đại. Nó cũng được hỗ trợ bởi Node.js.

XMLHttpRequest là một hàm khởi tạo (constructor) của Object XMLHttpRequest.

Nó phải được gọi bằng từ khóa **`new`** để tạo một Object XMLHttpRequest mới trước khi sử dụng bất kỳ một phương thức nào của nó.

```js
const xhr = new XMLHttpRequest();
```

Nó cung cấp cho chúng ta các `Properties`, `Method` và `Event` để tạo và gửi các yêu cầu HTTP đến một địa chỉ URL cụ thể và nhận dữ liệu trả về.

### Properties

XMLHttpRequest có một số properties, bao gồm:

- `open()`: Phương thức này được sử dụng để mở một yêu cầu HTTP.

- `send()`: Phương thức này được sử dụng để gửi một yêu cầu HTTP.

- `onreadystatechange()`: Sự kiện này được gọi khi trạng thái của yêu cầu HTTP thay đổi.

- `readyState`: Thuộc tính này chứa trạng thái hiện tại của yêu cầu HTTP.

- `status`: Thuộc tính này chứa mã trạng thái của yêu cầu HTTP.

- `statusText`: Thuộc tính này chứa mô tả của mã trạng thái của yêu cầu HTTP.

- `responseText`: Thuộc tính này chứa văn bản của phản hồi HTTP.

- `responseXML`: Thuộc tính này chứa XML của phản hồi HTTP.

### Methods

XMLHttpRequest có một số methods, bao gồm:

- `open()`: Phương thức này được sử dụng để mở một yêu cầu HTTP.

- `send()`: Phương thức này được sử dụng để gửi một yêu cầu HTTP.

- `abort()`: Phương thức này được sử dụng để hủy một yêu cầu HTTP.

- `getResponseHeader()`: Phương thức này được sử dụng để lấy giá trị của một tiêu đề HTTP.

- `getAllResponseHeaders()`: Phương thức này được sử dụng để lấy tất cả các tiêu đề HTTP.

### Events

XMLHttpRequest có một số events, bao gồm:

- `onreadystatechange()`: Sự kiện này được gọi khi trạng thái của yêu cầu HTTP thay đổi.

- `onload()`: Sự kiện này được gọi khi yêu cầu HTTP tải xong.

- `onerror()`: Sự kiện này được gọi khi yêu cầu HTTP gặp lỗi.

### Lợi ích của việc sử dụng XMLHttpRequest

XMLHttpRequest có một số lợi ích, bao gồm:

- Cho phép chúng ta tương tác với các tài nguyên web động.

- Cho phép chúng ta tải dữ liệu từ các tài nguyên web khác nhau.

- Cho phép chúng ta gửi dữ liệu đến các tài nguyên web khác nhau.

- Cho phép chúng ta kiểm soát các yêu cầu HTTP của mình.

### Lưu ý khi sử dụng XMLHttpRequest

XMLHttpRequest có một số lưu ý, bao gồm:

- XMLHttpRequest có thể làm chậm trang web của chúng ta.

- XMLHttpRequest có thể gây ra lỗi nếu không được sử dụng đúng cách.

- XMLHttpRequest có thể bị chặn bởi trình duyệt của người dùng.

---

## Tìm hiểu về hàm fetch()

Hàm fetch() là một hàm được giới thiệu trong JavaScript ES2015. Hàm `fetch()` cho phép chúng ta thực hiện các yêu cầu HTTP đến các tài nguyên web và nhận dữ liệu trả về một cách ngắn gọn và dễ dàng hơn so với hàm XMLHttpRequest.

Hàm `fetch()` có cú pháp như sau:

```js
fetch(url[, options])
```

- `url`: URL của tài nguyên web mà chúng ta muốn thực hiện yêu cầu.
- `options`: Một đối tượng có các tùy chọn cho yêu cầu.

Các tùy chọn có thể bao gồm:

- `method`: Phương thức HTTP của yêu cầu.
- `headers`: Các tiêu đề HTTP của yêu cầu.
- `body`: Dữ liệu của yêu cầu.

Hàm `fetch()` trả về một đối tượng Response. Đối tượng Response có một số thuộc tính, bao gồm:

- `status`: Mã trạng thái HTTP của yêu cầu.
- `statusText`: Mô tả mã trạng thái HTTP của yêu cầu.
- `headers`: Các tiêu đề HTTP của yêu cầu.
- `body`: Dữ liệu trả về của yêu cầu.

### Cách sử dụng hàm fetch()

Dưới đây là một ví dụ về cách sử dụng hàm `fetch()` để thực hiện một yêu cầu GET đến tài nguyên web `https://www.google.com` và nhận dữ liệu trả về dưới dạng văn bản:

```js
const response = await fetch("https://www.google.com");
const text = await response.text();
console.log(text);
```

Ở đoạn code này, chúng ta sử dụng hàm `fetch()` để thực hiện một yêu cầu GET đến tài nguyên web `https://www.google.com` và lưu kết quả trả về vào biến **`response`**.

Sau đó, chúng ta sử dụng phương thức **`text()`** của đối tượng **`response`** để lấy dữ liệu trả về dưới dạng văn bản và lưu nó vào biến **`text`**.

Cuối cùng, chúng ta in ra nội dung của biến **`text`** ở console.

### Hàm fetch() được build từ đâu?

Hàm `fetch()` là một phương thức toàn cục trong JavaScript, được xây dựng bởi các nhà Web developer để cho phép truy xuất tài nguyên từ mạng một cách dễ dàng và logic.

Hàm `fetch()` được định nghĩa trong Fetch API, một chuẩn mới để thực hiện các yêu cầu máy chủ với Promises.

Trước đó, chức năng này được thực hiện bằng cách sử dụng **`XMLHttpRequest`**.

Fetch cung cấp một lựa chọn tốt hơn có thể dễ dàng sử dụng bởi các công nghệ khác như Service Workers.

Fetch cũng cung cấp một nơi duy nhất để định nghĩa các khái niệm liên quan đến HTTP khác như CORS và các tiện ích mở rộng cho HTTP.

### Xây dựng lại hàm fetch2

Trước tiên để xây dựng được hàm `fetch2()`, chúng ta cần phải hiểu được cách hoạt động của hàm `fetch()`.

Hàm `fetch()` nhận vào một tham số là url và một tham số là options.

Hàm `fetch()` trả về một Promise với đối tượng Response.

```js
const initialOptions = {
  method: "GET",
  headers: {},
  body: null,
};

function fetch2(url, options = initialOptions) {
  if (!url) {
    return Promise.reject("Error: URL is not provided");
  }

  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open(options.method, url);

    xhr.onload = function () {
      if (xhr.status === 200) {
        resolve(xhr.responseText);
      } else {
        reject("Error: " + xhr.status);
      }
    };

    xhr.onerror = function () {
      reject("Error: " + xhr.status);
    };

    xhr.send(options.body);
  });
}
```

Ở đây, chúng ta gán một hàm callback cho sự kiện **`onload`** của Object **`xhr`**.

Trong hàm callback này, chúng ta kiểm tra xem trạng thái của yêu cầu HTTP có phải là **`200`** hay không hay nói cách khác là kiểm tra xem yêu cầu HTTP có thành công hay không.

Nếu thành công, chúng ta gọi hàm **`resolve()`** với tham số là dữ liệu trả về của yêu cầu HTTP.

Nếu không thành công, chúng ta gọi hàm **`reject()`** với tham số là thông báo lỗi.

Cuối cùng, chúng ta gọi phương thức **`send()`** của Object **`xhr`** để gửi yêu cầu HTTP với dữ liệu là **`options.body`**.

---

Vậy là chúng ta đã hoàn thành cơ bản được hàm **`fetch2()`** giống các chức năng cơ bản của hàm **`fetch()`**.

---

## Tìm hiểu về thư viện Axios

Axios là một thư viện JavaScript giúp chúng ta thực hiện các yêu cầu HTTP đến các tài nguyên web. Axios là một thư viện rất phổ biến, được sử dụng bởi nhiều dự án JavaScript khác nhau.

Axios có một số tính năng, bao gồm:

- Thực hiện các yêu cầu HTTP GET, POST, PUT và DELETE.

- Tùy chỉnh các yêu cầu HTTP, chẳng hạn như phương thức, tiêu đề và quyền.

- Xử lý các lỗi HTTP.

- Hỗ trợ các phản hồi JSON, XML và text.

- Hỗ trợ các phản hồi đa phần.

- Hỗ trợ các phản hồi lỗi.

Axios là một thư viện rất linh hoạt và có thể được sử dụng để thực hiện nhiều loại yêu cầu HTTP. Axios là một lựa chọn tuyệt vời cho các dự án JavaScript cần thực hiện các yêu cầu HTTP.

### Ưu và nhược điểm của Axios

**Ưu điểm của Axios**

- Axios là một thư viện rất phổ biến, được sử dụng bởi nhiều dự án JavaScript khác nhau.

- Axios có nhiều tính năng, bao gồm thực hiện các yêu cầu HTTP GET, POST, PUT và DELETE, tùy chỉnh các yêu cầu HTTP, xử lý các lỗi HTTP, hỗ trợ các phản hồi JSON, XML và text, hỗ trợ các phản hồi đa phần và hỗ trợ các phản hồi lỗi.

- Axios là một thư viện rất linh hoạt và có thể được sử dụng để thực hiện nhiều loại yêu cầu HTTP.

**Nhược điểm của Axios**

- Axios là một thư viện khá lớn, có thể làm chậm ứng dụng của chúng ta.

- Axios có thể khó sử dụng, đặc biệt là đối với những người mới bắt đầu với JavaScript.

### So sánh Axios với fetch

Axios là một thư viện JavaScript và fetch là một phương thức toàn cục của Javascript. Cả 2 đều giúp chúng ta thực hiện các yêu cầu HTTP đến các tài nguyên web. Tuy nhiên, có một số điểm khác biệt chính giữa chúng.

Axios là một thư viện có trạng thái, trong khi fetch thì không không có trạng thái. Điều này có nghĩa là Axios lưu trữ trạng thái của các yêu cầu HTTP, trong khi fetch không.

Axios cũng có nhiều tính năng hơn fetch, bao gồm thực hiện các yêu cầu HTTP GET, POST, PUT và DELETE, tùy chỉnh các yêu cầu HTTP, xử lý các lỗi HTTP, hỗ trợ các phản hồi JSON, XML và text, hỗ trợ các phản hồi đa phần và hỗ trợ các phản hồi lỗi.

Axios là một thư viện linh hoạt hơn fetch, nhưng nó cũng phức tạp hơn và có thể làm chậm ứng dụng của chúng ta. Nếu chúng ta cần một thư viện linh hoạt có nhiều tính năng, thì Axios là một lựa chọn tốt. Nếu chúng ta cần một sự đơn giản và hiệu quả, thì fetch là một lựa chọn tốt.

| Tính năng       | Axios       | fetch        |
| --------------- | ----------- | ------------ |
| Cần cài đặt     | Có          | Không        |
| Kích thước      | Lớn         | Nhỏ          |
| Sử dụng dễ dàng | Phức tạp    | Dễ sử dụng   |
| Tính năng       | Nhiều       | Ít           |
| Linh hoạt       | Linh hoạt   | Ít linh hoạt |
| Hiệu suất       | Có thể chậm | Hiệu quả     |
| Trạng thái      | Có          | Không        |

### Cài đặt Axios

Để cài đặt Axios, chúng ta sử dụng lệnh sau:

```bash
npm install axios
```

### Sử dụng Axios

Để sử dụng Axios, chúng ta cần import nó vào dự án của mình:

```js
import axios from "axios";
// Hoặc với CommonJS
const axios = require("axios");
```

Sau đó, chúng ta có thể sử dụng Axios để thực hiện các yêu cầu HTTP đến các tài nguyên web.

---

## Định nghĩa chuẩn về API

API là viết tắt của “Application Programming Interface” (giao diện lập trình ứng dụng).

Một API là một tập hợp các quy tắc được định nghĩa cho phép các ứng dụng khác nhau giao tiếp với nhau.

Nó hoạt động như một lớp trung gian xử lý chuyển đổi dữ liệu giữa các hệ thống, cho phép các công ty mở dữ liệu và chức năng của ứng dụng cho các nhà phát triển bên thứ ba, đối tác kinh doanh và các bộ phận nội bộ trong công ty của họ.

Ví dụ:

- React Context API là một cách để một ứng dụng React hiệu quả tạo ra các biến toàn cục có thể được truyền đi. Đây là sự thay thế cho “prop drilling” hoặc di chuyển props từ ông nội sang con sang cha, và cứ thế. Context cũng được ca ngợi là một cách tiếp cận dễ dàng hơn, nhẹ hơn để quản lý trạng thái sử dụng Redux.

  Vì vậy, các chức năng trong API React Context cũng được gọi là API.

---

## Tìm hiểu về REST API

REST API là một kiểu kiến trúc phần mềm, trong đó các hệ thống được thiết kế theo các nguyên tắc truyền tải trạng thái đại diện (Representational State Transfer - REST). REST là một tập hợp các ràng buộc kiến trúc được định nghĩa bởi nhà khoa học máy tính Roy Fielding. Các ràng buộc này bao gồm:

- Giao diện đồng nhất: Tất cả các yêu cầu API cho cùng một tài nguyên phải giống nhau, bất kể yêu cầu đến từ đâu.

- Tách biệt giữa client và server: Trong thiết kế API REST, ứng dụng client và server phải hoàn toàn độc lập với nhau.

- Không trạng thái: API REST không có trạng thái, có nghĩa là mỗi yêu cầu cần bao gồm tất cả thông tin cần thiết để xử lý nó.

- Khả năng lưu trữ trong bộ nhớ cache: Khi có thể, các tài nguyên nên được lưu trữ trong bộ nhớ cache ở phía client hoặc server.

- Kiến trúc hệ thống theo lớp: Trong API REST, các cuộc gọi và phản hồi đi qua các lớp khác nhau.

REST API cho phép các ứng dụng khác nhau giao tiếp với nhau một cách dễ dàng và an toàn thông qua giao thức HTTP. Vì vậy, REST API được sử dụng rộng rãi trong việc kết nối các thành phần và ứng dụng trong kiến trúc microservices.

---

### Các phương thức REST API

REST API sử dụng các phương thức HTTP để thực hiện các yêu cầu. Các phương thức này bao gồm:

- GET: Phương thức GET được sử dụng để lấy dữ liệu từ một tài nguyên.

Ví dụ: Lấy thông tin của một người dùng từ một tài nguyên.

```bash
GET /users/1
```

- POST: Phương thức POST được sử dụng để tạo một tài nguyên mới.

Ví dụ: Tạo một người dùng mới.

```bash
POST /users
```

- PUT: Phương thức PUT được sử dụng để cập nhật một tài nguyên.

Ví dụ: Cập nhật thông tin của một người dùng.

```bash
PUT /users/1
```

- PATCH: Phương thức PATCH được sử dụng để cập nhật một phần của một tài nguyên.

Ví dụ: Cập nhật một phần thông tin của một người dùng.

```bash
PATCH /users/1
```

- DELETE: Phương thức DELETE được sử dụng để xóa một tài nguyên.

Ví dụ: Xóa một người dùng.

```bash
DELETE /users/1
```

Các thao tác với REST API sẽ tương tự như ở bài **`Các thao tác với Fetch API`**.

---

## Thực hành: Xây dựng ứng dụng TodoList với Fetch API

Ở bài thực hành này, chúng ta sẽ làm quen với cách sử dụng Fetch API để tương tác với REST API.

Với các kiến thức đã học về JSON Server, chúng ta sẽ xây dựng một ứng dụng TodoList với các chức năng thêm, sửa, xóa và đánh dấu đã hoàn thành.

## Các thao tác REST API với JSON Server

- Lấy danh sách công việc: GET /todos

- Lấy một công việc: GET /todos/:id

- Thêm một công việc: POST /todos

- Cập nhật một công việc: PUT /todos/:id

- Xóa một công việc: DELETE /todos/:id

- Đánh dấu một công việc đã hoàn thành: PATCH /todos/:id

Bước đầu: Chúng ta cần cài đặt JSON Server để tạo một REST API giả lập.

```bash
json-server --watch db.json
```

Sau đó, tạo một tài nguyên trong file **db.json**.

```json
{
  "todos": [
    {
      "id": 1,
      "title": "Học lập trình để đi làm",
      "completed": false
    },
    {
      "id": 2,
      "title": "Học tiếng Việt",
      "completed": false
    },
    {
      "id": 3,
      "title": "Học tiếng mẹ đẻ",
      "completed": true
    }
  ]
}
```

Ví dụ:

Để lấy tất cả các công việc, chúng ta sử dụng phương thức GET và địa chỉ: `http://localhost:3000/todos`

```js
const url = "http://localhost:3000/todos";
const getTodos = async () => {
  const response = await fetch(url);
  const json = await response.json();
  return json;
};
document.addEventListener("DOMContentLoaded", async () => {
  const todos = await getTodos();
  document.write(JSON.stringify(todos));
});
```

Ở ví dụ này, chúng ta sử dụng hàm **`fetch()`** để thực hiện một yêu cầu GET đến địa chỉ **`http://localhost:3000/todos`** và lấy dữ liệu trả về dưới dạng JSON.

Sau khi cây DOM được tạo, chúng ta gọi hàm **`getTodos()`** để lấy dữ liệu từ REST API giả lập và hiển thị nó trong cây DOM.

Kết quả:

```json
[
  {
    "id": 1,
    "title": "Học lập trình để đi làm",
    "completed": false
  },
  {
    "id": 2,
    "title": "Học tiếng Việt",
    "completed": false
  },
  {
    "id": 3,
    "title": "Học tiếng mẹ đẻ",
    "completed": true
  }
]
```

---

Để thêm một công việc, chúng ta sử dụng phương thức POST và địa chỉ: `http://localhost:3000/todos`

```js
const url = "http://localhost:3000/todos";
const options = {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    title: "Học JS để đi làm",
    completed: false,
  }),
};
const postTodo = async () => {
  const response = await fetch(url, options);
  const json = await response.json();
  return json;
};

document.addEventListener("DOMContentLoaded", async () => {
  const todo = await postTodo();
  document.write(JSON.stringify(todo));
});
```

Ở ví dụ này, chúng ta sử dụng hàm **`fetch()`** để thực hiện một yêu cầu POST đến địa chỉ **`http://localhost:3000/todos`** và lấy dữ liệu trả về dưới dạng JSON.

Sau khi cây DOM được tạo, chúng ta gọi hàm **`postTodo()`** để gửi dữ liệu đến REST API giả lập và hiển thị dữ liệu trả về trong cây DOM.

Kết quả:

```json
{ "title": "Học JS để đi làm", "completed": false, "id": 4 }
```

---

Để cập nhật một công việc, chúng ta sử dụng phương thức PATCH và địa chỉ: `http://localhost:3000/todos/4`

```js
const url = "http://localhost:3000/todos/4";
const options = {
  method: "PATCH",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    completed: true,
  }),
};
const patchTodo = async () => {
  const response = await fetch(url, options);
  const json = await response.json();
  return json;
};
document.addEventListener("DOMContentLoaded", async () => {
  const todo = await patchTodo();
  document.write(JSON.stringify(todo));
});
```

Ở ví dụ này, chúng ta sử dụng hàm **`fetch()`** để thực hiện một yêu cầu PATCH đến địa chỉ **`http://localhost:3000/todos/4`** hay nói cách khác là cập nhật lại một phần tài nguyên có id là 4 và lấy dữ liệu trả về dưới dạng JSON.

Sau khi cây DOM được tạo, chúng ta gọi hàm **`patchTodo()`** để gửi dữ liệu đến REST API giả lập và hiển thị dữ liệu trả về trong cây DOM.

Kết quả:

```json
{ "title": "Học JS để đi làm", "completed": true, "id": 4 }
```

Lúc này, dữ liệu trong file **db.json** sẽ được cập nhật như sau:

```json
{
  "todos": [
    // Như dữ liệu cũ
    {
      "title": "Học JS để fullstack",
      "userName": "F8",
      "completed": true,
      "id": 4
    }
  ]
}
```

---

Để xóa một công việc, chúng ta sử dụng phương thức DELETE và địa chỉ: `http://localhost:3000/todos/4`

```js
const url = "http://localhost:3000/todos/4";
const options = {
  method: "PUT",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    title: "Học JS để fullstack",
    userName: "F8",
    completed: false,
  }),
};
const putTodo = async () => {
  const response = await fetch(url, options);
  const json = await response.json();
  return json;
};

document.addEventListener("DOMContentLoaded", async () => {
  const todo = await putTodo();
  document.write(JSON.stringify(todo));
});
```

Ở ví dụ này, chúng ta sử dụng hàm **`fetch()`** để thực hiện một yêu cầu PUT đến địa chỉ **`http://localhost:3000/todos/4`** hay nói cách khác là cập nhật lại tài nguyên có id là 4 và lấy dữ liệu trả về dưới dạng JSON.

Sau khi cây DOM được tạo, chúng ta gọi hàm **`putTodo()`** để gửi dữ liệu đến REST API giả lập và hiển thị dữ liệu trả về trong cây DOM.

Kết quả:

```json
{
  "title": "Học JS để fullstack",
  "userName": "F8",
  "completed": false,
  "id": 4
}
```

Lúc này, dữ liệu trong file **db.json** sẽ được cập nhật như sau:

```json
{
  "todos": [
    // Như dữ liệu cũ
    {
      "title": "Học JS để fullstack",
      "userName": "F8",
      "completed": false,
      "id": 4
    }
  ]
}
```

---

Để xóa một công việc, chúng ta sử dụng phương thức DELETE và địa chỉ: `http://localhost:3000/todos/4`

```js
const url = "http://localhost:3000/todos/4";
const options = {
  method: "DELETE",
};
const deleteTodo = async () => {
  const response = await fetch(url, options);
  const json = await response.json();
  return json;
};

const getTodos = async () => {
  const response = await fetch("http://localhost:3000/todos");
  const json = await response.json();
  return json;
};

document.addEventListener("DOMContentLoaded", async () => {
  await deleteTodo();
  const todos = await getTodos();
  document.write(JSON.stringify(todos));
});
```

Ở ví dụ này, chúng ta sử dụng hàm **`fetch()`** để thực hiện một yêu cầu DELETE đến địa chỉ **`http://localhost:3000/todos/4`** hay nói cách khác là xóa tài nguyên có id là 4 và lấy dữ liệu trả về dưới dạng JSON.

Sau khi cây DOM được tạo, chúng ta gọi hàm **`deleteTodo()`** để gửi một yêu cầu xóa tài nguyên có id là 4 đến REST API giả lập.

Sau đó gọi hàm **`getTodos()`** để lấy dữ liệu từ REST API giả lập và hiển thị nó trong cây DOM.

Lúc này, kết quả hiển thị trong cây DOM sẽ là:

```json
[
  {
    "id": 1,
    "title": "Học lập trình để đi làm",
    "completed": false
  },
  {
    "id": 2,
    "title": "Học tiếng Việt",
    "completed": false
  },
  {
    "id": 3,
    "title": "Học tiếng mẹ đẻ",
    "completed": true
  }
]
```

Lúc này, dữ liệu trong file **db.json** sẽ được cập nhật như sau:

```json
{
  "todos": [
    {
      "id": 1,
      "title": "Học lập trình để đi làm",
      "completed": false
    },
    {
      "id": 2,
      "title": "Học tiếng Việt",
      "completed": false
    },
    {
      "id": 3,
      "title": "Học tiếng mẹ đẻ",
      "completed": true
    }
  ]
}
```

---

Với các thao tác này, chúng ta có thể thực hành xây dựng ứng dụng TodoList với các chức năng thêm, sửa, xóa và đánh dấu đã hoàn thành.

<!-- ## Authentication và Authorization -->

## Authentication

Authentication là quá trình xác thực người dùng. Nói cách khác, đây là quá trình xác định người dùng là ai.

Authentication có thể được thực hiện bằng cách sử dụng một số phương pháp khác nhau, bao gồm:

- Sử dụng một tên người dùng và mật khẩu.
- Sử dụng một mã thông báo ví dụ như JSON Web Token (JWT)...
- Sử dụng một số phương pháp xác thực khác như OAuth.

Authentication là một phần quan trọng của bất kỳ ứng dụng web nào. Nó cho phép chúng ta xác định người dùng là ai và cung cấp cho họ quyền truy cập vào các tài nguyên của ứng dụng.

Authentication cần sử dụng bằng cách gửi yêu cầu đến một máy chủ xác thực. Máy chủ xác thực sẽ xác minh thông tin đăng nhập và trả về một mã thông báo xác thực. Mã thông báo xác thực này sẽ được sử dụng để xác thực các yêu cầu tiếp theo.

Ví dụ: khi chúng ta đăng nhập vào một trang web, chúng ta sẽ được yêu cầu cung cấp tên người dùng và mật khẩu của mình. Trang web sẽ gửi yêu cầu đến máy chủ xác thực, máy chủ xác thực sẽ xác minh thông tin đăng nhập của chúng ta và trả về một mã thông báo xác thực. Mã thông báo xác thực này sẽ được sử dụng để xác thực các yêu cầu tiếp theo của chúng ta đối với trang web.

## Authorization

Authorization là quá trình xác thực các yêu cầu của người dùng. Nói cách khác, đây là quá trình xác định người dùng có quyền truy cập vào tài nguyên hay không.

Authorization có thể được thực hiện bằng cách sử dụng một số phương pháp khác nhau, bao gồm:

- Sử dụng một số phương pháp xác thực như JSON Web Token (JWT)...
- Sử dụng một số phương pháp xác thực khác như OAuth.
- Sử dụng một số phương pháp xác thực khác như Access Control List (ACL).

Authorization là một phần quan trọng trong các trang web và ứng dụng web lớn. Nó cho phép chúng ta xác định người dùng có quyền truy cập vào các tài nguyên của ứng dụng hay không.

Ví dụ: khi chúng ta đăng nhập vào một trang web, chúng ta có thể có quyền truy cập vào một số tài nguyên, chẳng hạn như trang chủ, tài khoản của chúng ta và các bài viết của chúng ta. Tuy nhiên, chúng ta có thể không có quyền truy cập vào các tài nguyên khác, chẳng hạn như tài khoản của người khác hoặc dữ liệu nhạy cảm.

Dựa vào các cấp độ bảo mật, có thể chia làm 3 loại Authorization:

- **Single-Factor Authentication**: Đây là loại xác thực đơn giản nhất, chỉ sử dụng một yếu tố để xác thực người dùng. Ví dụ: tên người dùng và mật khẩu.

- **Two-Factor Authentication**: Đây là loại xác thực sử dụng hai yếu tố để xác thực người dùng. Ví dụ: tên người dùng và mật khẩu, mã xác thực.

- **Multi-Factor Authentication**: Đây là loại xác thực sử dụng nhiều yếu tố để xác thực người dùng. Ví dụ: tên người dùng và mật khẩu, mã xác thực, vân tay, khuôn mặt...

Ví dụ:

- Khi chúng ta đăng nhập vào trang **F8**, chúng ta sẽ được yêu cầu cung cấp tên người dùng và mật khẩu của mình hoặc đăng nhập bằng các tài khoản khác như Facebook, Google, Github... Sau khi chúng ta đăng nhập thành công, chúng ta có thể truy cập vào các tài nguyên của mình như trang chủ, tài khoản của chúng ta và các bài viết của chúng ta. Tuy nhiên, chúng ta không có quyền truy cập vào các tài nguyên khác, chẳng hạn như tài khoản của người khác hoặc dữ liệu nhạy cảm. **Đây là một ví dụ về Single-Factor Authentication và Authorization.**.

- Khi chúng ta đăng nhập vào trang web **Github**, nếu đã cài đặt 2FA, chúng ta sẽ được yêu cầu cung cấp tên người dùng và mật khẩu của mình và mã xác thực. Sau khi chúng ta đăng nhập thành công, chúng ta có thể truy cập vào các tài nguyên của mình như trang chủ, tài khoản của chúng ta và các bài viết của chúng ta. Tuy nhiên, chúng ta không có quyền truy cập vào các tài nguyên khác, chẳng hạn như tài khoản của người khác hoặc dữ liệu nhạy cảm. **Đây là một ví dụ về Two-Factor Authentication và Authorization.**.

- Khi chúng ta đăng nhập vào ngân hàng, chúng ta sẽ được yêu cầu cung cấp tên người dùng và mật khẩu của mình, mã xác thực, vân tay, khuôn mặt... Sau khi chúng ta đăng nhập thành công, chúng ta có thể truy cập vào các tài nguyên của mình như trang chủ, tài khoản của chúng ta và các bài viết của chúng ta. Tuy nhiên, chúng ta không có quyền truy cập vào các tài nguyên khác, chẳng hạn như tài khoản của người khác hoặc dữ liệu nhạy cảm. **Đây là một ví dụ về Multi-Factor Authentication và Authorization.**.

## Phân biệt giữa Authentication và Authorization

Authentication và Authorization là hai khái niệm quan trọng trong bảo mật web. Authentication là quá trình xác định người dùng là ai, trong khi Authorization là quá trình xác định người dùng có quyền truy cập vào tài nguyên hay không.

Authentication thường được thực hiện bằng cách sử dụng tên người dùng và mật khẩu, trong khi Authorization có thể được thực hiện bằng cách sử dụng một số phương pháp khác nhau, bao gồm mã thông báo, OAuth và ACL.

Authentication và Authorization đều là những phần quan trọng của bảo mật web và cần được sử dụng cùng nhau để bảo vệ các ứng dụng web khỏi những kẻ tấn công.

Dưới đây là một bảng phân tích rõ ràng hơn về sự khác nhau giữa Authentication và Authorization:

| Authentication                                                                        | Authorization                                                                                             |
| ------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- |
| Quá trình xác định người dùng là ai.                                                  | Quá trình xác định người dùng có quyền truy cập vào tài nguyên hay không.                                 |
| Thường được thực hiện bằng cách sử dụng tên người dùng và mật khẩu.                   | Có thể được thực hiện bằng cách sử dụng một số phương pháp khác nhau, bao gồm mã thông báo, OAuth và ACL. |
| Là quá trình xác thực thông tin đăng nhập                                             | Là quá trình xác minh xem có cho phép truy cập hay không.                                                 |
| Authentication là bước đầu tiên của authorization vì vậy luôn luôn đến trước.         | Authorization được thực hiện sau khi authentication thành công.                                           |
| Khi vào nhà hàng, chúng ta cần đi qua chỗ gửi xe, lấy vé để xác định rằng có ăn ở đó. | Sau khi vào nhà hàng, sẽ có lễ tân hỏi đặt bàn ở đâu, và chúng ta chỉ được ngồi bàn đó                    |

## Kết luận

Mặc dù, cả hai thuật ngữ thường được sử dụng kết hợp với nhau, chúng có các khái niệm và ý nghĩa hoàn toàn khác nhau. Authentication là quá trình xác định người dùng là ai, trong khi Authorization là quá trình xác định người dùng có quyền truy cập vào tài nguyên hay không.
