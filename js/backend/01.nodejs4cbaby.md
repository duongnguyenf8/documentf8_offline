<!-- ## Tổng quan về lập trình Back-end, cách back-end hoạt động -->

## Backend là gì? Backend có vai trò gì trong lập trình web?

Backend là một phần của một ứng dụng web, nó bao gồm các thành phần xử lý logic, xử lý dữ liệu, xử lý nghiệp vụ, xử lý tương tác với cơ sở dữ liệu, xử lý tương tác với các ứng dụng khác, xử lý tương tác với người dùng, xử lý tương tác với các thiết bị khác như máy in, máy quét, máy đọc mã vạch, máy đọc thẻ từ, máy đọc thẻ ATM, máy đọc thẻ Visa, MasterCard, ... và các thiết bị khác.

**Rút gọn:** Backend có vai trò quan trọng trong lập trình web, nó là nơi xử lý các nghiệp vụ, các logic, các dữ liệu, các tương tác với người dùng, các tương tác với các ứng dụng khác, các tương tác với các thiết bị khác.

Thường được ví dụ như một con người, Backend là bộ não của một ứng dụng web, nó xử lý các logic, các dữ liệu, các nghiệp vụ, tính toán và giao tiếp với cơ sở dữ liệu, giao tiếp với các ứng dụng khác, giao tiếp với các thiết bị khác.

Còn Frontend là một bộ phận khác của một con người, nó là bộ não thị giác, nó nhận các tín hiệu từ môi trường, từ các thiết bị khác, từ người dùng, từ các ứng dụng khác.

![OIP.jpg](https://files.fullstack.edu.vn/f8-prod/public-images/64ca823624d25.jpg)

---

## Backend hoạt động như thế nào trong lập trình web?

Backend trong lập trình web là phần của ứng dụng web nằm trên máy chủ và chịu trách nhiệm xử lý các yêu cầu từ người dùng. Backend thường được viết bằng các ngôn ngữ lập trình như PHP, Java, C#, Python, Ruby, NodeJS, ... và các framework như Laravel, Spring, .NET, Django, Ruby on Rails, ExpressJS, ... và các thư viện hỗ trợ.

NodeJS là một môi trường runtime JavaScript chạy trên máy chủ. NodeJS được viết bằng JavaScript, vì vậy nó rất dễ học với các lập trình viên Frontend. Ngoài ra, NodeJS còn có nhiều ưu điểm khác như:

- Có thể xử lý hàng ngàn kết nối cùng lúc dựa vào cơ chế bất đồng bộ (asynchronous) và sự kiện (event).

- Có thể xử lý các yêu cầu I/O (đọc/ghi file, truy vấn cơ sở dữ liệu, gọi API, ...) một cách hiệu quả và đồng thời. Điều này giúp NodeJS có thể xử lý các yêu cầu I/O một cách nhanh chóng.

- Có một cộng đồng người dùng lớn và tích cực.

Backend và Frontend giao tiếp với nhau thông qua API. API là một tập hợp các giao thức và quy ước cho phép các ứng dụng giao tiếp với nhau. API có thể được triển khai theo nhiều cách khác nhau, chẳng hạn như thông qua HTTP, WebSocket, gRPC, ...

Dưới đây là một ví dụ về cách Backend và Frontend giao tiếp với nhau:

1. Người dùng truy cập vào trang web.

2. Frontend gửi một yêu cầu đến Backend thông qua API.

3. Backend xử lý yêu cầu và trả về một phản hồi cho Frontend.

4. Frontend hiển thị phản hồi cho người dùng.

Backend là một phần quan trọng của ứng dụng web. Nó chịu trách nhiệm xử lý các yêu cầu từ người dùng và cung cấp dữ liệu và chức năng cho Frontend.

Backend được viết bằng các ngôn ngữ lập trình khác nhau, nhưng NodeJS là một lựa chọn phổ biến vì nó dễ học, hiệu quả và có một cộng đồng người dùng lớn.

---

<!-- ## Tổng quan về NodeJS -->

## Node.js là gì?

Node.js là một môi trường thực thi JavaScript đa nền tảng, mã nguồn mở, chạy trên "động cơ" (Môi trường) JavaScript V8. Nó được Ryan Dahl tạo ra vào năm 2009 và được sử dụng để xây dựng các ứng dụng mạng có thể mở rộng.

---

## Node.js hỗ trợ lập trình phía server như thế nào?

Node.js là một lựa chọn phổ biến cho lập trình phía server vì nó là bất đồng bộ. Điều này có nghĩa là Node.js có thể xử lý một lượng lớn kết nối đồng thời mà không bị chặn. Ngoài ra, Node.js rất hiệu quả trong việc xử lý các hoạt động I/O, chẳng hạn như đọc và ghi tệp hoặc truy vấn cơ sở dữ liệu.

---

## Ưu và nhược điểm của Node.js cho lập trình phía server

| Ưu điểm                                     | Nhược điểm                                             |
| ------------------------------------------- | ------------------------------------------------------ |
| Events và bất đồng bộ                       | Không lâu đời như một số ngôn ngữ khác                 |
| Hiệu quả trong việc xử lý các hoạt động I/O | Không phù hợp cho một số loại ứng dụng                 |
| Cộng đồng lớn                               | Hiệu suất có thể là một vấn đề đối với một số ứng dụng |
| Dễ học với lập trình viên Frontend web      | Phải học ngôn ngữ JavaScript                           |

---

### Ưu điểm của Node.js cho lập trình phía server

- **Events và bất đồng bộ:** Điều này làm cho Node.js rất hiệu quả trong việc xử lý các kết nối đồng thời.

- **Hiệu quả trong việc xử lý các hoạt động I/O:** Điều này làm cho Node.js trở thành một lựa chọn tốt cho các ứng dụng cần đọc và ghi tệp hoặc truy vấn cơ sở dữ liệu.

- **Cộng đồng lớn:** Có một cộng đồng lớn và tích cực các developer Node.js, có nghĩa là có nhiều tài nguyên có sẵn, chẳng hạn như thư viện, frameworks và hướng dẫn.

- **Dễ học:** Node.js dựa trên JavaScript, là một ngôn ngữ phổ biến mà nhiều developer đã biết.

---

### Nhược điểm của Node.js cho lập trình phía server

- **Không "trưởng thành" như một số ngôn ngữ khác:** Node.js là một kiến thức tương đối mới, vì vậy nó không lâu đời như một số ngôn ngữ khác, chẳng hạn như Java hoặc PHP. Vì vậy, nó có thể không phù hợp cho các ứng dụng yêu cầu tính ổn định, bảo mật và hiệu suất cao.

- **Không phù hợp cho một số loại ứng dụng:** Node.js không phù hợp cho một số loại ứng dụng, chẳng hạn như những ứng dụng yêu cầu nhiều tính toán vì hiệu suất của nó có thể là một vấn đề. Vì vậy, nó không phù hợp cho các ứng dụng yêu cầu tính toán phức tạp, chẳng hạn như các ứng dụng AI hoặc các ứng dụng yêu cầu tính toán phức tạp.

- **Hiệu suất không phù hợp một số ứng dụng:** Node.js có thể chậm đối với một số ứng dụng, chẳng hạn như những ứng dụng thực hiện nhiều truy vấn cơ sở dữ liệu. Vì nó được thiết kế để xử lý các hoạt động I/O, nó không phù hợp cho các ứng dụng yêu cầu nhiều tính toán.

---

### So sánh với một số frameworks phía server khác

Node.js thường được so sánh với Laravel và .NET, hai frameworks phía server phổ biến khác.

Laravel là một frameworks PHP được biết đến với cú pháp đơn giản và các tính năng mạnh mẽ. .NET là một frameworks của Microsoft được biết đến với khả năng mở rộng và hiệu suất.

Node.js là một lựa chọn tốt cho các ứng dụng cần xử lý một lượng lớn kết nối đồng thời. Laravel là một lựa chọn tốt cho các ứng dụng yêu cầu nhiều logic và tương tác cơ sở dữ liệu. .NET là một lựa chọn tốt cho các ứng dụng cần có khả năng mở rộng cao và hoạt động tốt.

| Frameworks | Ưu điểm                                                                                       | Nhược điểm                                                                                                                                  |
| ---------- | --------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |
| Node.js    | Events và bất đồng bộ<br>hiệu quả trong việc xử lý các hoạt động I/O<br>Cộng đồng lớn, dễ học | Không lâu đời như một số ngôn ngữ khác<br>không phù hợp cho một số loại ứng dụng,<br>Hiệu suất có thể là một vấn đề đối với một số ứng dụng |
| Laravel    | Cú pháp đơn giản, các tính năng mạnh mẽ                                                       | Không mở rộng như một số frameworks khác<br>hiệu suất có thể là một vấn đề đối với một số ứng dụng                                          |
| .NET       | Có khả năng mở rộng cao, hoạt động tốt                                                        | Không dễ học như một số frameworks khác, không phù hợp cho một số loại ứng dụng                                                             |

---

## Vậy Node.js có phù hợp cho lập trình phía server không?

Node.js là một lựa chọn tốt cho lập trình phía server vì nó là bất đồng bộ và hiệu quả trong việc xử lý các hoạt động I/O. Nó cũng có một cộng đồng lớn và tích cực các developer Node.js, có nghĩa là có nhiều tài nguyên có sẵn, chẳng hạn như thư viện, frameworks và hướng dẫn.

---

<!-- Xây dựng ứng dụng NodeJS đầu tiên (NodeJs thuần không sử dụng expressjs) -->

## Xây dựng ứng dụng NodeJS đầu tiên.

Với một dự án backend, thường có các mô hình thiết kế backend như sau:

- Mô hình MVC (Model - View - Controller): Đây là mô hình thiết kế backend phổ biến nhất hiện nay, nó được sử dụng trong các framework như Laravel, Spring, .NET, Django, Ruby on Rails, ExpressJS, ... và các thư viện hỗ trợ. Mô hình này có 3 thành phần chính là Model, View, Controller.

- Mô hình MVCS (Model - View - Controller - Service): Đây là mô hình thiết kế backend phổ biến khác, nó được sử dụng trong các framework như Laravel, Spring, .NET, Django, Ruby on Rails, ExpressJS, ... và các thư viện hỗ trợ. Mô hình này có 4 thành phần chính là Model, View, Controller, Service.

- Và các mô hình thiết kế khác như MVVM, MVP...

Vậy, với một ứng dụng nhỏ, chúng ta có thể sử dụng MVC hoặc không cần thiết kế theo mô hình nào cả.

Trước tiên. chúng ta muốn xây dựng một ứng dùng NodeJS đơn giản, chúng ta phải có NodeJS **^^**.

- Nếu chưa cài đặt, hãy cài đặt theo hướng dẫn tại đây: [nodejs.org](https://nodejs.org)

  - Hoặc với **Windows**, có thể tải luôn khi bấm vào **[đây](https://nodejs.org/dist/v18.16.1/node-v18.16.1-x64.msi)**

  - Hoặc với **MacOS**, có thể tải luôn khi bấm vào **[đây](https://nodejs.org/dist/v18.16.1/node-v18.16.1.pkg)**

- Sau khi cài đặt xong, mở **cmd** hoặc **terminal** lên và kiểm tra phiên bản của **nodejs** và **npm** bằng lệnh:

```bash
    node -v
    npm -v
```

- Nếu hiện ra phiên bản của **nodejs** và **npm** thì đã cài đặt thành công.

---

Tiếp theo, chúng ta tạo một thư mục mới, mở **cmd** hoặc **terminal** lên và gõ lệnh:

```bash
    mkdir helloWorld
    cd helloWorld
```

Dòng lệnh này sẽ tạo một thư mục mới có tên là **helloWorld** và chuyển đến thư mục này. Hoặc có thể tạo thủ công một thư mục mới và chuyển đến thư mục này.

---

Tiếp theo, chúng ta sẽ khởi tạo một **package.json** bằng lệnh:

```bash
    npm init -y
```

Dòng lệnh này sẽ khởi tạo một **package.json** với các thông tin mặc định ở trong thư mục hiện tại.

---

Tiếp theo, chúng ta sẽ tạo một file **index.js** bằng lệnh:

```bash
    touch index.js
```

Dòng lệnh này sẽ tạo một file **index.js** trong thư mục hiện tại.

Hoặc có thể tạo thủ công một file **index.js**.

---

Sau khi mở file **index.js** lên, chúng ta sẽ viết một đoạn code như sau:

```js
console.log("Hello World");
```

Vậy, chúng sẽ chạy ở đâu? Chúng ta sẽ chạy file **index.js** bằng lệnh:

```bash
    node index.js
```

Dòng lệnh này sẽ chạy file **index.js** trong thư mục hiện tại.

Kết quả:

```bash
    Hello World
```

---

Nhưng chúng ta không thể mãi chạy file **index.js** bằng lệnh trên, chúng ta sẽ tạo một **script** trong **package.json** để chạy file **index.js**.

Điều này sẽ giúp chúng ta khởi động ứng dụng một cách nhanh chóng. Và có thể kết hợp với các **script** khác để chạy ứng dụng.

```json
{
  "name": "helloWorld",
  "version": "1.0.0",
  "description": "Hello World",
  "main": "index.js",
  "scripts": {
    "start": "node index.js"
  },
  "author": "F8 Fullstack",
  "license": "ISC"
}
```

Sau khi thêm **script** vào **package.json**, chúng ta sẽ chạy ứng dụng bằng lệnh:

```bash
    npm start
```

Dòng lệnh này sẽ chạy file **index.js** trong thư mục hiện tại.

Kết quả:

```bash
    Hello World
```

---

Vậy, chúng ta có thể phát triển thêm dự án này bằng các thư viện, các frameworks khác như ExpressJS, NestJS, ... để xây dựng một ứng dụng hoàn chỉnh.

<!-- ## Tìm hiểu và sử dụng CommonJS và ES Module -->

## Import và export trong NodeJS

Trong NodeJS, chúng ta có thể sử dụng CommonJS và ES Module để import và export các module.

Nó giúp chúng ta chia được các đoạn code ở nhiều file khác nhau, xử lý các nghiệp vụ khác nhau, tách biệt các chức năng khác nhau,... và có thể sử dụng lại ở nhiều nơi khác nhau.

Nó giúp chúng ta viết code một cách hiệu quả, dễ quản lý, sửa lỗi và tái sử dụng hơn nhiều so với việc viết chung vào một file.

---

## CommonJS là gì?

CommonJS là một chuẩn được sử dụng để tạo các module trong Node.js. Nó được sử dụng trong các phiên bản Node.js cũ hơn, trước khi Node.js hỗ trợ ES Module.

Cú pháp CommonJS ở file export:

```js
// Export default
exports.default = "F8 Fullstack";

// Export named
module.exports = {
  name: "F8 Fullstack",
  age: 18,
};
```

Ở đây, chúng ta có thể sử dụng cả **export default** và **export named**.

Cú pháp CommonJS ở file import:

```js
// Import default
const message = require("./export").default; // F8 Fullstack
// Hoặc có thể viết ngắn gọn hơn
const { default: message } = require("./export");

// Import named
const { name, age } = require("./export");

// Hoặc có thể viết gộp cả default và named
const { default: message, name, age } = require("./export");
```

Ở đây, chúng ta có thể sử dụng cả **import default** và **import named**.

---

## ES Module là gì?

ES Module là một chuẩn được sử dụng để tạo các module trong Node.js. Nó được sử dụng trong các phiên bản Node.js mới hơn, sau khi Node.js hỗ trợ ES Module.

Cú pháp ES Module ở file export:

```js
// Export default
export default "F8 Fullstack";

// Export named
export const name = "F8 Fullstack";
export const age = 18;
```

Ở đây, chúng ta có thể sử dụng cả **export default** và **export named**.

Cú pháp ES Module ở file import:

```js
// Import default
import message from "./export"; // F8 Fullstack

// Import named
import { name, age } from "./export";

// Hoặc có thể viết gộp cả default và named
import message, { name, age } from "./export";
```

Ở đây, chúng ta có thể sử dụng cả **import default** và **import named**.

Cú pháp của ES Module sẽ ngắn gọn hơn so với CommonJS. Và ES Module sẽ được sử dụng nhiều hơn trong tương lai.

---

<!-- Xuất nội dung HTML, Json -->

## Các kiểu xuất nội dung trong NodeJS

Trong NodeJS, chúng ta có thể xuất nội dung dưới nhiều dạng khác nhau như HTML, JSON, XML, ...

Để xuất nội dung dưới dạng HTML, XML, chúng ta sẽ sử dụng **`res.send()`** hoặc **`res.end()`**.

Để xuất nội dung dưới dạng JSON, chúng ta sẽ sử dụng **`res.json()`**.

---

## Xuất nội dung dưới dạng HTML

Để xuất nội dung dưới dạng HTML, chúng ta sẽ sử dụng **`res.send()`** hoặc **`res.end()`**.

Việc xuất nội dung dưới dạng HTML thường được áp dụng ở các trang web sử dụng **server-side rendering**.

Xuất nội dung dạng HTML không chỉ là cả một trang web, nó còn là một đoạn mã HTML. Có thể chỉ để phục vụ cho một số trường hợp nhất định.

Ví dụ như chúng ta có một trang web, chúng ta muốn xuất một đoạn mã HTML để hiển thị một thông báo lỗi, chúng ta sẽ sử dụng **`res.send()`** hoặc **`res.end()`**.

Tuy nhiên, đôi lúc khi xuất một trang HTML, chúng rất dài, chúng ta sẽ không muốn viết cả trang HTML trong một file **index.js**. Điều này sẽ làm cho file **index.js** rất dài và khó quản lý.

Trong trường hợp đó, có một giải pháp được đặt ra là tạo một file HTML riêng và render file này, trong express.js, chúng ta sẽ sử dụng **`res.render()`**. Cũng có thể kết hợp thêm một module là **ejs** để render file HTML này. Cũng có thể sử dụng các module khác như **pug**, **handlebars**, ... Đa số chúng giúp chúng ta viết code HTML một cách ngắn gọn hơn và hỗ trợ dữ liệu động.

Ví dụ: Chúng ta có một file **views/index.pug** như sau:

```pug
doctype html
html
  head
    title= title
  body
    h1= message
```

Và một file **index.js** như sau:

```js
const http = require("http");
const pug = require("pug");
const compiledFunction = pug.compileFile("views/index.pug");
http
  .createServer((req, res) => {
    res.writeHead(200, { "Content-Type": "text/html" });
    res.end(compiledFunction({ title: "F8", message: "Fullstack" }));
  })
  .listen(3001);
```

Ở đây, chúng ta sẽ sử dụng **`res.end()`** để xuất nội dung dưới dạng HTML với đoạn mã HTML đã được render từ file **views/index.pug**.

Tuy nhiên, với các dữ liệu HTML quá lớn hoặc một số dữ liệu để giao tiếp với các ứng dụng khác, HTML không phải một lựa chọn tối ưu. Trong trường hợp này, chúng ta sẽ sử dụng JSON.

---

## Xuất nội dung dưới dạng JSON

Để xuất nội dung dưới dạng JSON, chúng ta sẽ sử dụng **`res.json()`**.

Cùng xem lại bức ảnh về mô hình thiết kế backend:

![OIP.jpg](https://files.fullstack.edu.vn/f8-prod/public-images/64ca823624d25.jpg)

Việc xuất nội dung dưới dạng JSON thường được áp dụng ở các trang web sử dụng **client-side rendering**.

Xuất nội dung dạng JSON thường được sử dụng để giao tiếp với các ứng dụng khác, chẳng hạn như giao tiếp với các ứng dụng di động, giao tiếp với các ứng dụng desktop, giao tiếp với các ứng dụng khác.

Ví dụ như chúng ta có một trang web, chúng ta muốn xuất một đoạn mã JSON để giao tiếp với các ứng dụng khác, chúng ta sẽ sử dụng **`res.json()`**.

Tuy nhiên, đôi lúc khi xuất một đoạn mã JSON, chúng rất dài, chúng ta sẽ không muốn viết cả đoạn mã JSON trong một file **index.js**. Điều này sẽ làm cho file **index.js** rất dài và khó quản lý.

Trong trường hợp đó, có một giải pháp được đặt ra là tạo một file JSON riêng, đọc file và xuất nội dung dưới dạng JSON, trong express.js, chúng ta sẽ sử dụng **`res.json()`**.

Cũng như HTML, chúng ta có thể xử lý và chỉ trả về đoạn JSON cần thiết đã được xử lý để gửi về client. Điều này giúp đoạn JSON được gửi về client nhỏ hơn và tối ưu hơn.

Ví dụ: Chúng ta có một file **data/data.json** như sau:

```json
{
  "name": "F8 Fullstack",
  "age": 18
}
```

Và một file **index.js** như sau:

```js
const express = require("express");
const app = express();

const data = require("./data/data.json");

app.get("/name", (req, res) => {
  res.json({ name: data.name });
});

app.get("/age", (req, res) => {
  res.json({ age: data.age });
});
app.listen(3000, () => console.log("Server started!"));
```

Ở đây, chúng ta sẽ sử dụng **`res.json()`** để xuất nội dung dưới dạng JSON.

Với JSON, chúng ta có thể tùy biến, xử lý và chỉ trả về đoạn JSON cần thiết đã được xử lý để gửi về client. Điều này giúp đoạn JSON được gửi về client nhỏ hơn và tối ưu hơn. Và phía client cũng sẽ dễ dàng xử lý hơn.

---

## Kết luận

Trong NodeJS, chúng ta có thể xuất nội dung dưới nhiều dạng khác nhau như HTML, JSON, XML, ...

Tùy các trường hợp khác nhau, chúng ta sẽ sử dụng các dạng khác nhau sao cho phù hợp.

Hầu hết, với các trang web hiện đại, chúng ta sẽ sử dụng JSON để giao tiếp với các ứng dụng khác. Và sử dụng HTML để render các trang web.

---

## Đọc nội dung file HTML

Như ở bài trước, chúng ta hoàn toàn có thể gửi một đoạn mã HTML về client để hiển thị một trang web.

Tuy nhiên, chúng ta có thể sử dụng dữ liệu động để render một trang web. Điều này giúp chúng ta có thể tùy biến nội dung trang web một cách dễ dàng.

Trong ví dụ này, chúng ta cùng tìm hiểu về cách đọc và thay đổi nội dung một file HTML thuần, một file ejs và một file pug. Đó là các cách thông dụng, phổ biến nhất hiện nay.

---

## Đọc, ghi nội dung file HTML

Để đọc nội dung một file HTML, chúng ta sẽ sử dụng module **fs**.

Trước tiên, chúng ta tạo một file **index.html** như sau:

```html
<title>{meta_title}</title>

<h1>{title}</h1>
<p>{message}</p>
```

**Tại sao không cần thẻ body, head hay html?**

Vì khi gửi một đoạn mã HTML về client, nó sẽ được hiểu là một đoạn mã HTML đầy đủ. Nó sẽ tự động thêm các thẻ body, head hay html vào.

Và một file **index.js** như sau:

```js
const http = require("http");
const fs = require("fs");

const data = {
  meta_title: "F8",
  title: "Fullstack",
  message: "NodeJS",
};
const replace = (value) => {
  const regex = new RegExp(`{${value}}`, "gi");
  return htmlContent.replace(regex, data[value]);
};

let htmlContent = fs.readFileSync("views/index.html", { encoding: "utf-8" });
Object.keys(data).forEach((value) => {
  htmlContent = replace(value);
});
http
  .createServer((req, res) => {
    res.writeHead(200, { "Content-Type": "text/html" });
    res.end(htmlContent);
  })
  .listen(3000);
```

Ở đoạn code này, chúng ta sử dụng 2 module là **http** và **fs**.

Sau đó chúng ta sử dụng **`fs.readFileSync()`** để đọc nội dung file **views/index.html** với encoding là **utf-8**.

Tiếp theo chúng ta sử dụng **`Object.keys()`** để lấy ra các key của object **data**. Và sử dụng **`forEach()`** để duyệt qua các key của object **data** sau đó sử dụng **`replace()`** để thay thế các key của object **data** với các giá trị tương ứng.

Cuối cùng chúng ta sử dụng **`res.end()`** để xuất nội dung dưới dạng HTML với đoạn mã HTML đã được render từ file **views/index.html**.

Với cách làm này, chúng ta khá mất công khi phải xây dựng từ đầu một hàm replace, lặp qua các data cần thay đổi để thay thế.

---

## Đọc, ghi nội dung file ejs

Để đọc nội dung một file ejs, chúng ta sẽ sử dụng module **fs**.

Trước tiên, chúng ta tạo một file **views/index.ejs** như sau:

```ejs
<title><%= meta_title %></title>

<h1><%= title %></h1>
<p><%= message %></p>
```

Và một file **index.js** như sau:

```js
const http = require("http");
const ejs = require("ejs");
const data = {
  meta_title: "F8",
  title: "Fullstack",
  message: "NodeJS",
};
http
  .createServer((req, res) => {
    res.writeHead(200, { "Content-Type": "text/html" });
    ejs.renderFile("./views/index.ejs", data, (err, str) => {
      err ? console.log(err) : res.end(str);
    });
  })
  .listen(3000);
```

Ở đoạn code này, chúng ta sử dụng 2 module là **http** và **ejs**.

Với **`ejs.renderFile()`**, chúng ta có thể render một file ejs với các dữ liệu cần thiết. Và sử dụng **`res.end()`** để xuất nội dung dưới dạng HTML với đoạn mã HTML đã được render từ file **views/index.ejs**.

Với cách làm này, chúng ta có thể sử dụng các biểu thức ejs để thay thế các dữ liệu cần thiết một cách ngắn gọn hơn.

---

## Đọc, ghi nội dung file pug

Một cách khác để đọc và thay đổi nội dung file HTML với dữ liệu động là sử dụng file pug.

Pug có cú pháp ngắn gọn hơn, dễ hiểu hơn ejs. Và cũng có thể sử dụng các biểu thức pug để thay thế các dữ liệu cần thiết một cách ngắn gọn hơn.

Trước tiên, chúng ta tạo một file **views/index.pug** như sau:

```pug
doctype html
html
  head
    title= meta_title
  body
    h1= title
    p= message
```

Và một file **index.js** như sau:

```js
const http = require("http");
const pug = require("pug").compileFile("views/index.pug");
const data = {
  meta_title: "F8",
  title: "Fullstack",
  message: "NodeJS",
};
http
  .createServer((req, res) => {
    res.writeHead(200, { "Content-Type": "text/html" });
    res.end(pug(data));
  })
  .listen(3000);
```

Ở đoạn code này, chúng ta sử dụng 2 module là **http** và **pug**.

Với **`pug.compileFile()`**, chúng ta có thể render một file pug với các dữ liệu cần thiết. Và sử dụng **`res.end()`** để xuất nội dung dưới dạng HTML với đoạn mã HTML đã được render từ file **views/index.pug**.

Với cách làm này, chúng ta có thể sử dụng các biểu thức pug để thay thế các dữ liệu cần thiết một cách ngắn gọn hơn và đơn giản hơn.

---

## Kết luận

Trong NodeJS, chúng ta có thể đọc và thay đổi nội dung một file HTML thuần hoặc một file ejs hay một file pug... để render một trang web.

Tuy nhiên, hiện nay đã có nhiều frameworks hỗ trợ chúng ta render một trang web một cách dễ dàng hơn, nhanh chóng hơn và hiệu quả hơn.

---

## Tìm hiểu về Nodemon

Khi viết NodeJS, chúng ta thường phải khởi động lại server để xem kết quả thay đổi. Điều này sẽ rất mất thời gian và không hiệu quả.

Vì vậy, thường nodemon sẽ là một lựa chọn tuyệt vời làm thay chúng ta khởi động lại server mỗi khi có thay đổi.

---

## Nodemon sử dụng như thế nào?

Để sử dụng nodemon, chúng ta cần cài đặt nodemon bằng lệnh:

```bash
    npm install -g nodemon
```

Câu lệnh này sẽ giúp chúng ta cài đặt nodemon ở chế độ toàn cục, có nghĩa là có thể sử dụng nodemon ở bất kỳ thư mục nào.

Sau khi cài đặt xong, chúng ta có thể đưa nodemon vào **scripts** trong **package.json** như sau:

```json
{
  "name": "helloWorld",
  "version": "1.0.0",
  "description": "Hello World",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "dev": "nodemon index.js"
  },
  "author": "F8 Fullstack"
}
```

Ở đây, chúng ta sẽ sử dụng **`npm run dev`** để chạy nodemon. Và sử dụng **`npm start`** để chạy node ở bản production.

---

## Kết luận

Nodemon là một công cụ hỗ trợ rất tốt cho chúng ta khi viết NodeJS. Nó giúp chúng ta khởi động lại server mỗi khi có thay đổi.

Nodemon chỉ nên sử dụng ở môi trường development, ở môi trường production, chúng ta nên sử dụng node. Vì nodemon sẽ tốn nhiều tài nguyên hơn node.

---

## Xử lý Routing trong NodeJS

Trong NodeJS, chúng ta có thể xử lý routing bằng cách sử dụng module **http** hoặc sử dụng các frameworks như ExpressJS, NestJS, ...

Điều này giúp chúng ta có thể xử lý các đường dẫn khác nhau, các phương thức khác nhau, các tham số khác nhau, ... một cách dễ dàng và hiệu quả hơn.

Routing là quá trình xử lý các yêu cầu của người dùng dựa trên đường dẫn URL. Trong NodeJS, chúng ta có thể xử lý routing bằng cách sử dụng module http hoặc sử dụng các frameworks như ExpressJS, NestJS, ...

Module http cung cấp một số hàm để xử lý routing, chẳng hạn như `createServer()`, `listen()`, `on()`, ... Chúng ta có thể sử dụng các hàm này để tạo một máy chủ HTTP và xử lý các yêu cầu của người dùng dựa trên đường dẫn URL.

Các frameworks như ExpressJS và NestJS cung cấp một số tính năng bổ sung để xử lý routing, chẳng hạn như định tuyến các đường dẫn, xử lý các phương thức HTTP khác nhau, xử lý các tham số khác nhau, ... Điều này giúp chúng ta có thể xử lý routing một cách dễ dàng và hiệu quả hơn.

Ví dụ:

```js
const http = require("http");

const server = http.createServer((req, res) => {
  // Lấy đường dẫn URL
  const path = req.url;

  // Lấy query từ URL
  const params = req.url.split(`?`).slice(1)[0]?.split(`&`);
  const query = {};
  params?.forEach((param) => {
    const [key, value] = param.split(`=`);
    query[key] = value;
  });
  // Xử lý các yêu cầu khác nhau dựa trên đường dẫn URL
  if (path === "/") {
    res.end("Home world");
  } else if (path === "/about") {
    res.end("About world");
  } else if (path.includes(`?`)) {
    res.end(JSON.stringify(query));
  } else {
    res.end("Not found world");
  }
});

server.listen(3000, () => {
  console.log("Server is listening on port 3000");
});
```

Ví dụ trên sẽ tạo một máy chủ HTTP và lắng nghe yêu cầu trên cổng 3000. Khi có một yêu cầu đến đường dẫn `/`, máy chủ sẽ gửi phản hồi `Hello, World!`. Khi có một yêu cầu đến đường dẫn `/about`, máy chủ sẽ gửi phản hồi `About world`. Các yêu cầu đến các đường dẫn khác sẽ nhận được phản hồi `404 Not Found`.

---

## Kết luận

Xử lý routing là một phần quan trọng và không thể thiếu trong làm việc với NodeJS backend. Nó giúp chúng ta xử lý được các yêu cầu khác nhau của client, hoặc người dùng dựa trên đường dẫn URL.

---

## Tìm hiểu về HTTP GET

HTTP GET là một trong các phương thức HTTP được sử dụng để gửi yêu cầu từ client đến server. Phương thức này được sử dụng để lấy dữ liệu từ server.

Phương thức GET thường được sử dụng để truy vấn các trang web, tải tài liệu và thực hiện các thao tác khác. Phương thức này cũng được sử dụng để lấy dữ liệu từ server để sử dụng trong các ứng dụng web.

Để sử dụng phương thức GET, chúng ta cần chỉ định URL của tài nguyên mà chúng ta muốn lấy dữ liệu trong yêu cầu. Chúng ta cũng có thể chỉ định các tham số trong yêu cầu để lọc hoặc sắp xếp kết quả.

Ví dụ về cách sử dụng phương thức GET để truy vấn một trang web:

```shell
GET /index.html HTTP/1.1
Host: fullstack.edu.vn
```

Yêu cầu trên sẽ yêu cầu server gửi trang `index.html`.

Ví dụ về cách sử dụng phương thức GET để tải một tài liệu:

```shell
GET /images/logo.png HTTP/1.1
Host: fullstack.edu.vn
```

Yêu cầu trên sẽ yêu cầu server gửi tài liệu `logo.png`.

Ví dụ về cách sử dụng phương thức GET để thực hiện một thao tác:

```shell
GET /users/12345/edit HTTP/1.1
Host: fullstack.edu.vn
```

Yêu cầu trên sẽ yêu cầu server hiển thị trang chỉnh sửa người dùng có ID là 12345.

Phương thức GET là một phương thức quan trọng trong HTTP. Phương thức này được sử dụng để lấy dữ liệu từ server để sử dụng trong các ứng dụng web.

---

## Cách kiểm tra một method GET

Để kiểm tra một method GET, chúng ta có thể sử dụng module **http** với hàm **`createServer()`**.

```js
const http = require("http");

const server = http.createServer((req, res) => {
  res.setHeader("Content-Type", "text/html; charset=utf-8");
  if (req.method === "GET") {
    return res.end("<h1>Đây là method GET!</h1>");
  }
  res.end("<h1>Không phải method GET!</h1>");
});

server.listen(3000, () => {
  console.log("Server is listening on port 3000");
});
```

Ở ví dụ này, chúng ta sử dụng hàm **`createServer()`** để tạo một máy chủ HTTP. Khi có một yêu cầu đến, chúng ta sẽ kiểm tra xem method của yêu cầu có phải là GET hay không. Nếu là GET, chúng ta sẽ gửi phản hồi `Đây là method GET!`. Nếu không phải, chúng ta sẽ gửi phản hồi `Không phải method GET!`.

---

## Cách lấy dữ liệu từ URL

Để lấy dữ liệu từ URL, chúng ta có thể sử dụng module **url** với hàm **`parse()`**.

```js
const http = require("http");
const url = require("url");

const controller = (req, res) => {
  if (req.method === "GET") {
    const parsedUrl = url.parse(req.url, true);
    const { pathname, query } = parsedUrl;
    if (pathname === "/") {
      return res.end("<h1>Đây là trang chủ!</h1>");
    }
    if (pathname === "/about") {
      return res.end("<h1>Đây là trang giới thiệu!</h1>");
    }
    if (pathname === "/users") {
      return res.end(
        `<h1>Đây là trang người dùng!</h1>
        <p>Query: ${JSON.stringify(query)}</p>`
      );
    }
    return res.end("<h1>Không tìm thấy trang!</h1>");
  }
  res.end("<h1>Không phải method GET!</h1>");
};

http
  .createServer((req, res) => {
    res.setHeader("Content-Type", "text/html; charset=utf-8");
    controller(req, res);
  })
  .listen(3000);
```

Ở ví dụ này, chúng ta sử dụng hàm **`parse()`** để lấy dữ liệu từ URL.

Khi `pathname` là `/users`, chúng ta sẽ lấy dữ liệu từ `query` để hiển thị.

---

## Kết luận

Mặc định khi vào một trang web, sẽ có một yêu cầu với method GET được gửi đến server để lấy nội dung của trang web. Điều này giúp chúng ta có thể lấy nội dung của trang web một cách dễ dàng.

Vì vậy, phương thức GET là một phương thức quan trọng trong HTTP, nó được sử dụng để lấy dữ liệu từ server để sử dụng trong các ứng dụng web.

Ngoài ra, khi sử dụng method GET, chúng ta cũng có thể lấy dữ liệu từ server để sử dụng trong các ứng dụng khác, chia sẻ đường dẫn URL cho người dùng, người khác...

Vì sử dụng method là GET, chúng ta sẽ lấy dữ liệu từ url bằng params và query... Chúng không có body. Vì vậy, với các dữ liệu lớn, chúng ta cần lấy dữ liệu với nhiều đầu vào khác nhau, chúng ta sẽ sử dụng method POST.

---

## Xử lý form trong NodeJS

Xử lý form là quá trình lấy dữ liệu từ form trên client và lưu trữ nó trên server. Form thường được sử dụng để gửi dữ liệu từ người dùng đến server, chẳng hạn như tên, email, địa chỉ, v.v.

Để xử lý form, chúng ta có thể sử dụng module `http` của NodeJS. Module này cung cấp hàm `on()` để xử lý các yêu cầu HTTP. Hàm `on()` có hai tham số: phương thức HTTP và hàm xử lý. Hàm xử lý sẽ được gọi khi có một yêu cầu HTTP đến với phương thức được chỉ định.

Để xử lý form, chúng ta có thể sử dụng hàm `req.body` để lấy dữ liệu từ form. Hàm `req.body` trả về một đối tượng có các thuộc tính tương ứng với các trường của form.

Dưới đây là một ví dụ về cách xử lý form trong NodeJS:

```js
const http = require("http");

const getBody = (req) => {
  return new Promise((resolve, reject) => {
    let body = "";
    req.on("data", (chunk) => {
      body += chunk.toString();
    });
    req.on("end", () => {
      resolve(body);
    });
    req.on("error", (err) => {
      reject(err);
    });
  });
};

const server = http.createServer(async (req, res) => {
  const body = await getBody(req);
  res.end(body);
});

server.listen(3000, () => {
  console.log("Server is listening on port 3000");
});
```

Trong ví dụ trên, chúng ta đã sử dụng hàm `getBody()` để lấy dữ liệu từ form. Hàm này sẽ trả về một đối tượng có các thuộc tính tương ứng với các trường của form.

Sau khi lấy dữ liệu từ form, chúng ta có thể lưu trữ nó trên server hoặc thực hiện các thao tác khác.

---

## Kết luận

Form thường được xử lý ở phía server vì lý do bảo mật. Dữ liệu từ form có thể chứa thông tin nhạy cảm, chẳng hạn như tên người dùng, mật khẩu, v.v. Nếu chúng ta xử lý form ở phía client, dữ liệu này sẽ bị hiển thị trên trình duyệt web của người dùng. Điều này có thể khiến dữ liệu bị đánh cắp bởi kẻ tấn công.

Xử lý form ở phía server giúp chúng ta bảo vệ dữ liệu của người dùng khỏi bị đánh cắp. Và tránh được các cuộc tấn công không sử dụng form phía client. Ví dụ như postman, curl, ...

---

<!-- ## Validate Form với NodeJS -->

## Validate là gì?

Validate là một quá trình kiểm tra tính hợp lệ của dữ liệu. Quá trình này giúp chúng ta đảm bảo rằng dữ liệu là chính xác và phù hợp với các yêu cầu.

Validate thường được sử dụng trong các ứng dụng web để kiểm tra dữ liệu được nhập bởi người dùng. Ví dụ, chúng ta có thể sử dụng validate để kiểm tra xem tên người dùng đã nhập có hợp lệ hay không, mật khẩu có đủ mạnh hay không, v.v.

Validate cũng được sử dụng trong các ứng dụng cơ sở dữ liệu để kiểm tra dữ liệu trước khi lưu trữ nó vào cơ sở dữ liệu. Ví dụ, chúng ta có thể sử dụng validate để kiểm tra xem số điện thoại đã nhập có đúng định dạng hay không, ngày tháng đã nhập có hợp lệ hay không, v.v.

Validate giúp chúng ta tránh được các lỗi xảy ra trong quá trình lưu trữ dữ liệu. Ví dụ, nếu chúng ta không validate số điện thoại trước khi lưu trữ nó vào cơ sở dữ liệu, có thể xảy ra lỗi nếu số điện thoại không đúng định dạng. Điều này có thể khiến chúng ta không thể truy vấn dữ liệu từ cơ sở dữ liệu.

Validate là một quá trình quan trọng trong việc đảm bảo tính chính xác và tính toàn vẹn của dữ liệu.

---

## Validate Form với NodeJS

Validate form là quá trình kiểm tra tính hợp lệ của dữ liệu được nhập bởi người dùng trong một form. Quá trình này giúp chúng ta đảm bảo rằng dữ liệu là chính xác và phù hợp với các yêu cầu.

Validate form thường được sử dụng trong các ứng dụng web để kiểm tra dữ liệu được nhập bởi người dùng. Ví dụ, chúng ta có thể sử dụng xác thực form để kiểm tra xem tên người dùng đã nhập có hợp lệ hay không, mật khẩu có đủ mạnh hay không, v.v.

Validate form cũng được sử dụng trong các ứng dụng cơ sở dữ liệu để kiểm tra dữ liệu trước khi lưu trữ nó vào cơ sở dữ liệu. Ví dụ, chúng ta có thể sử dụng xác thực form để kiểm tra xem số điện thoại đã nhập có đúng định dạng hay không, ngày tháng đã nhập có hợp lệ hay không, v.v.

Validate form giúp chúng ta tránh được các lỗi xảy ra trong quá trình lưu trữ dữ liệu. Ví dụ, nếu chúng ta không xác thực số điện thoại trước khi lưu trữ nó vào cơ sở dữ liệu, có thể xảy ra lỗi nếu số điện thoại không đúng định dạng. Điều này có thể khiến chúng ta không thể truy vấn dữ liệu từ cơ sở dữ liệu.

Validate form là một quá trình quan trọng trong việc đảm bảo tính chính xác và tính toàn vẹn của dữ liệu.

Dưới đây là một ví dụ về cách xác thực form trong NodeJS:

```js
const http = require("http");
const bodyParser = require("body-parser");
// Hàm kiểm tra thông tin đăng ký
const validate = (body) => {
  const { name, email, password } = body;
  const regex = /^[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,4}$/;
  // Kiểm tra từng trường thông tin
  return (
    (!name && "Chưa nhập tên") ||
    (!email && "Chưa nhập email") ||
    (!password && "Chưa nhập mật khẩu") ||
    (password.length < 8 && "Mật khẩu phải có ít nhất 8 ký tự") ||
    (!email.trim().match(regex) && "Email không hợp lệ") ||
    (name.trim().length < 3 && "Tên phải có ít nhất 3 ký tự") ||
    false
  );
};
http
  .createServer((req, res) => {
    res.setHeader("Content-Type", "text/html; charset=utf-8");
    // Xử lý đường dẫn /signup
    if (req.url === "/signup") {
      // Xử lý phương thức POST
      if (req.method === "POST") {
        // Sử dụng bodyParser để lấy dữ liệu từ request body
        bodyParser.json()(req, res, () => {
          const errorMsg = validate(req.body);
          // Nếu có lỗi, trả về thông báo lỗi
          if (errorMsg) res.end(`<span style="color: red;">${errorMsg}</span>`);
          else {
            // Ngược lại, hiển thị thông tin đăng ký
            const { name, email } = req.body;
            res.end(
              `
                <span style="color: green;">
                    Chúc mừng ${name} đã đăng ký thành công với email 
                    <a href="mailto:${email}">${email}</a>
                </span>
               `
            );
          }
        });
      } else {
        // Phương thức khác với /signup chỉ được hỗ trợ là POST
        res.end(
          "<span style='color: red;'>Phương thức không được hỗ trợ</span>"
        );
      }
    } else {
      // Xử lý đường dẫn không phải /signup
      res.end("<a href='/signup'>Trang đăng ký tài khoản</a>");
    }
  })
  .listen(3000);
```

Trong ví dụ trên, chúng ta đã sử dụng module `body-parser` để xác thực dữ liệu được nhập bởi người dùng trong form.

Chúng ta đã sử dụng cú pháp `if/else` để kiểm tra tính hợp lệ của dữ liệu.

Nếu dữ liệu không hợp lệ, chúng ta sẽ gửi một phản hồi cho người dùng.

Nếu dữ liệu hợp lệ, chúng ta sẽ đưa ra một phản hồi khác cho người dùng.

---

<!-- Upload File với NodeJS -->

## Upload file là gì?

Upload file là quá trình chuyển dữ liệu từ client lên server. Quá trình này giúp chúng ta lưu trữ dữ liệu trên server để sử dụng trong các ứng dụng web.

Upload file thường được sử dụng trong các ứng dụng web để lưu trữ các tệp được tải lên bởi người dùng. Ví dụ, chúng ta có thể sử dụng upload file để lưu trữ các tệp hình ảnh, tệp video, tệp âm thanh, v.v.

Ví dụ:

> **Cảnh báo**: Nội dung code dưới đây rất "Gây lú" với một số bạn. Nếu bạn không muốn bị "Gây lú", hãy xem thật nhiều để bớt lú :>!

```js
const http = require("http");
const path = require("path");
const formidable = require("formidable");
const fs = require("fs");
const uploadDir = path.join(__dirname, "uploads");
if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir);
}
const form = new formidable.IncomingForm();
form.uploadDir = uploadDir;
form.keepExtensions = true;
const uploadImage = async (req, res) => {
  try {
    await new Promise((resolve, reject) => {
      form.parse(req, (err, fields, files) => {
        if (err) return reject(err);
        const pathFile = files["file"] ? files["file"][0] : files[""][0];
        const name = pathFile.originalFilename;
        fs.rename(pathFile.filepath, path.join(uploadDir, name), (err) => {
          if (err) return reject(err);
          resolve(name);
        });
      });
    });
    res.writeHead(200, { "Content-Type": "text/plain" });
    res.end("File uploaded!");
  } catch (err) {
    res.writeHead(500, { "Content-Type": "text/plain" });
    res.end(err.message);
  }
};
http
  .createServer(async (req, res) => {
    if (req.method === "POST") {
      await uploadImage(req, res);
    } else {
      res.writeHead(200, { "Content-Type": "text/plain" });
      res.end("Try POST method!");
    }
  })
  .listen(3000);
```

Trong ví dụ trên, chúng ta đã sử dụng module `http` để tạo một máy chủ HTTP.

Sau đó, chúng ta đã sử dụng module `formidable` để xử lý dữ liệu được tải lên từ client.

Để sử dụng được module `formidable`, chúng ta cần cài đặt module này bằng lệnh:

```bash
npm install formidable
```

Cuối cùng, chúng ta đã sử dụng module `fs` để lưu trữ dữ liệu trên server.

---

## Kết luận

Upload file là một quá trình quan trọng trong việc lưu trữ dữ liệu trên server. Nó giúp chúng ta lưu trữ các tệp được tải lên bởi người dùng để sử dụng trong các ứng dụng web.

Upload file thường được sử dụng trong các ứng dụng web để lưu trữ các tệp hình ảnh, tệp video, tệp âm thanh, v.v.

Upload file là một phần quan trọng trong một trang web lớn và chuyên nghiệp. Nó giúp chúng ta lưu trữ các tệp được tải lên bởi người dùng để sử dụng trong các ứng dụng web.

---

## Session trong NodeJS

![image.png](https://files.fullstack.edu.vn/f8-prod/public-images/64cfe0536b1e1.png)

Session là một cơ chế cho phép bạn lưu trữ dữ liệu liên quan đến một phiên làm việc cụ thể của người dùng trên máy chủ. Phiên là một khoảng thời gian ngắn mà người dùng tương tác với ứng dụng của bạn, thường bắt đầu khi họ truy cập và kết thúc khi họ đăng xuất hoặc thoát.

Để sử dụng session trong NodeJS, chúng ta có thể sử dụng module `express-session`. Module này cung cấp một số API để tạo và quản lý session. Chúng ta có thể sử dụng các API này để lưu trữ dữ liệu session trong bộ nhớ hoặc cơ sở dữ liệu.

Nhưng ở bài này, chúng ta sẽ tự build ra một phương thức để lấy session, không sử dụng tới `express-session`.

---

## Ví dụ

Ví dụ về cách để tạo một session:

```js
const http = require("http"); // module http
const fs = require("fs"); // module fs
const uuid = require("uuid"); // module uuid sử dụng để tạo một id randoms
const serialize = require("serialize-javascript"); // module serialize sử dụng để tạo một object

// Đường dẫn tới thư mục lưu trữ session
const sessionDir = "./sessions";
// Nếu chưa có sessionDir thì tạo mới
if (!fs.existsSync(sessionDir)) {
  fs.mkdirSync(sessionDir);
}
// Hàm lấy thời gian hiện tại
function now() {
  return new Date().toLocaleString();
}
// Hàm tạo mới session
function createSession() {
  const sessionId = uuid.v4(); // Tạo ID duy nhất
  const sessionData = {
    id: sessionId,
    lastAccessed: now(),
    data: {},
  }; // Dữ liệu session ban đầu là một object chứa id của nó, thời gian khởi tạo
  const sessionPath = `${sessionDir}/${sessionId}.json`;
  // Lưu dữ liệu session vào file
  fs.writeFileSync(sessionPath, serialize(sessionData));
  return sessionId;
}

// Hàm đọc session
function readSession(sessionId) {
  const sessionPath = `${sessionDir}/${sessionId}.json`;
  try {
    const sessionData = fs.readFileSync(sessionPath, "utf-8");
    const session = JSON.parse(sessionData);
    session.lastAccessed = now();
    fs.writeFileSync(sessionPath, serialize(session));
    return session;
  } catch (error) {
    return {};
  }
}

// Tạo server
http
  .createServer((req, res) => {
    const cookies = req.headers.cookie || "";
    const sessionId = cookies.split("=")[1];
    // Xử lý khi client gửi request
    if (req.url === "/") {
      // Nếu chưa có session thì tạo mớii
      if (!sessionId) {
        const newSessionId = createSession();
        // Gửi Set-Cookie header wit infinity time
        res.setHeader(
          "Set-Cookie",
          `sessionId=${newSessionId}; expires=${Date.UTC(9999, 12, 31)}`
        );
        res.writeHead(200, { "Content-Type": "text/plain" });
        res.end("Session created!" + newSessionId);
      } else {
        // nếu có rồi chuyển hướng sang trang /get-session
        res.writeHead(302, {
          Location: "/get-session",
        });
        res.end();
      }
    } else if (req.url === "/get-session") {
      try {
        // Tìm sessionId trong /sessions/*.json file
        if (!fs.existsSync(`${sessionDir}/${sessionId}.json`)) {
          // xóa cookie trong /sessions/*.json, của trình duyệt
          res.setHeader("Set-Cookie", `sessionId=;`);
          res.writeHead(302, {
            Location: "/",
          });
          return res.end();
        }
        // Nếu đã tìm được sessionId, trả về data
        const sessionData = readSession(sessionId);
        res.writeHead(200, { "Content-Type": "application/json" });
        res.end(JSON.stringify(sessionData));
      } catch (error) {
        console.log("error", error);
        res.writeHead(302, {
          Location: "/",
        });
        res.end();
      }
    } else {
      res.writeHead(404, { "Content-Type": "text/plain" });
      res.end("Not Found");
    }
  })
  .listen(3000);
```

Trong ví dụ trên, chúng ta đã sử dụng một số thư viện và chức năng chính của chúng trong đoạn code:

- http: Được sử dụng để create server.

- fs: Được sử dụng để đọc, ghi, kiểm tra sự tồn tại của một file.

- uuid: Được sử dụng để tạo một id ngẫu nhiên dài mà đảm bảo không bị trùng.

- serialize: Được sử dụng để tuần tự hóa(serialize) một tập hợp Object thành JSON, bao gồm biểu thức chính quy, hàm,...

---

Chúng ta cũng có thể sử dụng session để lưu trữ dữ liệu khác, chẳng hạn như trạng thái giỏ hàng, v.v.

Dưới đây là một ví dụ về cách sử dụng session để lưu trữ trạng thái giỏ hàng:

```js
const http = require("http"); // module http
const fs = require("fs"); // module fs
const uuid = require("uuid"); // module uuid sử dụng để tạo một id randoms
const serialize = require("serialize-javascript"); // module serialize sử dụng để tạo một object

// Đường dẫn tới thư mục lưu trữ session
const sessionDir = "./sessions";
// Nếu chưa có sessionDir thì tạo mới
if (!fs.existsSync(sessionDir)) {
  fs.mkdirSync(sessionDir);
}
// Hàm lấy thời gian hiện tại
function now() {
  return new Date().toLocaleString();
}
// Hàm tạo mới session
function createSession() {
  const sessionId = uuid.v4(); // Tạo ID duy nhất
  const sessionData = {
    id: sessionId,
    lastAccessed: now(),
    data: {},
  }; // Dữ liệu session ban đầu là một object chứa id của nó, thời gian khởi tạo
  const sessionPath = `${sessionDir}/${sessionId}.json`;
  // Lưu dữ liệu session vào file
  fs.writeFileSync(sessionPath, serialize(sessionData));
  return sessionId;
}

// Hàm đọc session
function readSession(sessionId) {
  const sessionPath = `${sessionDir}/${sessionId}.json`;
  try {
    const sessionData = fs.readFileSync(sessionPath, "utf-8");
    const session = JSON.parse(sessionData);
    session.lastAccessed = now();
    fs.writeFileSync(sessionPath, serialize(session));
    return session;
  } catch (error) {
    return {};
  }
}

function destroySession(sessionId, res) {
  const sessionPath = `${sessionDir}/${sessionId}.json`;
  if (fs.existsSync(sessionPath)) {
    fs.unlinkSync(sessionPath);
  }
  // xóa cookie trong /sessions/*.json, của trình duyệt
  res.setHeader("Set-Cookie", `sessionId=;`);
  res.writeHead(302, {
    Location: "/",
  });
  res.end();
}
function checkSession(sessionId, res) {
  if (!fs.existsSync(`${sessionDir}/${sessionId}.json`)) {
    return false;
  }
  return true;
}

async function addCart(sessionId, cartObj) {
  // Lấy data của session trong /sessions/*.json file
  const sessionData = fs.readFileSync(
    `${sessionDir}/${sessionId}.json`,
    "utf-8"
  );
  const session = await JSON.parse(sessionData);
  const { data } = session;
  // Thêm item trong cart
  !data.cart || data.cart === []
    ? (data.cart = [cartObj])
    : (data.cart = [...data.cart, cartObj]);
  fs.writeFileSync(`${sessionDir}/${sessionId}.json`, serialize(session));
  // Cập nhật time
  readSession(sessionId);
  // Trả về thông tin cart
  return session.data.cart;
}
// Tạo server
http
  .createServer((req, res) => {
    const cookies = req.headers.cookie || "";
    const sessionId = cookies.split("=")[1];
    // Xử lý khi client gửi request
    if (req.url === "/") {
      // Nếu chưa có session thì tạo mới
      if (!sessionId) {
        const newSessionId = createSession();
        // Gửi Set-Cookie header
        res.setHeader(
          "Set-Cookie",
          `sessionId=${newSessionId}; expires=${Date.UTC(9999, 12, 31)}`
        );
        res.writeHead(200, { "Content-Type": "text/plain" });
        res.end("Session created!" + newSessionId);
      } else {
        // nếu có rồi chuyển hướng sang trang /get-session
        res.writeHead(302, {
          Location: "/get-session",
        });
        res.end();
      }
    } else if (req.url === "/get-session") {
      try {
        // Tìm sessionId trong /sessions/*.json file
        if (checkSession(sessionId, res)) {
          // Nếu đã tìm được sessionId, trả về data
          const sessionData = readSession(sessionId);
          res.writeHead(200, { "Content-Type": "application/json" });
          res.end(JSON.stringify(sessionData));
        } else {
          destroySession(sessionId, res);
        }
      } catch (error) {
        destroySession(sessionId, res);
      }
    } else if (req.url === "/cart") {
      // Nếu sessionId không tồn tại trong folder sessions
      if (checkSession(sessionId, res)) {
        (async () => {
          const cartObj = {
            id: uuid.v4(),
            name: "F8 - fullstack",
            price: 10000,
            quantity: 1,
          };
          const data = await addCart(sessionId, cartObj);
          res.writeHead(200, { "Content-Type": "application/json" });
          res.end(JSON.stringify(data));
        })();
      } else {
        destroySession(sessionId, res);
      }
    } else {
      res.writeHead(404, { "Content-Type": "text/plain" });
      res.end("Not Found");
    }
  })
  .listen(3000);
```

Trong ví dụ trên, chúng ta đã sử dụng session để lưu trữ trạng thái giỏ hàng. Chúng ta đã sử dụng thuộc tính `cart` để lưu trữ danh sách các sản phẩm trong giỏ hàng. Chúng ta đã sử dụng thuộc tính `id` để lưu trữ ID của sản phẩm, thuộc tính `name` để lưu trữ tên của sản phẩm và thuộc tính `quantity` để lưu trữ số lượng của sản phẩm.

---

## Quá trình xử lý

Khi một yêu cầu mới đến, chúng ta đọc Headers "Cookie" trong yêu cầu để xem nếu có thông tin về phiên được gửi từ trình duyệt của người dùng.

Nếu có, chúng ta đọc dữ liệu session tương ứng từ tệp và tiến hành xử lý yêu cầu với dữ liệu session này.

Nếu không có thông tin phiên trong cookie, chúng ta tạo một phiên mới bằng cách tạo một ID duy nhất, tạo dữ liệu session tương ứng, lưu trữ dữ liệu session vào tệp và gửi một Headers "Set-Cookie" đến trình duyệt để lưu thông tin phiên.

## Kết luận

Mỗi phiên làm việc sẽ có một ID duy nhất, và dữ liệu session tương ứng sẽ được lưu trữ trong một tệp có tên giống với ID của phiên.

Các dữ liệu session được chuyển đổi thành định dạng văn bản và lưu trữ dưới dạng tệp.

Cần quản lý việc lưu trữ tệp, xử lý bảo mật cho session, và cân nhắc các vấn đề liên quan đến hiệu suất và tối ưu hóa.

---

## Cookie trong NodeJS

Cookie là một chuỗi văn bản nhỏ được lưu trữ trên máy tính của người dùng bởi một trang web. Cookie được sử dụng để lưu trữ thông tin về người dùng, chẳng hạn như tên người dùng, mật khẩu, ngôn ngữ, v.v. Cookie có thể được sử dụng để theo dõi hoạt động của người dùng trên một trang web, để cá nhân hóa trải nghiệm của người dùng, và để lưu trữ trạng thái của một trang web.

Cookie được sử dụng bằng cách gửi chúng từ máy chủ web đến máy tính của người dùng. Khi người dùng truy cập một trang web, máy chủ web sẽ gửi cookie đến máy tính của người dùng. Cookie sau đó được lưu trữ trên máy tính của người dùng và sẽ được gửi trở lại máy chủ web khi người dùng truy cập trang web đó một lần nữa.

Cookie có thể được sử dụng để lưu trữ một số loại thông tin, bao gồm:

- Access Token, Refresh Token
- Ngôn ngữ
- Quốc gia
- Ngày truy cập
- Trang web đã truy cập
- Sản phẩm đã xem
- Đơn hàng đã đặt

Cookie có thể được sử dụng để theo dõi hoạt động của người dùng trên một trang web. Ví dụ: một trang web có thể sử dụng cookie để theo dõi số lần người dùng đã truy cập trang web, các trang web mà người dùng đã truy cập, và các sản phẩm mà người dùng đã xem. Thông tin này có thể được sử dụng để cải thiện trải nghiệm của người dùng trên trang web và để cá nhân hóa quảng cáo.

Cookie cũng có thể được sử dụng để lưu trữ trạng thái của một trang web. Ví dụ: một trang web có thể sử dụng cookie để lưu trữ trạng thái của giỏ hàng của người dùng. Khi người dùng thêm một sản phẩm vào giỏ hàng, trang web sẽ lưu trữ thông tin về sản phẩm trong cookie. Khi người dùng truy cập trang giỏ hàng, trang web sẽ đọc thông tin từ cookie và hiển thị giỏ hàng của người dùng.

## Ví dụ về sử dụng cookie

- Cookie có thể được sử dụng với thư viện http trong NodeJS bằng cách sử dụng hàm `res.cookie()`. Hàm này có hai tham số: tên cookie và giá trị của cookie.

  ```js
  res.cookie("name", "F8");
  ```

  ***

- Để tạo một cookie chúng ta có thể sử dụng `http`

  ```js
  const http = require("http");
  http
    .createServer((req, res) => {
      const cookie = req.headers?.cookie; // Lấy cookie từ header
      console.log(cookie);
      // Tạo một biến tên là name, giá trị của nó là F8
      const name = "F8";
      const maxAge = new Date(
        new Date().getTime() + 86409000 // 1 ngày
      ).toUTCString();
      // Gửi response về cho client
      res.setHeader("Content-Type", "text/plain; charset=utf-8");
      res.writeHead(200, {
        "Set-Cookie": `company=${name}; expires=${maxAge}; httpOnly;`,
      });
      res.end("Hello, world!");
    })
    .listen(3000);
  ```

  Trong ví dụ trên, chúng ta đã sử dụng module `http` để tạo một cookie. Cookie có tên là `company` và giá trị là `F8`.

  ***

- Để tạo và lưu một thông tin giỏ hàng trong cookie, chúng ta có thể làm như sau:

  ```js
  const http = require("http");

  http
    .createServer((req, res) => {
      const cookie = req.headers?.cookie; // Lấy cookie từ header
      let { cartData } = cookie;
      // Nếu chưa có cart thì khởi tạo cart, nếu có rồi thì thôi.
      if (!cartData) {
        cartData = [];
      }
      // Thêm một sản phẩm vào giỏ
      cartData.push({
        id: 1,
        name: "Product 1",
        quantity: 1,
      });
      // Gửi response về cho client
      res.setHeader("Content-Type", "text/plain; charset=utf-8");
      res.writeHead(200, { "Set-Cookie": `cart=${JSON.stringify(cartData)};` });
      res.end(`Có tất cả ${cartData.length} sản phẩm trong giỏ hàng!`);
    })
    .listen(3000);
  ```

  Trong ví dụ trên, chúng ta check xem có giỏ hàng chưa, nếu chưa có thì tạo ra một biến để lưu giá trị giỏ hàng, sau đó thêm 1 sản phẩm vào giỏ hàng và trả về cho client cookie, tổng số lượng sản phẩm trong giỏ.

---

## Lưu ý khi sử dụng Cookie

### Lợi ích của Cookie

Cookie có một số lợi ích, bao gồm:

- Trình duyệt sẽ tự động gửi cookie qua header đến server, không cần phải gửi thủ công.
- Cookie có thể được sử dụng để lưu trữ thông tin về người dùng, chẳng hạn như tên người dùng, mật khẩu, ngôn ngữ, v.v.
- Cookie có thể được sử dụng để theo dõi hoạt động của người dùng trên một trang web.
- Cookie có thể được sử dụng để cá nhân hóa trải nghiệm của người dùng.
- Cookie có thể được sử dụng để lưu trữ trạng thái của một trang web.

  ***

### Hạn chế của Cookie

Tuy nhiên, cookie cũng có một số hạn chế, bao gồm:

- Cookie có thể bị chặn bởi trình duyệt web.
- Cookie có thể bị đánh cắp bởi kẻ tấn công.
- Cookie có thể bị sử dụng để theo dõi người dùng mà không có sự đồng ý của họ.

  ***

### Lưu ý khi sử dụng Cookie

Khi sử dụng cookie, điều quan trọng là phải lưu ý một số vấn đề sau:

- Cookie có thể bị chặn bởi trình duyệt web. Nếu người dùng chặn cookie, họ có thể không thể sử dụng một số tính năng của trang web.
- Cookie có thể bị đánh cắp bởi kẻ tấn công. Nếu cookie bị đánh cắp, kẻ tấn công có thể truy cập thông tin cá nhân của người dùng.
- Cookie có thể được sử dụng để theo dõi người dùng mà không có sự đồng ý của họ. Điều này có thể là một vấn đề về quyền riêng tư.

  ***

### Sử dụng Cookie một cách an toàn

Để bảo vệ thông tin của người dùng, điều quan trọng là phải sử dụng cookie một cách an toàn. Dưới đây là một số mẹo về cách sử dụng cookie một cách an toàn:

- Sử dụng cookie chỉ khi cần thiết.
- Sử dụng cookie với mã hóa.
- Khắc phục bảo mật cho cookie.
- Tuân thủ luật bảo mật.

  ***

**Lưu ý**

- Chỉ lưu những dữ liệu cần thiết vào cookie

- Sử dụng cookie hợp lý để tránh làm chậm trang web

- Cookie nên được mã hóa để bảo vệ dữ liệu của người dùng.

- Cookie nên có thời hạn sử dụng để ngăn chặn người dùng truy cập dữ liệu cũ.

- Cookie nên được sử dụng một cách hợp lý để không xâm phạm quyền riêng tư của người dùng.

---

## Kết luận

Cookie là một công cụ mạnh mẽ có thể được sử dụng để lưu trữ thông tin trên máy tính của người dùng. Cookie có thể được sử dụng để theo dõi hoạt động của người dùng trên một trang web, để cá nhân hóa trải nghiệm của người dùng, và để lưu trữ trạng thái của một trang web. Tuy nhiên, điều quan trọng là phải sử dụng cookie một cách an toàn để bảo vệ thông tin của người dùng.
