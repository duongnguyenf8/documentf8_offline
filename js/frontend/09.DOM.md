<!--
# Tổng quan về DOM trong Javascript
# Hiểu đúng các thao tác với DOM
# Tìm hiểu các loại DOM
# 5 cách truy xuất tới Element (DOM Element)
# Các thao tác với DOM HTML
# Các thao tác với DOM CSS
# Các thao tác với class
# Các thao tác với DOM Navigation
# Các thao tác với DOM Nodes
# Làm việc với từ khóa this trong Event
# Event Object và các tình huống thực tế
# Tìm hiểu phương thức e.preventDefault() và e.stopPropagation()
# Thực hành xây dựng các bài tập từ cơ bản đến nâng cao
# Xây dựng ứng dụng TodoList
-->

## Tổng quan về DOM trong JavaScript

DOM là viết tắt của Document Object Model, là một chuẩn được định nghĩa bởi W3C để truy xuất và thao tác các thành phần của một trang web. DOM được xem như một cây phân cấp, trong đó có thể truy xuất tới các thành phần bên trong của nó.

DOM được chia thành 3 loại:

- Core DOM: cung cấp các đối tượng cơ bản để mô tả một tài liệu. (ví dụ: document, element, text, attribute, comment, etc.)
- HTML DOM: cung cấp các đối tượng để mô tả và thao tác với HTML document. (ví dụ: HTMLInputElement, HTMLBodyElement, HTMLAnchorElement, etc.)
- XML DOM: cung cấp các đối tượng để mô tả và thao tác với XML document. (ví dụ: XMLDocument, XMLNode, XMLNodeList, etc.)

DOM được truy cập và thao tác bằng JavaScript. JavaScript là một ngôn ngữ kịch bản được sử dụng để thêm tính tương tác cho các trang web.

DOM cung cấp một số phương thức để truy cập và thao tác các thành phần của một trang web, bao gồm:

- `getElementById()`: Truy xuất một phần tử theo ID của nó.

- `getElementsByTagName()`: Truy xuất một danh sách các phần tử theo tên thẻ của chúng.

- `querySelector()`: Truy xuất một phần tử duy nhất theo một selector CSS.

- `querySelectorAll()`: Truy xuất một danh sách các phần tử theo một selector CSS.

- `appendChild()`: Thêm một phần tử con vào một phần tử.

- `insertBefore()`: Thêm một phần tử con vào trước một phần tử khác.

- `removeChild()`: Xóa một phần tử con khỏi một phần tử.

- `setAttribute()`: Thiết lập thuộc tính của một phần tử.

- `getAttribute()`: Lấy giá trị của một thuộc tính của một phần tử.

- `textContent` Lấy văn bản của một phần tử.

- `innerHTML` Lấy code HTML của một phần tử.

- Và nhiều phương thức khác nữa...

---

DOM là một công cụ mạnh mẽ để truy cập và thao tác các thành phần của một trang web.
Bằng cách sử dụng JavaScript, chúng ta có thể thêm tính tương tác cho các trang web của mình và tạo ra các trải nghiệm người dùng phong phú hơn.

---

## Ví dụ về DOM

Thêm một thẻ `<button>` vào trang web:

<code-snippet>

```html
<button>Run Code</button>
<script>
  const btn = document.querySelector('button');
  let count = 1;
  btn.onclick = () => {
    count++;
    const btnCreate = document.createElement('button');
    btnCreate.innerHTML = 'Đây là nút thứ ' + count;
    btnCreate.onclick = () => {
      alert(btnCreate.innerText);
    };
    document.body.appendChild(btnCreate);
  };
</script>
```

</code-snippet>

Trong đoạn code này, chúng ta đã tạo một thẻ `<button>` mới và thêm nó vào trang web.

Chúng ta cũng đã thêm một sự kiện nhấp chuột vào nút, khiến thẻ `<button>` mới được thêm vào trang web mỗi khi nút được nhấp.

Đây là Core DOM, vì chúng ta đang tạo ra một phần tử mới và thêm nó vào trang web.

---

Thêm một sự kiện nhấp chuột vào một nút:

<code-snippet>

```html
<button>Run Code</button>
<script>
  const btn = document.querySelector('button');
  let count = 0;
  const p = document.createElement('p');
  btn.onclick = () => {
    count++;
    p.textContent = `Thẻ p được tạo bằng JavaScript! Đây là lần click thứ ${count}!`;
    document.body.appendChild(p);
  };
</script>
```

</code-snippet>

Trong đoạn code này, chúng ta đã tạo một sự kiện nhấp chuột vào một nút, khiến một thẻ `<p>` mới được thêm vào trang web mỗi khi nút được nhấp.

Đây là HTML DOM, vì chúng ta đang thêm một sự kiện vào một phần tử HTML.

---

Thêm một phần tử vào một tài liệu XML:

<code-snippet>

```html
<button>Run Code</button>
<iframe id="result-iframe" frameborder="0" width="100%" height="300"></iframe>
<script>
  const btn = document.querySelector('button');
  const iframe = document.getElementById('result-iframe');
  btn.onclick = () => {
    const xml = new DOMParser().parseFromString('<xml></xml>', 'text/xml');
    const html = xml.createElement('html');
    const body = xml.createElement('body');
    const style = xml.createElement('style');
    const bgcolor = prompt('Nhập màu nền: ', '#fad');
    const color = prompt('Nhập màu chữ: ', '#333');
    style.innerHTML = `
          body {
            font-family: system-ui;
            background-color: ${bgcolor};
            color: ${color};
          }
          `;
    body.innerHTML = 'Hello F8!';
    html.appendChild(style);
    html.appendChild(body);

    // Lấy tài liệu của iframe
    const iframeDocument = iframe.contentWindow.document;

    // Xóa nội dung hiện tại trong iframe
    iframeDocument.open();
    iframeDocument.write('');
    iframeDocument.close();

    // Thêm nội dung mới vào iframe
    iframeDocument.open();
    iframeDocument.write(html.outerHTML);
    iframeDocument.close();
  };
</script>
```

</code-snippet>

Trong đoạn code này, chúng ta đã tạo một tài liệu XML mới và thêm một phần tử `<html>` vào tài liệu đó.

Chúng ta cũng đã thêm một phần tử `<style>` và một phần tử `<body>` vào phần tử `<html>`.

Tiếp theo đó in ra màn hình một tài liệu HTML mới với màu nền và màu chữ do người dùng nhập vào.

Đây là XML DOM, vì chúng ta đang thêm một phần tử vào một tài liệu XML.

---

## Kết luận

DOM là một công cụ mạnh mẽ có thể được sử dụng để thêm tính tương tác cho các trang web của chúng ta. Bằng cách sử dụng JavaScript, chúng ta có thể truy cập và thao tác các thành phần của một trang web và tạo ra các trải nghiệm người dùng phong phú hơn.

---

## Hiểu đúng các thao tác với DOM

**Hình ảnh mô hình cây DOM**

[![DOM Tree](https://www.w3schools.com/js/pic_htmltree.gif)](https://www.w3schools.com/js/js_htmldom.asp)

---

## DOM HTML

DOM HTML là một tiêu chuẩn cho việc truy cập và thay đổi các phần tử của một tài liệu HTML bằng JavaScript. DOM là viết tắt của **Document Object Model**, một mô hình đối tượng và giao diện lập trình được trình duyệt tạo ra khi một trang web được tải. Với DOM, JavaScript có thể tạo ra HTML động bằng cách:

- Thay đổi nội dung, cấu trúc và kiểu của các phần tử HTML
- Thêm hoặc xóa các phần tử HTML
- Thay đổi các thuộc tính hoặc kiểu của các phần tử HTML
- Phản ứng với các sự kiện xảy ra trên các phần tử HTML
- Tạo ra các phần tử HTML mới

DOM là một tiêu chuẩn của W3C (World Wide Web Consortium), một tổ chức quốc tế đặt ra các quy ước cho web. DOM định nghĩa:

- Các thuộc tính và phương thức của mỗi đối tượng HTML
- Cách truy cập vào các đối tượng HTML từ JavaScript
- Cách thay đổi các đối tượng HTML từ JavaScript

Nói cách khác: DOM HTML là một tiêu chuẩn cho việc lấy, thay đổi, thêm hoặc xóa các phần tử HTML.

---

### Thay đổi nội dung, cấu trúc và kiểu của các phần tử HTML

JavaScript có thể thay đổi nội dung, cấu trúc và kiểu của các phần tử HTML bằng cách sử dụng các phương thức của đối tượng DOM. Ví dụ: phương thức `textContent` có thể được sử dụng để thay đổi nội dung văn bản của một phần tử, phương thức `innerHTML` có thể được sử dụng để thay đổi code HTML của một phần tử, và phương thức `style` có thể được sử dụng để thay đổi kiểu của một phần tử.

---

### Thêm hoặc xóa các phần tử HTML

JavaScript có thể thêm hoặc xóa các phần tử HTML bằng cách sử dụng phương thức `appendChild()` của đối tượng `document`. Ví dụ: đoạn code sau đây sẽ thêm một nút vào phần tử `body`:

```js
const button = document.createElement('button');
button.textContent = 'Click Me!';
document.body.appendChild(button);
```

Đoạn code sau đây sẽ xóa một nút khỏi phần tử `body`:

```js
const button = document.querySelector('.my-button');
document.body.removeChild(button);
```

---

### Thay đổi các thuộc tính hoặc kiểu của các phần tử HTML

JavaScript có thể thay đổi các thuộc tính hoặc kiểu của các phần tử HTML bằng cách sử dụng các phương thức của đối tượng DOM. Ví dụ: đoạn code sau đây sẽ thay đổi màu nền của một phần tử:

```js
const element = document.querySelector('.my-element');
element.style.backgroundColor = 'red';
```

---

### Phản ứng với các sự kiện xảy ra trên các phần tử HTML

JavaScript có thể phản ứng với các sự kiện xảy ra trên các phần tử HTML bằng cách sử dụng các phương thức của đối tượng DOM. Ví dụ: đoạn code sau đây sẽ thêm một trình xử lý sự kiện `click` cho một nút:

```js
const button = document.querySelector('.my-button');
button.addEventListener('click', () => {
  // Đoạn code xử lý sự kiện
});
```

---

### Tạo ra các phần tử HTML mới

JavaScript có thể tạo ra các phần tử HTML mới bằng cách sử dụng phương thức `createElement()` của đối tượng `document`. Ví dụ: đoạn code sau đây sẽ tạo ra một nút mới:

```js
const button = document.createElement('button');
button.textContent = 'Click Me!';
```

---

## Kết luận

DOM HTML là một công cụ mạnh mẽ có thể được sử dụng để tạo ra HTML động. Bằng cách sử dụng JavaScript, chúng ta có thể thay đổi nội dung, cấu trúc, kiểu, thuộc tính và sự kiện của các phần tử HTML.

---

<!-- ## Tìm hiểu các loại DOM -->

## Tìm hiểu các loại DOM

Trong Javascript cung cấp cho chúng ta tổng cộng 12 loại DOM thao tác với các thành phần của một trang web.

DOM (Document Object Model) là một giao diện lập trình cho các tài liệu web. Nó đại diện cho trang để các chương trình(**Scripts**) có thể thay đổi cấu trúc, kiểu và nội dung của tài liệu. DOM đại diện cho tài liệu dưới dạng các nút(**Nodes**) và đối tượng(**Object**). Do đó, các ngôn ngữ lập trình có thể tương tác với trang.

DOM cung cấp cho chúng ta các **Methods** là các hành động mà chúng ta có thể thực hiện (_trên các phần tử HTML_). Các thuộc tính DOM là các giá trị (_của các phần tử HTML_) mà chúng ta có thể thiết lập hoặc thay đổi. Giao diện lập trình DOM là các thuộc tính và phương thức của mỗi đối tượng.

---

## DOM Document

Đối tượng `document` trong JavaScript là một đại diện cho tài liệu HTML hiện tại được hiển thị trong cửa sổ trình duyệt. Nó cung cấp nhiều phương thức và thuộc tính để truy cập và cập nhật nội dung và cấu trúc của tài liệu.

Ví dụ:

<code-snippet>

```html
<button>Run Code</button>
<script>
  const btn = document.querySelector('button'); // Lấy phần tử button đầu tiên ở trong tài liệu HTML
  btn.onclick = () => {
    document.write('Hello World!'); // Thay thế nội dung của tài liệu HTML bằng chuỗi "Hello World!"
  };
</script>
```

</code-snippet>

Ở đoạn code trên, chúng ta đã sử dụng phương thức `write()` của đối tượng `document` để thay thế nội dung của tài liệu HTML bằng chuỗi "Hello World!".

Điều này có nghĩa là tất cả các phần tử HTML hiện tại sẽ bị xóa khỏi tài liệu và được thay thế bằng chuỗi "Hello World!".

---

## DOM Elements

DOM Elements là các phần tử HTML được đại diện bởi các đối tượng trong DOM. Các phần tử này có thể được truy cập và thao tác bằng JavaScript để thay đổi nội dung, kiểu và thuộc tính của chúng.

Ví dụ:

<code-snippet>

```html
<input type="text" id="input" />
<p>Hello: <span id="name"></span></p>
<script>
  const input = document.getElementById('input');
  const name = document.getElementById('name');
  input.oninput = () => {
    name.textContent = input.value.toUpperCase();
  };
</script>
```

</code-snippet>

Ở đoạn code trên, chúng ta đã sử dụng phương thức `getElementById()` của đối tượng `document` để lấy phần tử `<input>` và `<span>`. Chúng đều là các Element trong cây DOM.

Chúng ta cũng đã sử dụng thuộc tính `oninput` để đăng ký một hàm xử lý sự kiện cho sự kiện `input` của phần tử `<input>`. Sau đó, chúng ta đã sử dụng thuộc tính `textContent` để thay đổi nội dung của phần tử `<span>`.

---

## DOM HTML

DOM HTML là một mô hình đối tượng tiêu chuẩn và giao diện lập trình cho HTML. Nó xác định:

- Các phần tử HTML là các đối tượng
- Các thuộc tính của tất cả các phần tử HTML
- Các phương thức để truy cập tất cả các phần tử HTML
- Các sự kiện cho tất cả các phần tử HTML

Ví dụ:

<code-snippet>

```html
<button>Run Code</button>
<p>Hello earth!</p>
<script>
  const btn = document.querySelector('button');
  const p = document.querySelector('p');
  btn.onclick = () => {
    p.style.color = 'darkgreen';
    p.textContent = 'Hello world!';
  };
</script>
```

</code-snippet>

Trong ví dụ trên, chúng ta có một phần tử `<p>` và một `<button>`.
Khi người dùng nhấp vào nút, chúng ta sẽ thay đổi màu chữ và nội dung của phần tử `<p>`.

Với DOM HTML, chúng ta có thể truy cập và thay đổi tất cả các phần tử HTML bằng JavaScript.

---

## DOM Forms

Đối tượng `forms` trong DOM cho phép chúng ta truy cập vào các biểu mẫu trong một tài liệu HTML. Chúng ta có thể sử dụng nó để lấy thông tin từ biểu mẫu hoặc thay đổi giá trị của các trường nhập.

Ví dụ:

<code-snippet>

```html
<form>
  <input type="email" id="email" placeholder="email" />
  <input type="password" id="password" placeholder="password" />
  <button>Submit</button>
</form>

<script>
  const $ = (selector) => document.querySelector(selector);
  const trim = (str) => str.trim();
  const email = $('#email'),
    password = $('#password');
  $('form').onsubmit = (e) => {
    e.preventDefault();
    const emailValue = trim(email.value),
      passwordValue = trim(password.value);
    if (emailValue === '' || passwordValue === '') {
      alert('Email hoặc Password không được để trống!');
      emailValue === '' ? email.focus() : password.focus();
      return;
    }
    const data = `Email: ${email.value}\nPassword: ${password.value}`;
    document.body.appendChild(document.createElement('pre')).innerHTML = data;
  };
</script>
```

</code-snippet>

Trong ví dụ trên, chúng ta có một biểu mẫu với hai trường nhập và một nút gửi. Khi người dùng nhấp vào nút, chúng ta sẽ lấy giá trị của các trường nhập và hiển thị chúng trong một phần tử `<pre>`.

Với DOM Forms, chúng ta có thể truy cập và thay đổi các biểu mẫu HTML bằng JavaScript.

---

## DOM CSS

DOM CSS cho phép JavaScript thay đổi kiểu của các phần tử HTML. Chúng ta có thể sử dụng nó để thêm, xóa hoặc sửa đổi thuộc tính CSS của một phần tử.

Ví dụ:

<code-snippet>

```html
<button>Run Code</button>
<script>
  const btn = document.querySelector('button');
  const randomColor = (type) => {
    const r = Math.floor(Math.random() * 128 + (type === 'light' && 128));
    const g = Math.floor(Math.random() * 128 + (type === 'light' && 128));
    const b = Math.floor(Math.random() * 128 + (type === 'light' && 128));
    return `rgb(${r}, ${g}, ${b})`;
  };
  btn.onclick = () => {
    btn.style.backgroundColor = randomColor('light');
    btn.style.color = randomColor();
  };
</script>
```

</code-snippet>

Trong ví dụ trên, chúng ta có một phần tử `<button>`. Khi người dùng nhấp vào nút, chúng ta sẽ thay đổi màu nền và màu chữ của nó.

Với type là "light", chúng ta sẽ tạo ra một màu sáng. Nếu không chúng ta sẽ tạo ra một màu tối.

Với DOM CSS, chúng ta có thể thay đổi kiểu của các phần tử HTML bằng JavaScript.

---

## DOM Animations

DOM Animations cho phép chúng ta tạo ra các hoạt ảnh bằng JavaScript bằng cách điều chỉnh các thuộc tính của phần tử theo thời gian. Chúng ta có thể sử dụng API Web Animations hoặc sử dụng `setInterval` hoặc `requestAnimationFrame` để điều khiển quá trình hoạt ảnh.

Ví dụ:

<code-snippet>

```html
<button>Run Code</button>
<p class="dice"></p>
<p class="dice"></p>
<p class="dice"></p>
<script>
  const btn = document.querySelector('button');
  const dice = document.querySelectorAll('.dice');
  const sides = ['Một', 'Hai', 'Ba', 'Bốn', 'Năm', 'Sáu'];
  const roll = () => {
    const random = Math.floor(Math.random() * sides.length);
    return sides[random];
  };
  btn.onclick = () => {
    const start = performance.now();
    const duration = 1500;
    const interval = setInterval(() => {
      const timePassed = performance.now() - start;
      if (timePassed >= duration) {
        clearInterval(interval);
        return;
      }
      dice.forEach((die) => {
        die.className = 'dice';
        die.innerText = roll();
      });
    }, 100); // Cách 1: Sử dụng setInterval
    /*
    let previousTime = 0,
        startTime = performance.now(),
        stop = false;
      const duration = 100,
        timeout = 1500;
      const update = (currentTime) => {
        if (currentTime - previousTime >= duration && !stop) {
          dice.forEach((die) => {
            die.className = "dice";
            die.innerText = roll();
          });
          previousTime = currentTime;
        }
        if (currentTime - startTime <= timeout) requestAnimationFrame(update);
        else stop = true;
      };
      requestAnimationFrame(update);
    }; // Cách 2: Sử dụng requestAnimationFrame
    */
  };
</script>
```

</code-snippet>

Trong ví dụ trên, chúng ta có một nút và ba phần tử `<p>` với một lớp `dice`. Khi người dùng nhấp vào nút, chúng ta sẽ thay đổi nội dung của các phần tử `<p>` để tạo ra một hoạt ảnh tung xúc xắc.

Với DOM Animations, chúng ta có thể tạo ra các hoạt ảnh bằng JavaScript bằng cách điều chỉnh các thuộc tính của phần tử theo thời gian.

Vậy 2 cách khác gì nhau và performance của chúng như thế nào?

| Đặc điểm     | `setInterval`                                                      | `requestAnimationFrame`                                               |
| ------------ | ------------------------------------------------------------------ | --------------------------------------------------------------------- |
| Khi gọi      | Được gọi ngay lập tức và sau đó sau mỗi khoảng thời gian nhất định | Được gọi ngay trước khi khung tiếp theo được vẽ                       |
| Số lần gọi   | Được gọi nhiều lần                                                 | Được gọi tối đa một lần mỗi khung                                     |
| Độ chính xác | Không chính xác                                                    | Chính xác cao                                                         |
| Hiệu suất    | Không hiệu quả                                                     | Hiệu quả cao                                                          |
| Sử dụng      | Thích hợp cho các tác vụ lặp lại không cần độ chính xác cao        | Thích hợp cho các tác vụ cần độ chính xác cao, chẳng hạn như hoạt ảnh |

Về hiệu suất, `requestAnimationFrame()` là hiệu quả hơn `setInterval()`. Điều này là do `requestAnimationFrame()` chỉ được kích hoạt trước khi kết thúc khung tiếp theo, trong khi `setInterval()` được kích hoạt theo chu kỳ, với khoảng thời gian cố định. Điều này có nghĩa là `requestAnimationFrame()` không lãng phí tài nguyên bằng cách chạy khi không cần thiết.

Về sử dụng, `setInterval()` thích hợp cho các tác vụ lặp lại, chẳng hạn như cập nhật trạng thái hoặc phát nhạc. Điều này là do `setInterval()` có thể được sử dụng để chạy một hàm với một khoảng thời gian cố định. `requestAnimationFrame()`, mặt khác, thích hợp cho các tác vụ cần được thực hiện trước khi kết thúc khung tiếp theo, chẳng hạn như hoạt ảnh. Điều này là do `requestAnimationFrame()` được đảm bảo chạy trước khi kết thúc khung tiếp theo, điều này là cần thiết cho hoạt ảnh để hoạt động chính xác.

Với `setInterval` thích hợp để:

- Tạo một đồng hồ đếm ngược
- Chạy một lặp vô hạn
- Phát nhạc

Với `requestAnimationFrame` thích hợp để:

- Tạo một hoạt ảnh
- Thay đổi kích thước hoặc vị trí của một phần tử
- Vẽ nội dung lên màn hình

Nhìn chung, `requestAnimationFrame()` là sự lựa chọn tốt hơn cho các hoạt động nhạy cảm với thời gian. Nó hiệu quả hơn và ít có khả năng gây giật hơn `setInterval()`.

## DOM Events

DOM Events cho phép JavaScript phản ứng với các sự kiện xảy ra trong tài liệu, chẳng hạn như khi người dùng nhấp vào một nút hoặc khi một trang được tải xong. Chúng ta có thể sử dụng `addEventListener` để đăng ký một hàm xử lý sự kiện cho một sự kiện cụ thể.

Ví dụ:

<code-snippet>

```html
<div class="todo"></div>
<button id="btn">Run code</button>
<script>
  const todo = document.querySelector('.todo');
  const btn = document.querySelector('#btn');
  const rand = () => Math.floor(Math.random() * 100);
  const getTodo = async () => {
    const response = await fetch(
      `https://jsonplaceholder.typicode.com/todos/${rand()}`
    );
    const data = await response.json();
    todo.innerHTML = `
      <h1>${data.title}</h1>
      <p>${data.completed ? 'Đã hoàn thành' : 'Chưa hoàn thành'}</p>
    `;
  };
  document.addEventListener('DOMContentLoaded', () => {
    getTodo();
  });
  btn.addEventListener('click', () => {
    getTodo();
  });
</script>
```

</code-snippet>

Trong ví dụ trên, chúng ta có một phần tử `<div>` với một lớp `todo`. Khi **trang được tải xong**, chúng ta sẽ lấy một công việc ngẫu nhiên từ API JSONPlaceholder và hiển thị nó trong phần tử `<div>`.

Với DOM Events, chúng ta có thể phản ứng với các sự kiện xảy ra trong tài liệu, chẳng hạn như khi người dùng nhấp vào một nút hoặc khi một trang được tải xong.

---

## DOM EventListener

Phương thức `addEventListener()` trong JavaScript, cho phép gắn một hàm xử lý sự kiện cho một phần tử HTML nào đó.

Phương thức `addEventListener()` có nhiều ưu điểm, như không ghi đè các hàm xử lý sự kiện đã có, có thể gắn nhiều hàm xử lý sự kiện cùng loại hoặc khác loại cho một phần tử, có thể gắn hàm xử lý sự kiện cho bất kỳ đối tượng DOM nào, không chỉ là phần tử HTML, và có thể kiểm soát cách thức lan truyền của sự kiện.

Phương thức `addEventListener()` có ba tham số: loại sự kiện (ví dụ `“click”` hoặc `“mousedown”`), hàm xử lý sự kiện, và một giá trị boolean chỉ định sử dụng lan truyền nổi hay lan truyền chụp.

- Tham số thứ ba là tùy chọn, mặc định là `false` (lan truyền nổi). [Xem thêm](https://www.w3schools.com/js/js_htmldom_eventlistener.asp)

Phương thức `removeEventListener()` dùng để gỡ bỏ các hàm xử lý sự kiện đã được gắn bằng phương thức `addEventListener()`.

Ví dụ:

<code-snippet>

```html
<button id="btn">Run code</button>
<script>
  document.getElementById('btn').addEventListener('click', function () {
    alert('Hello World!');
  });
</script>
```

</code-snippet>

### Phân biệt EventListener và Events

Event Listener khác dom Events ở chỗ Event Listener là một phương thức cho phép gắn các hàm xử lý sự kiện cho các đối tượng DOM, còn dom Events là các sự kiện được sinh ra khi người dùng tương tác với các đối tượng DOM. Ví dụ, khi người dùng nhấn vào một nút, sẽ sinh ra một dom Event là “click”, và ta có thể gắn một Event Listener để xử lý sự kiện này.

---

## DOM Navigation

DOM Navigation cho phép chúng ta điều hướng qua cây DOM bằng cách sử dụng các quan hệ giữa các nút. Chúng ta có thể sử dụng các thuộc tính như `parentNode`, `firstChild`, `lastChild`, `nextSibling` và `previousSibling` để di chuyển lên, xuống và ngang qua cây DOM.

Ví dụ:

<code-snippet>

```html
<div class="container">
  <button>Run code</button>
  <span class="paragraph">Hello</span>
</div>

<script>
  const paragraph = document.querySelector('.paragraph');
  const container = paragraph.parentNode; // Tác động vào thẻ cha từ thẻ con
  const button = paragraph.previousElementSibling; // Tác động vào thẻ đằng trước
  const span = document.createElement('span');
  span.innerText = 'F8';
  container.appendChild(span);
  button.addEventListener('click', () => {
    const span = document.createElement('span');
    container.style.backgroundColor = '#ffaadd80';
    span.innerHTML = '8';
    container.appendChild(span);
  });
</script>
```

</code-snippet>

---

## DOM Nodes

Một Node trong DOM là một đối tượng đại diện cho một phần của tài liệu. Có nhiều loại nút khác nhau, bao gồm các nút phần tử, nút văn bản và nút thuộc tính. Mỗi nút có các thuộc tính và phương thức riêng để truy cập và thao tác với nó.

Ví dụ:

<code-snippet>

```html
<form id="form">
  <input placeholder="Enter your name!" id="input" />
  <button>Click me</button>
</form>
<script>
  const form = document.getElementById('form');
  form.addEventListener('submit', (e) => {
    const inputVal = document.getElementById('input').value;
    alert('Hello ' + inputVal);
  });
</script>
```

</code-snippet>

---

## DOM Collections

Một DOM Collection là một danh sách (tập hợp) các đối tượng DOM được trích xuất từ một tài liệu. Có hai loại DOM Collection chính là HTMLCollection và NodeList. Các phần tử trong một DOM Collection có thể được truy cập bằng chỉ số.

Cập nhật động: HTMLCollection là một đối tượng cập nhật động, nghĩa là nó sẽ tự động cập nhật khi có sự thay đổi trong DOM.

Nguồn gốc: HTMLCollection được trả về từ các phương thức như `document.getElementsByClassName` hoặc `document.getElementsByTagName`...

Ví dụ:

<code-snippet>

```html
<p>Hello</p>
<p>Hello</p>
<p>Hello</p>
<p>Hello</p>
<p>Hello</p>
<script>
  const pTag = document.getElementsByTagName('p');
  for (let i = 0; i <= pTag.length; i++) {
    pTag[i].innerHTML = 'Hello' + i + '!';
  }
</script>
```

</code-snippet>

---

## DOM Node Lists

Một NodeList là một danh sách (tập hợp) các nút được trích xuất từ một tài liệu. Một NodeList giống như một HTMLCollection, nhưng có thêm một số phương thức khác nhau. Các phần tử trong một NodeList có thể được truy cập bằng chỉ số.

NodeList không phải là một đối tượng cập nhật động, nó chỉ chứa các phần tử DOM tại thời điểm nó được tạo ra.

Phương thức: HTMLCollection có ít phương thức hơn so với NodeList. Ví dụ, NodeList có phương thức `forEach` để duyệt qua các phần tử, trong khi HTMLCollection không có.

NodeList được trả về từ các phương thức như `document.querySelectorAll`, `document.querySelector`...

Ví dụ:

<code-snippet>

```html
<p>Hello</p>
<p>Hello</p>
<p>Hello</p>
<p>Hello</p>
<p>Hello</p>
<script>
  const pTag = document.querySelectorAll('p');
  pTag.forEach((tag, i) => {
    tag.innerHTML = 'Hello' + i;
  });
</script>
```

</code-snippet>

---

## Kết luận

Tuy nhiều là vậy, nhưng hầu hết chúng ta sẽ làm việc với 4 loại Node trong DOM thường được chú ý và dùng nhiều nhất, cùng với cách lấy chúng trong JavaScript:

1. `document`: Đối tượng gốc của một cây tài liệu. Chúng ta có thể truy cập đối tượng `document` trực tiếp trong JavaScript.

2. `element`: Các phần tử trong một tài liệu HTML hoặc XML. Chúng ta có thể sử dụng các phương thức như `document.getElementById()`, `document.getElementsByTagName()`, `document.getElementsByClassName()`, hoặc `document.querySelector()` để lấy các phần tử trong tài liệu.
3. `text`: Nội dung văn bản của một phần tử hoặc thuộc tính. Chúng ta có thể truy cập nội dung văn bản của một phần tử bằng cách sử dụng thuộc tính `textContent` hoặc `innerText` của phần tử đó.

4. `attribute`: Một thuộc tính của một phần tử. Chúng ta có thể truy cập các thuộc tính của một phần tử bằng cách sử dụng phương thức `getAttribute()` hoặc truy cập trực tiếp các thuộc tính thông qua đối tượng phần tử.

---

<!-- 5 cách truy xuất tới Element (DOM Element)  -->

## 1. Truy xuất bằng ID

Chúng ta có thể sử dụng phương thức `getElementById()` để truy xuất tới một Element có ID cụ thể. Phương thức này trả về một Element, hoặc null nếu không tìm thấy Element nào có ID đó.

```javascript
var inputTag = document.getElementById('inputId');
```

---

## 2. Truy xuất bằng className

Chúng ta có thể sử dụng phương thức `getElementsByClassName()` để truy xuất tới một mảng các Element có cùng className. Phương thức này trả về một HTMLCollection, có thể chứa nhiều Element hoặc không chứa Element nào.

```javascript
var paragraphList = document.getElementsByClassName('text');
```

---

## 3. Truy xuất bằng tagName

Chúng ta có thể sử dụng phương thức `getElementsByTagName()` để truy xuất tới một mảng các Element có cùng tagName. Phương thức này trả về một HTMLCollection, có thể chứa nhiều Element hoặc không chứa Element nào.

```javascript
var titleTag = document.getElementsByTagName('h1');
```

---

## 4. Truy xuất 1 phần tử bằng CSS query

Chúng ta có thể sử dụng CSS selector để truy xuất tới một Element. CSS selector là một chuỗi ký tự mô tả các thuộc tính của Element cần truy xuất.

Để truy xuất tới một Element đầu tiên, chúng ta có thể sử dụng phương thức `querySelector()`. Phương thức này trả về một Element, hoặc null nếu không tìm thấy Element nào phù hợp với CSS selector.

```javascript
var btnSubmit = document.querySelector('form button[type=submit]');
```

---

## 5. Truy xuất nhiều phần tử bằng CSS query

Chúng ta có thể sử dụng CSS selector để truy xuất tới nhiều Element hoặc một mảng các Element. CSS selector là một chuỗi ký tự mô tả các thuộc tính của Element cần truy xuất.

Để truy xuất tới tất cả các Element phù hợp với CSS selector, chúng ta có thể sử dụng phương thức `querySelectorAll()`. Phương thức này trả về một NodeList, có thể chứa nhiều Element hoặc không chứa Element nào.

```javascript
var inputPassword = document.querySelectorAll('form input.password');
```

---

## So sánh các cách truy xuất

| Cách truy xuất             | Đặc điểm                                                                               |
| -------------------------- | -------------------------------------------------------------------------------------- |
| `getElementById()`         | Trả về một Element, hoặc null nếu không tìm thấy Element nào có ID đó.                 |
| `getElementsByClassName()` | Trả về một HTMLCollection, có thể chứa nhiều Element hoặc không chứa Element nào.      |
| `getElementsByTagName()`   | Trả về một HTMLCollection, có thể chứa nhiều Element hoặc không chứa Element nào.      |
| `querySelector()`          | Trả về một Element, hoặc null nếu không tìm thấy Element nào phù hợp với CSS selector. |
| `querySelectorAll()`       | Trả về một NodeList, có thể chứa nhiều Element hoặc không chứa Element nào.            |

---

### Phân biệt HTMLCollection và NodeList

HTMLCollection và NodeList là hai loại đối tượng khác nhau trong JavaScript, được sử dụng để lưu trữ một tập hợp các phần tử DOM:

| Đặc điểm      | HTMLCollection                                                                                     | NodeList                                                                                  |
| ------------- | -------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| Định nghĩa    | HTMLCollection là một tập hợp các phần tử DOM được sắp xếp theo thứ tự xuất hiện trong tài liệu.   | NodeList là một tập hợp các nút (node) trong tài liệu, bao gồm cả phần tử và nút văn bản. |
| Cách truy cập | Có thể truy cập các phần tử trong HTMLCollection bằng cách sử dụng chỉ số hoặc **id của phần tử**. | Có thể truy cập các nút trong NodeList bằng cách sử dụng chỉ số.                          |
| Tính động     | HTMLCollection là động, nghĩa là nó sẽ tự động cập nhật khi có sự thay đổi trong tài liệu.         | NodeList có thể là động hoặc tĩnh, tùy thuộc vào cách nó được tạo ra.                     |
| Phương thức   | HTMLCollection không có phương thức riêng.                                                         | NodeList có một số phương thức riêng, chẳng hạn như forEach().                            |

---

<!-- Các thao tác với DOM HTML -->

DOM HTML cung cấp cho chúng ta một số thuộc tính và phương thức để thao tác với các phần tử HTML trong trang web.

## Thuộc tính

Dưới đây là một số thuộc tính hay sử dụng trong DOM HTML:

`id`: Thuộc tính này xác định ID của một phần tử.

`class`: Thuộc tính này xác định lớp của một phần tử.

`name`: Thuộc tính này xác định tên của một phần tử, có thể sử dụng như một key của đối tượng form.

`value`: Thuộc tính này xác định giá trị của một phần tử nhập liệu.

Với các thuộc tính có thật của thẻ HTML đó, có thể sử dụng chúng như một key trong đối tượng HTML.

<code-snippet>

```html
<h3 class="title" name="haha">hello F8</h3>

<script>
  const title = document.querySelector('.title');

  console.log(title.name);
  console.log(title.className);
</script>
```

</code-snippet>

---

## Phương thức

Dưới đây là một số phương thức hay sử dụng trong DOM HTML:

DOM (Document Object Model) là một chuẩn được định nghĩa bởi W3C (Tổ Chức Web Toàn Cầu – World Wide Web Consortium) để truy xuất và thao tác trên các tài liệu có cấu trúc dạng HTML hay XML bằng các ngôn ngữ lập trình thông dụng như Javascript, PHP... Các phương thức DOM là các hành động mà chúng ta có thể thực hiện trên các đối tượng (phần tử) của DOM. Các phương thức DOM bao gồm chọn một phần tử, tạo một phần tử mới, thay đổi nội dung của phần tử, thay đổi CSS, xóa phần tử... Một số phương thức hay sử dụng trong DOM HTML bao gồm:

- `getElementById()`: Chọn phần tử duy nhất với id đã cho. Trường hợp có 2 id giống nhau thì nó chọn phần tử đầu tiên.
- `getElementsByClassName()`: Chọn các phần tử của HTML Collection với className đã cho.
- `getElementsByTagName()`: Chọn các phần tử HTML Collection với tên thẻ đã cho.
- `querySelector()`: Chọn phần tử đầu tiên của CSS Selector.
- `querySelectorAll()`: Chọn danh sách các phần tử của CSS Selector.
- `createElement()`: Tạo ra một thẻ HTML mới.
- `removeChild(node)`: Loại bỏ một phần tử HTML.
- `setAttribute(name,value)`: Đặt lại hoặc thêm mới một thuộc tính cho thẻ.
- `remove()`: Xóa phần tử khỏi cây DOM.

---

## Lấy giá trị

Chúng ta có thể lấy giá trị của một phần tử bằng cách sử dụng thuộc tính `value`, `innerText`...

Ví dụ, để lấy giá trị của một input text, chúng ta có thể sử dụng `value`:

```javascript
const input = document.querySelector("input[type='text']");
const value = input.value;
```

Ví dụ, để lấy giá trị của một thẻ HTML, chúng ta có thể sử dụng `innerText`:

```javascript
const title = document.querySelector('h1.title');
const value = title.innerText;
```

---

## Cập nhật giá trị

Chúng ta có thể cập nhật giá trị của một phần tử bằng cách sử dụng phương thức `value`, `innerText`...

Ví dụ, để cập nhật giá trị của một input text, chúng ta có thể sử dụng `value`:

```javascript
const input = document.querySelector("input[type='text']");
input.value = 'New value';
```

Ví dụ, để cập nhật giá trị của một thẻ HTML, chúng ta có thể sử dụng `innerText`:

```javascript
const title = document.querySelector('h1.title');
title.innerText = 'New value';
```

---

## Xóa phần tử khỏi cây DOM

Chúng ta có thể xóa một phần tử khỏi cây DOM bằng cách sử dụng phương thức `remove()`.

Ví dụ, để xóa một div element, chúng ta có thể sử dụng `remove()` sau:

```javascript
const div = document.querySelector('div');
div.remove();
```

---

### innerHTML, innerText, outerHTML, outerText, textContent

Các thuộc tính và phương thức này được sử dụng để thao tác với nội dung của một phần tử HTML.

| Thuộc tính    | Mô tả                                                                                                                                                                                        |
| ------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `innerHTML`   | Trả về nội dung HTML bên trong một phần tử.                                                                                                                                                  |
| `innerText`   | Trả về nội dung văn bản của một phần tử và các phần tử con của nó, không bao gồm các thẻ HTML. Nó không trả về nội dung của các phần tử ẩn.                                                  |
| `outerHTML`   | Trả về code HTML đại diện cho phần tử và nội dung của nó.                                                                                                                                    |
| `outerText`   | Trả về cùng giá trị như `innerText`. Khi được sử dụng như một setter, nó thay thế toàn bộ node hiện tại bằng văn bản đã cho (khác với innerText, thay thế nội dung bên trong node hiện tại). |
| `textContent` | Trả về nội dung văn bản của một phần tử và các phần tử con của nó, không bao gồm các thẻ HTML. Nó trả về nội dung của tất cả các phần tử, kể cả `<script>` và `<style>`.                     |

---

**Chú ý:**

- `innerHTML`: Khi sử dụng thuộc tính này để thay đổi nội dung HTML của một phần tử, chúng ta cần lưu ý rằng nó có thể ảnh hưởng đến các sự kiện và thuộc tính của các phần tử con. Ngoài ra, việc sử dụng `innerHTML` để chèn nội dung không an toàn có thể dẫn đến các vấn đề bảo mật như tấn công XSS.
- `innerText`: Thuộc tính này chỉ trả về nội dung văn bản của các phần tử được hiển thị và bỏ qua các phần tử ẩn. Do đó, nếu chúng ta muốn lấy toàn bộ nội dung văn bản của một phần tử, kể cả các phần tử ẩn, chúng ta nên sử dụng thuộc tính `textContent`.
- `outerHTML`: Khi sử dụng thuộc tính này để thay đổi code HTML đại diện cho một phần tử, chúng ta cần lưu ý rằng nó sẽ thay thế toàn bộ phần tử hiện tại và các phần tử con của nó.
- `outerText`: Khi được sử dụng như một setter, thuộc tính này sẽ thay thế toàn bộ node hiện tại bằng văn bản đã cho (khác với innerText, thay thế nội dung bên trong node hiện tại).
- `textContent`: Thuộc tính này trả về nội dung văn bản của tất cả các phần tử con, kể cả `<script>` và `<style>`. Do đó, khi sử dụng thuộc tính này để lấy nội dung văn bản của một phần tử, chúng ta cần lọc ra các phần tử không mong muốn.

<!-- Các thao tác với DOM CSS -->

## DOM CSS là gì?

DOM CSS cung cấp cho chúng ta một số phương thức để thao tác với các thuộc tính CSS của các phần tử HTML trong trang web. Điều này cho phép chúng ta thay đổi động các thuộc tính CSS của các phần tử HTML, giúp tạo ra các hiệu ứng động và tương tác với người dùng một cách linh hoạt hơn.

Ngoài ra, chúng ta cũng có thể sử dụng các sự kiện DOM để thực hiện các thao tác với CSS khi có sự kiện xảy ra, ví dụ như khi người dùng nhấn chuột vào một nút hoặc di chuột qua một phần tử HTML. Điều này giúp tăng tính tương tác và trải nghiệm người dùng trên trang web.

DOM CSS có thể tác động đến tất cả các thuộc tính CSS của các phần tử HTML, bao gồm:

- Màu sắc
- Phông chữ
- Kích thước
- Vị trí
- ...

Style là một đối tượng vì nó lưu trữ tất cả các thuộc tính CSS của một phần tử HTML. Đồng thời, nó cũng là thuộc tính của thẻ HTML. Vì vậy chúng ta có 2 cách viết style trong Javascript:

---

## Cách sử dụng DOM CSS

Cách 1: Sử dụng style như một thuộc tính của thẻ HTML

```javascript
var title = document.querySelector('h1');
title.style =
  'background-color: red; color: black; border: 1px solid black; padding: 10px;';
```

Tuy nhiên cách này không được sử dụng nhiều vì độ phức tạp khi viết 1 chuỗi dài, chưa kể nếu chúng ta viết một style nữa ở dưới thì sẽ ghi đè tất cả style ở trên.

---

Cách 2.1: Sử dụng riêng lẻ các thuộc tính trong đối tượng style

```javascript
var title = document.querySelector('h1');
title.style.backgroundColor = 'red';
title.style.color = 'black';
title.style.border = '1px solid black';
title.style.padding = '10px';
```

---

Cách này tốt hơn cách trước khi chúng ta chỉ thay đổi riêng lẻ từng thuộc tính. Tuy nhiên với việc viết như này chỉ thích hợp với ít thuộc tính. Nếu nhiều hơn thì chúng ta nên lựa chọn:

Cách 2.2: Sử dụng `Object.assign`

```javascript
var title = document.querySelector('h1');
var titleStyle = {
  backgroundColor: 'green',
  color: '#faa300',
  border: '1px solid black',
  padding: '10px',
};

Object.assign(title.style, titleStyle);
```

Với cách này, các đoạn code style được gom nhóm một cách dễ hiểu và được copy vào đối tượng style của title với `Object.assign`.

Để sử dụng DOM CSS, chúng ta cần truy cập vào thuộc tính `style` của một phần tử HTML. Thuộc tính này là một đối tượng chứa tất cả các thuộc tính CSS của phần tử đó.

Sau đó, chúng ta có thể sử dụng các phương thức của đối tượng `style` để thay đổi các thuộc tính CSS của phần tử.

---

## Lưu ý khi sử dụng DOM CSS

Sau khi sử dụng DOM CSS, các thuộc tính CSS của phần tử sẽ được chuyển sang inline style. Inline style là các thuộc tính CSS được đặt trực tiếp trong phần tử HTML. Vì vậy, chúng sẽ ghi đè các style có độ ưu tiên thấp hơn tại code css.

DOM CSS thích hợp cho CSS động và ít thuộc tính. CSS động là CSS được thay đổi theo thời gian. CSS ít thuộc tính là CSS chỉ bao gồm một vài thuộc tính.

---

### Ví dụ

- **Link**: http://42.96.41.29:880/demo-dom-css

Ở ví dụ này, chúng ta thấy một thanh timeline chạy ở đáy mỗi thông báo, mỗi thông báo chạy ở một position nhất định và di chuyển về hướng ngược lại mỗi khi hết thời gian sau đó được xóa khỏi cây DOM bằng hàm `remove()`. Nhưng liệu những thành phần như này có phải CSS động, và có cần thiết phải sử dụng tới các thuộc tính như `transition`, `translate`, `opacity`,... trong đối tượng style không?

Không cần thiết, chúng ta có thể sử dụng và nên sử dụng animation CSS trong trường hợp này, điều đó sẽ khiến đoạn code dễ viết hơn, chạy tốt hơn, mượt mà hơn khi không phải thay đổi thuộc tính translate, opacity liên tục trong inline CSS.

---

## Kết luận

DOM CSS thực sự là một công cụ hữu ích trong Javascript để chúng ta can thiệp vào inline CSS nhằm thay đổi thuộc tính của một phần tử theo điều kiện, tuy nhiên không nên quá lạm dụng chúng trong các mục đích không cần thiết tránh làm code trở nên khó hơn.

Một số phương thức DOM CSS thường dùng

- `style.backgroundColor`: Thay đổi màu nền của một phần tử.
- `style.color`: Thay đổi màu chữ của một phần tử.
- `style.width`: Thay đổi chiều rộng của một phần tử.
- `style.height`: Thay đổi chiều cao của một phần tử.
- `style.position`: Thay đổi vị trí của một phần tử.

Ngoài ra, DOM CSS còn cung cấp một số phương thức khác để thao tác với các thuộc tính CSS của các phần tử HTML.

<!-- Các thao tác với class -->

## Thao tác với className là gì?

Class là một thuộc tính của phần tử HTML dùng để xác định các kiểu hoặc trạng thái của phần tử đó.

Bằng cách này, thay vì phải cập nhật nhiều thuộc tính CSS thì chúng ta có thể thêm 1 class với vai trò tương tự nhưng code sẽ ngắn gọn, đẹp hơn và làm được nhiều tác vụ hơn.

### className và classList

- `className`: Thuộc tính này trả về một chuỗi chứa tất cả các class của phần tử, được nối với nhau bằng dấu cách.
- `classList`: Thuộc tính này trả về một đối tượng NodeList chứa tất cả các class của phần tử.

## Thao tác thêm class

Để thêm class cho một phần tử HTML, chúng ta có thể sử dụng phương thức `classList.add()`. Phương thức này có thể nhận một hoặc nhiều class làm tham số.

Ví dụ, để thêm class `title` cho h1 element, chúng ta có thể sử dụng code sau:

<code-snippet>

```html
<style>
  .title {
    color: #fad300;
    background: #333;
  }
</style>
<h1>Hello F8</h1>
<button>Run code</button>
<script>
  var h1 = document.querySelector('h1');
  var btn = document.querySelector('button');
  btn.onclick = function () {
    h1.classList.add('title');
  };
</script>
```

</code-snippet>

Ngoài ra, với các class chỉ sử dụng 1 lần nhằm thể hiện 1 chức năng nổi bật hơn, chúng ta có thể sử dụng `classList.toggle()`

<code-snippet>

```html
<style>
  .title {
    color: #fad300;
    background: #333;
  }
</style>
<h1>Hello F8</h1>
<button>Run code</button>
<script>
  var h1 = document.querySelector('h1');
  var btn = document.querySelector('button');
  btn.onclick = function () {
    h1.classList.toggle('title');
  };
</script>
```

</code-snippet>

## Thao tác sửa class

Để sửa class cho một phần tử HTML, chúng ta có thể sử dụng phương thức `classList.replace()`. Phương thức này có thể nhận hai tham số: class cũ và class mới.

Ví dụ, để sửa class `main` thành `title` cho h1 element, chúng ta có thể sử dụng code sau:

<code-snippet>

```html
<style>
  .title {
    color: #fad300;
    background: #333;
  }
</style>
<h1 class="main">Hello F8</h1>
<button>Run code</button>
<script>
  var h1 = document.querySelector('h1');
  var btn = document.querySelector('button');
  btn.onclick = function () {
    h1.classList.replace('main', 'title');
  };
</script>
```

</code-snippet>

## Thao tác xóa class

Để xóa class cho một phần tử HTML, chúng ta có thể sử dụng phương thức `classList.remove()`. Phương thức này có thể nhận một hoặc nhiều class làm tham số.

Ví dụ, để xóa class `active` cho h1 element, chúng ta có thể sử dụng code sau:

<code-snippet>

```html
<style>
  .title {
    color: #fad300;
    background: #333;
  }
  .title.active {
    color: #333;
    background: #fad300;
  }
</style>
<h1 class="title active">Hello F8</h1>
<button>Run code</button>
<script>
  var h1 = document.querySelector('.title');
  var btn = document.querySelector('button');
  btn.onclick = function () {
    h1.classList.remove('active');
  };
</script>
```

</code-snippet>

## Thao tác đọc class

Để đọc class của một phần tử HTML, chúng ta có thể sử dụng thuộc tính `classList` của phần tử đó. Thuộc tính này trả về một đối tượng NodeList chứa tất cả các class của phần tử.

Ví dụ, để lấy tất cả các class của h1 element, chúng ta có thể sử dụng code sau:

<code-snippet>

```html
<style>
  .title {
    color: #fad300;
    background: #333;
  }
</style>
<h1 class="title active">Hello F8</h1>
<span class="class-list"></span>
<button>Run code</button>
<script>
  var h1 = document.querySelector('.title');
  var list = document.querySelector('.class-list');
  var btn = document.querySelector('button');
  btn.onclick = function () {
    var classes = h1.classList;
    for (var className of classes) {
      list.innerText += className + ' ';
    }
  };
</script>
```

</code-snippet>

Ngoài ra, chúng ta thường sử dụng phương thức `classList.contains()` để kiểm tra class đó đã có hoặc không có tại element đó chưa thay vì phải sử dụng một vòng lặp để tìm kiếm

<code-snippet>

```html
<style>
  .title {
    color: #fad300;
    background: #333;
  }
  .title.active {
    color: #333;
    background: #fad300;
  }
</style>
<h1 class="title active">Hello F8</h1>
<span class="result"></span>
<button>Run code</button>
<script>
  var h1 = document.querySelector('.title');
  var result = document.querySelector('.result');
  var btn = document.querySelector('button');
  btn.onclick = function () {
    h1.classList.contains('active')
      ? (result.innerText = 'Có class active')
      : (result.innerText = 'Không có class active');
  };
</script>
```

</code-snippet>

## Kết luận

Chúng ta sẽ cần nhớ về 5 phương thức này, vì mỗi khi làm việc với DOM chúng ta không thể bỏ qua các thao tác với class của HTML element

- `add()`: Thêm một hoặc nhiều class cho phần tử.
- `remove()`: Xóa một hoặc nhiều class cho phần tử.
- `contains()`: Kiểm tra xem phần tử có chứa một class cụ thể hay không.
- `toggle()`: Thêm hoặc xóa một class cho phần tử, tùy thuộc vào việc class đó có tồn tại hay không.
- `replace()`: Thay thế một class hiện có bằng một class mới.

---

## Từ khóa this trong event là gì?

Trong JavaScript, từ khóa this có thể được sử dụng để tham chiếu đến đối tượng hiện tại trong một phạm vi nhất định. Trong trường hợp của event, this sẽ tham chiếu đến phần tử HTML đã kích hoạt event đó.

Ví dụ, nếu chúng ta có một h1 element có ID là `title`, và chúng ta thêm một event listener cho event `click` cho h1 element đó, thì từ khóa this trong event `click` sẽ tham chiếu đến h1 element đó.

```javascript
const h1 = document.getElementById('title');

h1.addEventListener('click', function () {
  // this tham chiếu đến h1 element
  console.log(this);
});
```

---

### Khi nào cần sử dụng this trong event

Chúng ta cần sử dụng từ khóa this trong event khi chúng ta cần truy cập đến phần tử HTML đã kích hoạt event đó. Ví dụ, nếu chúng ta muốn thay đổi CSS của phần tử đã kích hoạt event, chúng ta có thể sử dụng from khóa this để truy cập đến phần tử đó.

<code-snippet>

```html
<h1 id="title">HelloF8</h1>

<script>
  const h1 = document.getElementById('title');

  h1.addEventListener('click', function () {
    // this tham chiếu đến h1 element
    this.style.backgroundColor = 'red';
  });
</script>
```

</code-snippet>

---

## Các trường hợp cần lưu ý với this trong event

Có một số trường hợp cần lưu ý với từ khóa this trong event:

- Trong event listener được định nghĩa bằng hàm anonymous, this sẽ tham chiếu đến element hiện tại.
- Trong event listener được định nghĩa bằng hàm arrow, this sẽ tham chiếu đến window.
- Trong event listener được định nghĩa bằng hàm bind, this sẽ tham chiếu đến đối tượng mà nó được bind.

Để tránh các lỗi do from khóa this, chúng ta nên sử dụng hàm thông thường `function` để listener cho đối tượng cụ thể mà chúng ta muốn tham chiếu.

```javascript
const h1 = document.getElementById('title');

// this tham chiếu đến h1 element
h1.addEventListener('click', function () {
  console.log(this); // h1 element
});

// this tham chiếu đến window
h1.addEventListener('click', () => {
  console.log(this); // window
});

// this tham chiếu đến h1 element
h1.addEventListener(
  'click',
  function () {
    console.log(this); // h1 element
  },
  this
);
```

<!-- Event Object -->

## Event Object là gì?

Event Object trong JavaScript là một đối tượng bao gồm các thuộc tính và phương thức mà tất cả các sự kiện có thể truy cập.
Đôi khi chúng ta truyền vào hàm xử lý event một đối tượng với tên đại loại như event, evt hay đơn giản chỉ là e
Nó tự động truyền vào hàm xử lý sự kiện để thêm các chức năng và thông tin

Ví dụ:

<code-snippet>

```html
<h1 class="title" id="title">Form login</h1>
<form id="formLogin">
  <div class="form-control">
    <label>
      Username
      <input type="text" name="username" />
    </label>
  </div>
  <div class="form-control">
    <label>
      Password
      <input type="password" name="password" />
    </label>
  </div>
  <button type="submit">Login</button>
</form>
<script>
  var title = document.querySelector('#title');
  var form = document.querySelector('#formLogin');
  var username = form.username;
  var password = form.password;
  form.addEventListener('submit', function (eventObject) {
    eventObject.preventDefault();
    var checkLogin = username.value === 'admin' && password.value === 'admin';
    if (checkLogin) {
      title.innerText = 'Login successful!';
    } else {
      alert('did you mean "admin"?');
      title.innerText = 'Login failed!';
    }
    username.focus();
    username.value = '';
    password.value = '';
    form.reset();
  });
</script>
```

</code-snippet>

Ở ví dụ này, chúng ta sử dụng đến Event Object và hàm `preventDefault()` để ngăn chặn sự kiện mặc định của form khi submit.

## Tại sao cần sử dụng Event Object?

Chúng ta sử dụng Event Object trong JavaScript vì nó cho phép chúng ta tương tác với HTML khi một sự kiện xảy ra. Mỗi phần tử HTML chứa một tập hợp các sự kiện mà có thể kích hoạt chương trình JavaScript. Ví dụ, khi người dùng nhấp chuột, khi một trang web đã được tải, khi một hình ảnh đã được tải, khi di chuyển chuột qua một phần tử, khi một trường đầu vào được thay đổi, khi một biểu mẫu HTML được submit, khi người dùng nhấn một phím.

Event Object giúp chúng ta xây dựng các chức năng phản hồi theo hành động của người dùng. Ví dụ, khi xây dựng chức năng hiển thị danh sách sinh viên, chúng ta xây dựng một button Hiển Thị Sinh Viên, nếu user click vào button này thì sẽ để lấy danh sách và trả kết quả về cho người dùng.

Nói cách khác, Event Object giúp chúng ta tạo ra các ứng dụng web tương tác và đáp ứng nhu cầu của người dùng một cách linh hoạt.

## Các loại Event Object

Các sự kiện trong JavaScript có thể được phân loại thành bốn nhóm chính:

**Sự kiện chuột (Mouse Events)**: Đây là nhóm sự kiện liên quan đến hành động của chuột, ví dụ như click chuột, di chuyển chuột qua một phần tử, v.v.
**Sự kiện bàn phím (Keyboard Events)**: Nhóm này bao gồm các sự kiện liên quan đến việc nhấn phím trên bàn phím.

**Sự kiện biểu mẫu (Form Events)**: Những sự kiện này xảy ra khi người dùng tương tác với một biểu mẫu HTML, ví dụ như khi một trường đầu vào được thay đổi hoặc khi một biểu mẫu HTML được submit.

**Sự kiện Document/Window**: Những sự kiện này liên quan đến trạng thái của trang web hoặc cửa sổ trình duyệt, ví dụ như khi một trang web đã được tải hoàn toàn.

Ngoài ra, còn có nhiều loại sự kiện khác trong JavaScript. Tùy thuộc vào nhu cầu cụ thể của ứng dụng, chúng ta có thể sử dụng các loại sự kiện khác nhau.

## Các thuộc tính, phương thức phổ biến

Event Object trong JavaScript có nhiều thuộc tính và phương thức khác nhau, tùy thuộc vào loại sự kiện. Dưới đây là một số thuộc tính và phương thức phổ biến:

| Sự kiện       | Mô tả                                                             |
| ------------- | ----------------------------------------------------------------- |
| `onclick`     | Xảy ra khi người dùng nhấn chuột vào một đối tượng HTML           |
| `ondblclick`  | Xảy ra khi người dùng nhấn chuột hai lần vào một đối tượng HTML   |
| `onmouseover` | Xảy ra khi con trỏ chuột di chuyển vào một đối tượng HTML         |
| `onmouseout`  | Xảy ra khi con trỏ chuột di chuyển ra khỏi một đối tượng HTML     |
| `onkeydown`   | Xảy ra khi người dùng nhấn phím xuống trên bàn phím               |
| `onkeypress`  | Xảy ra khi người dùng nhấn và giữ phím trên bàn phím              |
| `onkeyup`     | Xảy ra khi người dùng nhả phím trên bàn phím                      |
| `onchange`    | Xảy ra khi giá trị của một đối tượng HTML thay đổi                |
| `onfocus`     | Xảy ra khi một đối tượng HTML được chọn hoặc được đặt con trỏ vào |
| `onblur`      | Xảy ra khi một đối tượng HTML bị bỏ chọn hoặc bị mất con trỏ      |
| `onsubmit`    | Xảy ra khi người dùng gửi một form HTML                           |
| `onreset`     | Xảy ra khi người dùng thiết lập lại một form HTML                 |
| `onload`      | Xảy ra khi một trang web hoặc một ảnh được tải xong               |
| `onunload`    | Xảy ra khi người dùng rời khỏi một trang web                      |
| `oncopy`      | Xảy ra khi người dùng sao chép nội dung của một đối tượng HTML    |

<!-- Tìm hiểu phương thức e.preventDefault() và e.stopPropagation() -->

## Phương thức `e.preventDefault()` là gì?

Phương thức `e.preventDefault()` được sử dụng để ngăn chặn hành động mặc định của một event. Hành động mặc định của một event có thể là mở một liên kết, tải một hình ảnh, submit một form...

Ví dụ, nếu chúng ta có một liên kết có href là "https://fullstack.edu.vn", và chúng ta thêm một event listener cho event click cho liên kết đó, thì hành động mặc định của event click là mở liên kết. Tuy nhiên, nếu chúng ta gọi phương thức `e.preventDefault()` trong event listener, thì hành động mặc định sẽ bị ngăn chặn.

Ví dụ:

<code-snippet>

```html
<style>
  .page {
    transition: opacity 0.3s ease-in-out;
  }
  .page.hide {
    opacity: 0;
  }
</style>
<div class="page">
  <h1>Home</h1>
  <a href="/about">Sang trang</a>
</div>
<script>
  const page = document.querySelector('.page');
  const pageTagA = page.querySelector('a');
  const pageTitle = page.querySelector('h1');
  pageTagA.addEventListener('click', function (e) {
    e.preventDefault();
    page.classList.add('hide');
    const title = pageTitle.innerText === 'Home' ? 'About' : 'Home';
    const attribute =
      pageTagA.getAttribute('href') === '/about' ? '/' : '/about';
    setTimeout(function () {
      pageTitle.innerText = title;
      pageTagA.href = attribute;
      page.classList.remove('hide');
    }, 300);
  });
</script>
```

</code-snippet>

Ở ví dụ này, như ta thấy một thẻ `a` có đường dẫn tới trang About hoặc Home, tuy nhiên khi bấm vào thì không chuyển trang. Với trường hợp này, ta cần sử dụng tới `e.preventDefault()` để ngăn sự kiện mặc định chuyển sang trang của HTML.

### Khi nào cần sử dụng phương thức `e.preventDefault()`?

Chúng ta cần sử dụng phương thức `e.preventDefault()` khi chúng ta muốn ngăn chặn hành động mặc định của một event. Ví dụ, chúng ta có thể sử dụng phương thức này để:

- Ngăn chặn việc tải một trang web mới khi người dùng nhấp vào một liên kết.

- Ngăn chặn việc mở một hình ảnh mới khi người dùng nhấp vào một hình ảnh.

- Ngăn chặn việc thay đổi tab khi người dùng nhấp vào một liên kết.

- Và còn nhiều tình huống khác nữa.

---

## Phương thức `e.stopPropagation()` là gì?

Phương thức `e.stopPropagation()` được sử dụng để ngăn chặn sự lan truyền của một event. Khi một event xảy ra, event đó sẽ được truyền từ phần tử khởi tạo event đến các phần tử cha của phần tử đó. Phương thức `e.stopPropagation()` được sử dụng để ngăn chặn sự lan truyền của event đến các phần tử cha.

Ví dụ, nếu chúng ta có một div element có chứa một button element, và chúng ta thêm một event listener cho event click cho div element đó, thì event đó sẽ được truyền từ div element đến button element. Tuy nhiên, nếu chúng ta gọi phương thức `e.stopPropagation()` trong event listener cho div element, thì event đó sẽ không được truyền đến button element.

```javascript
const div = document.querySelector('div');
const button = document.querySelector('button');

div.addEventListener('click', function (e) {
  // Ngăn chặn sự lan truyền của event
  e.stopPropagation();

  // Thực hiện hành động tùy chỉnh
  console.log('Bạn đã nhấp vào div');
});

button.addEventListener('click', function () {
  console.log('Bạn đã nhấp vào button');
});
```

<code-snippet>

```html
<style>
  .modal {
    width: 100vw;
    height: 100vh;
    position: fixed;
    top: 0;
    left: 0;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    opacity: 1;
    transition: opacity 0.3s ease-in-out;
  }
  .container {
    width: 500px;
    height: 500px;
    background-color: #fff;
    border-radius: 10px;
    padding: 20px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
  }
  .hide {
    opacity: 0;
    pointer-events: none;
  }
</style>
<button>Open</button>
<div class="modal">
  <div class="container">
    <h1>Hello World!</h1>
    <button>Close</button>
  </div>
</div>

<script>
  const modal = document.querySelector('.modal');
  const btn = document.querySelectorAll('button');
  const container = document.querySelector('.container');
  btn.forEach(function (element) {
    element.addEventListener('click', function (e) {
      modal.classList.toggle('hide');
    });
  });
  container.addEventListener('click', function (e) {
    e.stopPropagation();
  });
  modal.addEventListener('click', function (e) {
    modal.classList.toggle('hide');
  });
</script>
```

</code-snippet>

Ở trường hợp này, ta tận dụng modal để làm overlay, tuy nhiên việc này mang đến 1 bất lợi khi click vào container vẫn là click vào modal, vì vậy nó vẫn được tắt đi mặc dù không đúng. Vì vậy, chúng ta ngăn chặn sự kiện của cha `modal` vào con `container` để có thể thực hiện các tác vụ trong `container` hoàn toàn bình thường.

### Khi nào cần sử dụng phương thức `e.stopPropagation()`?

Chúng ta cần sử dụng phương thức e.stopPropagation() khi chúng ta muốn ngăn chặn sự lan truyền của một event. Ví dụ, chúng ta có thể sử dụng phương thức này để:

- Ngăn chặn việc kích hoạt một event khác khi người dùng nhấp vào một phần tử.

- Ngăn chặn việc mở một menu khi người dùng nhấp vào một liên kết.

- Ngăn chặn việc đóng một modal khi người dùng nhấp vào một phần tử bên ngoài modal.

## Kết luận

Phương thức `e.preventDefault()` được sử dụng để ngăn chặn hành động mặc định của một event. Phương thức `e.stopPropagation()` được sử dụng để ngăn chặn sự lan truyền của một event.

<!-- DOM Navigation -->

## DOM Navigation

DOM Navigation cho phép chúng ta điều hướng qua cây DOM bằng cách sử dụng các quan hệ giữa các nút. Chúng ta có thể sử dụng các thuộc tính như `parentNode`, `firstChild`, `lastChild`, `nextSibling` và `previousSibling` để di chuyển lên, xuống và ngang qua cây DOM.

Ví dụ:

<code-snippet>

```html
<div class="container">
  <button>Run code</button>
  <span class="paragraph">Hello</span>
</div>

<script>
  const paragraph = document.querySelector('.paragraph');
  const container = paragraph.parentNode; // Tác động vào thẻ cha từ thẻ con
  const button = paragraph.previousElementSibling; // Tác động vào thẻ đằng trước
  const span = document.createElement('span');
  span.innerText = 'F8';
  container.appendChild(span);
  button.addEventListener('click', () => {
    const span = document.createElement('span');
    container.style.backgroundColor = '#ffaadd80';
    span.innerHTML = '8';
    container.appendChild(span);
  });
</script>
```

</code-snippet>

---

## Cách sử dụng DOM Navigation

### Thuộc tính `firstElementChild`

`firstElementChild` giúp ta lấy được phần tử con đầu tiên của một element.

Ví dụ:

<code-snippet>

```html
<style>
  * {
    user-select: none;
  }
  .active {
    background-color: #faa300;
  }
</style>
<div class="container">
  <h1>Hello F8</h1>
  <p>Click vào thẻ H1</p>
</div>
<script>
  const container = document.querySelector('.container');
  container.firstElementChild.addEventListener('click', function () {
    this.classList.toggle('active');
  });
</script>
```

</code-snippet>

Ở ví dụ này, chúng ta lấy được thẻ H1 từ element cha là container, khi click vào thẻ H1, background sẽ được thành màu Cam.

---

### Thuộc tính `lastElementChild`

Tương tự như trên, thuộc tính `lastElementChild` giúp ta lấy được phần tử con cuối cùng của một element.

Ví dụ:

<code-snippet>

```html
<style>
  * {
    user-select: none;
  }
  .active {
    background-color: #faa300;
  }
</style>
<div class="container">
  <h1>Hello F8</h1>
  <p>Click vào thẻ H1</p>
</div>
<script>
  const container = document.querySelector('.container');
  const message = container.lastElementChild.innerText;
  let count = 0;
  container.firstElementChild.addEventListener('click', function () {
    this.classList.toggle('active');
    container.lastElementChild.innerText = `${message} ${++count} lần`;
  });
</script>
```

</code-snippet>

Ở ví dụ này, chúng ta lấy được thẻ p từ element cha là container, khi click vào thẻ H1, sẽ hiển thị số lần click vào thẻ p

### Thuộc tính `parentElement`

Thuộc tính `parentElement` giúp ta lấy được phần tử cha của một element.

Ví dụ:

<code-snippet>

```html
<style>
  * {
    user-select: none;
  }
  .active {
    background-color: #faa300;
  }
</style>
<div class="container">
  <div class="container-inner">
    <h1>Hello F8</h1>
    <p>Click vào thẻ H1</p>
  </div>
  <button class="reset">Reset</button>
</div>
<script>
  const container = document.querySelector('.container');
  const h1Tag = container.firstElementChild.querySelector('h1');
  const pTag = container.firstElementChild.querySelector('p');
  const message = pTag.innerText;
  let count = 0;
  h1Tag.addEventListener('click', function () {
    this.parentElement.classList.toggle('active');
    pTag.innerText = `${message} ${++count} lần`;
  });
  const reset = container.lastElementChild;
  reset.addEventListener('click', function () {
    const active = document.querySelector('.active');
    active.classList.remove('active');
    pTag.innerText = message;
    count = 0;
  });
</script>
```

</code-snippet>

Ở ví dụ này, chúng ta lấy được `.container-inner` từ h1, sau khi click, add class active cho cả thẻ cha là `.container-inner`

---

### Thuộc tính `nextElementSibling`

Thuộc tính `nextElementSibling` giúp ta lấy được phần tử tiếp theo của một element.

Ví dụ:

<code-snippet>

```html
<style>
  * {
    user-select: none;
  }
  .active {
    background-color: #faa300;
  }
</style>
<div class="container">
  <h1>Hello F8</h1>
  <p>Click vào thẻ H1</p>
</div>
<script>
  const container = document.querySelector('.container');
  const message = container.lastElementChild.innerText;
  let count = 0;
  container.firstElementChild.addEventListener('click', function () {
    this.classList.toggle('active');
    this.nextElementSibling.innerText = `${message} ${++count} lần`;
  });
</script>
```

</code-snippet>

Ở ví dụ này, chúng ta lấy được thẻ H1, sau khi bấm, ta lấy được thẻ p bằng cách sử dụng `nextElementSibling`

---

### Thuộc tính `previousElementSibling`

Thuộc tính `previousElementSibling` giúp ta lấy được phần tử đằng trước của một element.

Ví dụ:

<code-snippet>

```html
<style>
  .active {
    background-color: #faa300;
  }
</style>
<div class="container">
  <h1>Hello F8</h1>
</div>
<button>Change Theme</button>
<script>
  const btn = document.querySelector('button');
  btn.addEventListener('click', function () {
    this.previousElementSibling.classList.toggle('active');
  });
</script>
```

</code-snippet>

Ở ví dụ này, chúng ta lấy được thẻ button, sau khi bấm, ta lấy được `.container` bằng cách sử dụng `previousElementSibling`

---

## Kết luận

Ngoài các ví dụ trên, còn các node khác như:

`firstChild`: Sẽ trả về một **node** con đầu tiên của một element. Chúng khác với `firstElementChild` sẽ trả về một phần tử HTML đầu tiên.

`lastChild`: Sẽ trả về một **node** con cuối cùng của một element. Chúng khác với `lastElementChild` sẽ trả về một phần tử HTML cuối cùng.

`childNodes`: Sẽ trả về tất cả các **node** con của một element. Chúng khác với `children` sẽ trả về tất cả các phần tử HTML con.

`parentNode`: Sẽ trả về **node** cha của một element. Chúng khác với `parentElement` sẽ trả về phần tử HTML cha.

`nextSibling`: Sẽ trả về **node** tiếp theo của một element. Chúng khác với `nextElementSibling` sẽ trả về phần tử HTML tiếp theo.

`previousSibling`: Sẽ trả về **node** đằng trước của một element. Chúng khác với `previousElementSibling` sẽ trả về phần tử HTML đằng trước.

`nodeName`: Sẽ trả về tên của **node** chứa tên thẻ viết hoa của HTML.

`nodeValue`: Sẽ trả về giá trị của **node**.

`nodeType`: Sẽ trả về kiểu của **node**.

<!-- Custom Event và Custom Element -->

## Custom Event

Custom event trong JavaScript, còn được gọi là sự kiện tổng hợp, là một loại sự kiện do chúng ta tự tạo ra. Chúng có thể được kích hoạt từ bên trong một sự kiện khác. Giống như các sự kiện thông thường, Custom Events cho phép thực thi và các đưa ra các output tùy chọn. Tuy nhiên, chúng được tự custom hoặc tạo mới và có thể được gọi nhiều lần trong suốt quá trình sử dụng trang web.

Custom event có thể được sử dụng để tạo "các sự kiện khác biệt".

Ví dụ: một hoặc tất cả phần tử text của chúng ta có thể kích hoạt các sự kiện cho biết điều gì xảy ra với đoạn text đó: selected (bôi đen), copy (sao chép), v.v. Một đoạn code khác có thể lắng nghe các sự kiện và quan sát những gì đang xảy ra với đoạn text đó. Sau khi quan sát, chúng thực hiện một hành động và đưa ra một output tùy chỉnh.

- Như trang web google sheet, khi thực hiện copy một ô của table, chúng copy cả định dạng và khi paste vào sheet sẽ giữ được định dạng đó.

- Như các text-editor, khi bôi đen, bấm các tổ hợp phím như `ctrl B` sẽ thực hiện in đậm chính đoạn text đó lên.

- ...

Chúng ta không chỉ có thể tạo ra các sự kiện hoàn toàn mới sử dụng cho mục đích của riêng mình mà còn cả những sự kiện tích hợp sẵn, chẳng hạn như click, mousedown, v.v. Điều này có thể hữu ích cho việc kiểm tra tự động.

Để tạo custom event, chúng ta có thể sử dụng constructor `Event()`. chúng ta cũng có thể tạo custom event bằng cách sử dụng `CustomEvent()` constructor, cho phép chúng ta chỉ định thông tin bổ sung của thuộc tính.

---

Ví dụ:

<code-snippet>

```html
<p class="text">
  Lorem ipsum dolor sit amet consectetur adipisicing elit. Mollitia sapiente
  beatae quis ipsa ex iusto nulla ullam a quos ea!
</p>
<p class="text2">Hello F8</p>
<script>
  const contextMenu = document.createElement('ul');
  const cssUl = {
    listStyle: 'none',
    padding: 0,
    backgroundColor: '#f8f9fa',
    border: '1px solid #ccc',
    position: 'fixed',
    zIndex: 1000,
    display: 'none',
    cursor: 'pointer',
  };
  const btnCopy = document.createElement('button');
  btnCopy.innerText = 'Copy to clipboard';
  btnCopy.onclick = function () {
    navigator.clipboard.writeText(selectedEvent.detail.textContent);
  };

  const btnSearch = document.createElement('button');
  btnSearch.innerText = 'Search in Google';
  btnSearch.onclick = function () {
    window.open(
      'https://www.google.com/search?q=' +
        encodeURIComponent(selectedEvent.detail.textContent)
    );
  };

  contextMenu.appendChild(btnCopy);
  contextMenu.appendChild(btnSearch);
  Object.assign(contextMenu.style, cssUl);
  document.body.appendChild(contextMenu);
  const selectedEvent = new CustomEvent('selected', {
    detail: { textContent: '' },
  });

  document.addEventListener('selected', function (e) {
    const selectedText = window.getSelection().toString();
    if (selectedText) {
      e.detail.textContent = selectedText;
      contextMenu.style.display = 'block';
    } else {
      contextMenu.style.display = 'none';
    }
  });
  document.addEventListener('mouseup', function () {
    document.dispatchEvent(selectedEvent);
  });
</script>
```

</code-snippet>

Ở đoạn code này, chúng ta bắt một sự kiện tùy chỉnh có tên `selected` và thực hiện lấy được đoạn text đã bôi đen, sau khi bôi đen hoàn tất, chúng ta thấy hiện ra một output vùng tùy chọn có copy, search để thực hiện các sự kiện của riêng chúng ta định nghĩa như copy đoạn text, search trên google...

---

### Phân biệt giữa `new Event` và `new CustomEvent`

- **new Event** tạo ra một sự kiện đơn giản, không có dữ liệu tùy chỉnh nào được gắn vào.
- **new CustomEvent** tạo ra một sự kiện có thể chứa dữ liệu tùy chỉnh trong thuộc tính `detail` của nó.
- **new MouseEvent** tạo ra một sự kiện liên quan đến con trỏ chuột, có thêm các thuộc tính như `clientX`, `clientY`, `button`, ...
- Nếu chúng ta muốn tạo một sự kiện cuộn (`scroll`), chúng ta có thể sử dụng `new Event('scroll')` hoặc `new CustomEvent('scroll', {detail: ...})` tùy theo nhu cầu của chúng ta.
- Nếu chúng ta muốn tạo một sự kiện nhấp (`click`), chúng ta nên sử dụng `new MouseEvent('click')` để có thể truy cập các thuộc tính của con trỏ chuột.

| **Đặc điểm**          | **new Event**                                                             | **new CustomEvent**                                                              |
| --------------------- | ------------------------------------------------------------------------- | -------------------------------------------------------------------------------- |
| **Mô tả**             | Tạo ra một sự kiện đơn giản, không có dữ liệu tùy chỉnh nào được gắn vào. | Tạo ra một sự kiện có thể chứa dữ liệu tùy chỉnh trong thuộc tính detail của nó. |
| **Cú pháp**           | `new Event('event-name')`                                                 | `new CustomEvent('event-name', { detail: data })`                                |
| **Dữ liệu tùy chỉnh** | Không hỗ trợ.                                                             | Có hỗ trợ thông qua thuộc tính `detail`.                                         |
| **Sử dụng**           | Thích hợp cho các sự kiện đơn giản như 'click', 'scroll', v.v.            | Thích hợp khi chúng ta muốn gắn kèm dữ liệu tùy chỉnh vào sự kiện.               |

---

## Trigger Event

Một số phần tử cung cấp các phương thức cụ thể để kích hoạt một sự kiện.

Ví dụ: để kích hoạt sự kiện click trên bất kỳ phần tử nào, chúng ta có thể sử dụng phương thức `click()`:

```javascript
btn.click();
```

Các phần tử nhập liệu đầu vào cung cấp các phương thức `focus()` và `blur()` để kích hoạt các sự kiện focus và blur:

```javascript
input.focus();
input.blur();
```

Phần tử form có các phương thức `submit()` và `reset()` để kích hoạt các sự kiện submit và reset:

```javascript
form.submit();
form.reset();
```

---

Đó là các phương thức đã được hỗ trợ sẵn, với các phương thức cần được custom lại, trigger có thể được viết như sau:

<code-snippet>

```html
<div class="quantity">
  <button class="minus">-</button>
  <input type="text" size="3" value="1" />
  <button class="plus">+</button>
  <input type="range" value="1" class="timer" />
</div>
<hr />
<p>Tổng tiền: <span class="price">100 USD</span></p>
<script>
  const quantity = document.querySelector('.quantity');
  const quantityInput = quantity.querySelector('input');
  const timer = document.querySelector('.timer');
  const price = document.querySelector('.price');
  const minusBtn = quantityInput.previousElementSibling;
  const plusBtn = quantityInput.nextElementSibling;
  const changeEvent = new Event('change');

  // Call change

  plusBtn.addEventListener('click', function () {
    quantityInput.value++;
    quantityInput.dispatchEvent(changeEvent);
  });

  minusBtn.addEventListener('click', function () {
    quantityInput.value--;
    if (quantityInput.value < 1) {
      quantityInput.value = 1;
    }
    quantityInput.dispatchEvent(changeEvent);
  });

  // Custom event drag

  let initialValue = null;
  let dragEvent;

  document.addEventListener('mouseup', function () {
    initialValue = null;
  });

  timer.addEventListener('input', function () {
    if (!initialValue) {
      initialValue = this.value;
      dragEvent = new CustomEvent('drag', {
        detail: {
          initialValue: initialValue,
        },
      });
    }

    if (this.value !== initialValue) {
      timer.dispatchEvent(dragEvent);
    }
  });

  // 2 event listeners custom

  quantityInput.addEventListener('change', function () {
    price.innerText = this.value * 100 + ' USD';
    timer.value = this.value;
  });

  timer.addEventListener('drag', function (e) {
    quantityInput.value = this.value;
    quantityInput.dispatchEvent(changeEvent);
  });
</script>
```

</code-snippet>

Trong ví dụ này, chúng ta tái định nghĩa một trigger `change`, của `quantityInput`, Trong event này, chúng ta làm 2 việc là cập nhật giá tiền, cập nhật thanh range.

Và có 3 nơi dispatch trigger này:

- Khi `plusBtn` và `minusBtn` được click.

- Custom một event là drag, khi thanh range được "Kéo"

Thì sẽ đều gọi và thực hiện event change của input, từ đó có thể cập nhật thanh kéo, cập nhật giá mà không cần viết lại nhiều lần.

---

## Kết luận

Custom event là một kỹ thuật giúp ta tạo mới hoặc custom lại event đã có. Nhờ đó, chúng ta có thể viết và tái sử dụng các sự kiện một cách khoa học, hợp lý và không phải viết lại nhiều.

Nhờ đó, các sự kiện được xử lý ở mọi nơi khác nhau nhưng có một hành động giống nhau, có thể sử dụng custom Event để giải quyết hiệu quả hơn.

<!-- Custom Element và các tình huống thực tế -->

## Custom Element

Custom Element là một loại phần tử HTML được định nghĩa bởi chính chúng ta. Custom Element có thể được sử dụng để tạo ra các thành phần web tùy chỉnh có hành vi và kiểu dáng riêng.

---

### Custom Element có thể làm gì?

Custom Element có thể làm được tất cả những gì mà các phần tử HTML tiêu chuẩn có thể làm, bao gồm:

- Hiển thị nội dung
- Kích hoạt các sự kiện
- Tương tác với người dùng

Ngoài ra, Custom Element còn có thể làm được những việc mà các phần tử HTML tiêu chuẩn không thể làm, chẳng hạn như:

- Tự định nghĩa các thuộc tính và phương thức
- Tự định nghĩa các CSS selector
- Thừa kế từ các phần tử HTML khác

---

### Custom Element thường được dùng để làm gì?

Custom Element thường được dùng để tạo ra các thành phần web tùy chỉnh có hành vi và kiểu dáng riêng. Ví dụ, Custom Element có thể được sử dụng để tạo ra:

- Các biểu mẫu tùy chỉnh
- Các thanh công cụ tùy chỉnh
- Các menu tùy chỉnh
- Các trò chơi và ứng dụng web tùy chỉnh

---

### Cách sử dụng Custom Element với function constructor

Để tạo ra một Custom Element với function constructor, chúng ta cần tạo một function constructor có tên là `customElement`. Function constructor này sẽ trả về một đối tượng có các thuộc tính và phương thức của Custom Element.

Ví dụ về cách tạo ra một Custom Element với function constructor:

```javascript
function MyElement() {
  // Tạo đối tượng Custom Element
  const element = document.createElement('div');

  // Thêm thuộc tính và phương thức cho Custom Element
  element.setAttribute('is', 'my-element');
  element.textContent = 'Hello, world!';

  // Trả về đối tượng Custom Element
  return element;
}

// Đăng ký Custom Element với trình duyệt
customElements.define('my-element', MyElement);
```

---

### Cách sử dụng Custom Element với class HTMLElement

Để tạo ra một Custom Element với class HTMLElement, chúng ta cần tạo một class kế thừa từ class `HTMLElement`. Class này sẽ định nghĩa các thuộc tính và phương thức của Custom Element.

Dưới đây là một ví dụ về cách tạo ra một Custom Element với class HTMLElement:

```javascript
class MyElement extends HTMLElement {
  constructor() {
    super();

    // Thêm thuộc tính và phương thức cho Custom Element
    this.textContent = 'Hello, world!';

    // Tạo sự kiện click
    this.addEventListener('click', () => {
      console.log('Đã nhấp vào Custom Element');
    });
  }
}

// Đăng ký Custom Element với trình duyệt
customElements.define('my-element', MyElement);

// Thêm Custom Element vào DOM
const element = document.querySelector('my-element');
```

---

## Sử dụng Custom Element

Như chúng ta thấy ở đây:

<code-snippet>

```html
<style>
  h1 {
    color: red;
  }
</style>
<h1>Hello F8</h1>
```

</code-snippet>

Chúng ta có một text-editor với field nhập liệu code ở bên trái, bên phải là một vùng để hiển thị kết quả.

Với trường hợp này, nếu như không sử dụng Custom Element, thì mỗi khi tạo thêm một text-editor như vậy thì phải copy rất nhiều code, sửa lại JS và khó để custom lại. Vì vậy, nếu sử dụng Custom Element thì có thể làm được một text-editor riêng biệt một cách dễ dàng.

---

### Bước 1: Khởi tạo base cho thành phần custom

Trước khi custom một element, chúng ta cần biết được nó làm gì, cấu trúc và style như nào, như vậy chúng ta có thể xây dựng một base HTML như sau:

```html
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    border: none;
    outline: none;
  }
  .code-snippet {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: #f2f2f2;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
    height: 80vh;
    width: 80vw;
    padding: 12px;
    border-radius: 12px;
    box-shadow: 0 0 12px rgba(0, 0, 0, 0.1);
  }
  .code-snippet .area {
    position: relative;
    height: 100%;
    width: 45%;
    over-flow: hidden;
  }
  .code-snippet button {
    position: absolute;
    height: 30px;
    width: 60px;
    background-color: #f2f2f2;
    bottom: 10px;
    right: 10px;
    border-radius: 8px;
    cursor: pointer;
  }
  .code-snippet textarea {
    height: 100%;
    width: 100%;
    padding: 12px;
    border-radius: 12px;
    resize: none;
    background-color: #191a2e;
    color: #baa4da;
    font-size: 16px;
  }
  .code-snippet iframe {
    height: 100%;
    width: 55%;
    border-radius: 12px;
  }
</style>
<div class="code-snippet">
  <div class="area">
    <textarea
      spellcheck="false"
      title="Hi, mình là Dương Nguyễn, mình làm cái code snippet này đó hihi ^^">
    </textarea>
    <button title="Reset code">Reset</button>
  </div>
  <iframe></iframe>
</div>
```

Ở đây, ngoại trừ style, chúng ta có một vùng nhập liệu bên trái với text-area, button để reset lại giá trị ban đầu.

Bên phải là một iframe để hiển thị kết quả của HTML viết bên trái.

---

### Bước 2 Đăng ký phần tử

Chúng ta có thể sử dụng một `<template>` element để dễ dàng sửa đổi hơn.

```javascript
const codeSnippetContent = document.createElement('template');
codeSnippetContent.innerHTML = `Đoạn HTML trên`;
```

Sau đó chúng ta khởi tạo một hàm tạo `CodeSnippet` để khởi tạo và khai báo các function cần thiết.

```javascript
function CodeSnippet() {
  // Khởi tạo HTMLElement
  const shadowRoot = Reflect.construct(HTMLElement, [], this.constructor);
  // Khởi tạo ShadowDom
  shadowRoot.attachShadow({ mode: 'open' });
  // Sử dụng element Template để làm code base
  shadowRoot.shadowRoot.appendChild(codeSnippetContent.content.cloneNode(true));
  // Lấy ra các element và giá trị cần thiết trong shadowRoot
  shadowRoot.textarea = shadowRoot.shadowRoot.querySelector('textarea');
  shadowRoot.iframe = shadowRoot.shadowRoot.querySelector('iframe');
  shadowRoot.resetButton = shadowRoot.shadowRoot.querySelector('button');
  shadowRoot.innerContent = shadowRoot.innerHTML.trim();
  // Xử lý đoạn này để code-snippet có thể lấy được các đoạn code HTML ở bên trong nó
  if (shadowRoot.innerContent) {
    shadowRoot.updateContent(shadowRoot.innerContent);
    shadowRoot.iframe.srcdoc = shadowRoot.innerContent;
    shadowRoot.innerHTML = '';
  }
  // Thử các sự kiện
  shadowRoot.textarea.focus();
  shadowRoot.resetButton.click();
  return shadowRoot;
}
// Lấy các prototype từ HTMLElement vào CodeSnippet
CodeSnippet.prototype = Object.create(HTMLElement.prototype, {
  constructor: { value: CodeSnippet },
});

// Đăng ký phần tử với customElements
customElements.define('code-snippet', CodeSnippet);
```

---

### Bước 3: Hoàn thiện các function cơ bản

Các phần tử đã được định nghĩa, tuy nhiên chúng chưa thể chạy được gì. Vì vậy, chúng ta thêm một số sự kiện cho nó

```javascript
function CodeSnippet() {
  const shadowRoot = Reflect.construct(HTMLElement, [], this.constructor);
  shadowRoot.attachShadow({ mode: 'open' });
  shadowRoot.shadowRoot.appendChild(codeSnippetContent.content.cloneNode(true));
  shadowRoot.textarea = shadowRoot.shadowRoot.querySelector('textarea');
  shadowRoot.iframe = shadowRoot.shadowRoot.querySelector('iframe');
  shadowRoot.resetButton = shadowRoot.shadowRoot.querySelector('button');
  shadowRoot.innerContent = shadowRoot.innerHTML.trim();
  if (shadowRoot.innerContent) {
    shadowRoot.updateContent(shadowRoot.innerContent);
    shadowRoot.iframe.srcdoc = shadowRoot.innerContent;
    shadowRoot.innerHTML = '';
  }
  shadowRoot.textarea.addEventListener(
    'keydown',
    shadowRoot.debounce(shadowRoot.updateIframe, 300).bind(shadowRoot)
  );
  shadowRoot.resetButton.addEventListener(
    'click',
    shadowRoot.reset.bind(shadowRoot)
  );
  shadowRoot.shadowRoot.addEventListener(
    'keydown',
    shadowRoot.saveContent.bind(shadowRoot)
  );
  shadowRoot.textarea.focus();
  shadowRoot.resetButton.click();
  return shadowRoot;
}
```

Sau khi có các sự kiện, chúng ta sẽ định nghĩa các function tương ứng:

1. **Hàm Debounce**:

```javascript
CodeSnippet.prototype.debounce = function (func, wait) {
  let timeout;
  return function () {
    const context = this,
      args = arguments;
    const later = function () {
      timeout = null;
      func.apply(context, args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
};
```

- **Mục đích**: Hàm này được sử dụng để giới hạn tốc độ gọi một hàm. Nó trì hoãn việc thực hiện hàm `func` trong `wait` milliseconds nếu hàm đã được gọi nhiều lần.

- **Chi tiết**:

  - `func`: Hàm cần được trì hoãn.
  - `wait`: Thời gian chờ (milliseconds) trước khi thực hiện `func`.

- **Cách hoạt động**:
  - Khi hàm được gọi, nó sẽ đặt một hẹn giờ. Nếu hàm được gọi lại trong khoảng thời gian `wait`, hẹn giờ trước đó sẽ bị huỷ và hẹn giờ mới sẽ được đặt. Sau khi không có cuộc gọi nào trong khoảng thời gian `wait`, hàm `func` sẽ được thực hiện.

2. **Hàm Cập Nhật Iframe**:

```javascript
CodeSnippet.prototype.updateIframe = function () {
  const code = this.textarea.value;
  const newIframe = document.createElement('iframe');
  newIframe.srcdoc = this.iframe.srcdoc;
  this.iframe.parentNode.replaceChild(newIframe, this.iframe);
  const iframeDoc = newIframe.contentDocument;
  iframeDoc.open();
  iframeDoc.write(code);
  this.updateContent(code);
  iframeDoc.close();
  this.iframe = newIframe;
};
```

- **Mục đích**: Hàm này cập nhật nội dung của `<iframe>` để hiển thị mã HTML.

- **Chi tiết**:
  - `this.textarea.value`: Lấy giá trị trong phần `<textarea>` của `<code-snippet>`.
  - `document.createElement('iframe')`: Tạo một thẻ `<iframe>` mới.
  - `newIframe.srcdoc = this.iframe.srcdoc;`: Sao chép nội dung của iframe hiện tại vào iframe mới.
  - `this.iframe.parentNode.replaceChild(newIframe, this.iframe);`: Thay thế iframe cũ bằng iframe mới.
  - `const iframeDoc = newIframe.contentDocument;`: Truy cập vào document bên trong iframe.
  - `iframeDoc.open();`: Mở document trong iframe để viết nội dung vào.
  - `iframeDoc.write(code);`: Viết mã HTML vào document trong iframe.
  - `this.updateContent(code);`: Cập nhật nội dung trong `<textarea>`.
  - `iframeDoc.close();`: Đóng document trong iframe.
  - `this.iframe = newIframe;`: Cập nhật iframe với iframe mới.

3. **Hàm Reset**:

```javascript
CodeSnippet.prototype.reset = function () {
  const srcDoc = this.iframe.srcdoc;
  this.updateContent(srcDoc);
  this.updateIframe();
};
```

- **Mục đích**: Hàm này reset giá trị của `<code-snippet>` về trạng thái mặc định.

- **Chi tiết**:
  - `const srcDoc = this.iframe.srcdoc;`: Lấy nội dung của iframe.
  - `this.updateContent(srcDoc);`: Cập nhật nội dung trong `<textarea>` với nội dung của iframe.
  - `this.updateIframe();`: Cập nhật lại iframe.

4. **Hàm Cập Nhật Nội Dung**:

```javascript
CodeSnippet.prototype.updateContent = function (value) {
  const textarea = this.textarea;
  value = value.replaceAll('      ', '');
  textarea.textContent = value;
  textarea.value = value;
};
```

- **Mục đích**: Hàm này cập nhật nội dung của `<textarea>`.

- **Chi tiết**:
  - `value`: Giá trị cần cập nhật.
  - `value.replaceAll('      ', '');`: Loại bỏ các khoảng trắng đầu dòng.
  - `textarea.textContent = value;`: Cập nhật nội dung văn bản.
  - `textarea.value = value;`: Cập nhật giá trị của textarea.

5. **Hàm Lưu Nội Dung**:

```javascript
CodeSnippet.prototype.saveContent = function (event) {
  if (event.ctrlKey && event.key === 's') {
    event.preventDefault();
    const fileName = this.textarea.value.slice(0, 5);
    const fileContent = this.textarea.value;
    navigator.clipboard.writeText(fileContent);
    const blob = new Blob([fileContent], {
      type: 'text/html',
    });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName + '.html';
    a.click();
    window.URL.revokeObjectURL(url);
  }
};
```

- **Mục đích**: Hàm này lưu nội dung vào một file HTML khi người dùng ấn Ctrl + S.

- **Chi tiết**:
  - `event.ctrlKey && event.key === 's'`: Kiểm tra nếu người dùng ấn Ctrl + S.
  - `event.preventDefault();`: Ngăn chặn hành động mặc định của Ctrl + S.
  - `const fileName = this.textarea.value.slice(0, 5);`: Lấy một phần của nội dung để làm tên file.
  - `const fileContent = this.textarea.value;`: Lấy nội dung từ textarea.
  - `navigator.clipboard.writeText(fileContent);`: Copy nội dung vào clipboard.
  - Tạo một Blob từ nội dung và cài đặt kiểu là 'text/html'.
  - Tạo một đường dẫn URL từ Blob.
  - Tạo một thẻ `<a>` để tạo và tải xuống liên kết.
  - Bấm vào liên kết để tải xuống file.
  -

Loại bỏ đường dẫn URL sau khi tải xuống.

6. **Ngăn Chặn Ctrl + S Tại Mức Cửa Sổ**:

```javascript
window.addEventListener('keydown', function (event) {
  if (event.ctrlKey && event.key === 's') {
    event.preventDefault();
  }
});
```

- **Mục đích**: Ngăn chặn hành động mặc định của Ctrl + S khi được gọi ở mức cửa sổ.

- **Chi tiết**:
  - `event.ctrlKey && event.key === 's'`: Kiểm tra nếu người dùng ấn Ctrl + S.
  - `event.preventDefault();`: Ngăn chặn hành động mặc định của Ctrl + S.

---

### Hoàn thiện code-snippet đơn giản

Sau khi hoàn thiện, đoạn code cuối cùng sẽ là:

```javascript
const codeSnippetContent = document.createElement('template');
codeSnippetContent.innerHTML = `Đoạn HTML trên`;
function CodeSnippet() {
  const shadowRoot = Reflect.construct(HTMLElement, [], this.constructor);
  shadowRoot.attachShadow({ mode: 'open' });
  shadowRoot.shadowRoot.appendChild(codeSnippetContent.content.cloneNode(true));
  shadowRoot.textarea = shadowRoot.shadowRoot.querySelector('textarea');
  shadowRoot.iframe = shadowRoot.shadowRoot.querySelector('iframe');
  shadowRoot.resetButton = shadowRoot.shadowRoot.querySelector('button');
  shadowRoot.innerContent = shadowRoot.innerHTML.trim();
  if (shadowRoot.innerContent) {
    shadowRoot.updateContent(shadowRoot.innerContent);
    shadowRoot.iframe.srcdoc = shadowRoot.innerContent;
    shadowRoot.innerHTML = '';
  }
  shadowRoot.textarea.addEventListener(
    'input',
    shadowRoot.debounce(shadowRoot.updateIframe, 300).bind(shadowRoot)
  );
  shadowRoot.resetButton.addEventListener(
    'click',
    shadowRoot.reset.bind(shadowRoot)
  );
  shadowRoot.shadowRoot.addEventListener(
    'keydown',
    shadowRoot.saveContent.bind(shadowRoot)
  );
  shadowRoot.textarea.focus();
  shadowRoot.resetButton.click();
  return shadowRoot;
}
CodeSnippet.prototype = Object.create(HTMLElement.prototype, {
  constructor: { value: CodeSnippet },
});
CodeSnippet.prototype.debounce = function (func, wait) {
  let timeout;
  return function () {
    const context = this,
      args = arguments;
    const later = function () {
      timeout = null;
      func.apply(context, args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
};
CodeSnippet.prototype.updateIframe = function () {
  const code = this.textarea.value;
  const newIframe = document.createElement('iframe');
  newIframe.srcdoc = this.iframe.srcdoc;
  this.iframe.parentNode.replaceChild(newIframe, this.iframe);
  const iframeDoc = newIframe.contentDocument;
  iframeDoc.open();
  iframeDoc.write(code);
  this.updateContent(code);
  iframeDoc.close();
  this.iframe = newIframe;
};
CodeSnippet.prototype.reset = function () {
  const srcDoc = this.iframe.srcdoc;
  this.updateContent(srcDoc);
  this.updateIframe();
};
CodeSnippet.prototype.updateContent = function (value) {
  const textarea = this.textarea;
  value = value.replaceAll('      ', '');
  textarea.textContent = value;
  textarea.value = value;
};
CodeSnippet.prototype.saveContent = function (event) {
  if (event.ctrlKey && event.key === 's') {
    event.preventDefault();
    const fileName = this.textarea.value.slice(0, 5);
    const fileContent = this.textarea.value;
    navigator.clipboard.writeText(fileContent);
    const blob = new Blob([fileContent], {
      type: 'text/html',
    });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName + '.html';
    a.click();
    window.URL.revokeObjectURL(url);
  }
};
window.addEventListener('keydown', function (event) {
  if (event.ctrlKey && event.key === 's') {
    event.preventDefault();
  }
});
customElements.define('code-snippet', CodeSnippet);
```

---

### Sử dụng code-snippet đơn giản

Với code-snippet vừa viết, chúng ta có thể sử dụng base như này để tạo một text-editor đơn giản:

```html
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
</style>
<code-snippet></code-snippet>
```

Hoặc có thể bọc một đoạn code html vào và chạy riêng biệt ở trong đó:

```html
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
</style>
<code-snippet>
  <style>
    .active {
      background-color: #faa300;
    }
  </style>
  <div class="container">
    <h1>Hello F8</h1>
  </div>
  <button>Change Theme</button>
  <script>
    const btn = document.querySelector('button');
    btn.addEventListener('click', function () {
      this.previousElementSibling.classList.toggle('active');
    });
  </script>
</code-snippet>
```

Tất nhiên, đó chỉ là một đoạn code tính năng đơn giản để dễ dàng tìm hiểu về custom Element. Có thể tham khảo bản đầy đủ hơn tại **[Đây](https://duongnguyenf8.github.io/demo_custom-element)**

<style>
  * {
    margin: 0;
    padding: 0;
  }
</style>
<iframe
  src="https://duongnguyenf8.github.io/demo_custom-element"
  frameborder="0"
  style="width: 100vw;
   height: 50vh">
</iframe>

---

## Kết luận

Custom Element giúp chúng ta giải quyết nhiều sự việc khó và mang tính chất lặp lại nhiều lần, tuy nhiên không cần lạm dụng quá sâu, với các tính năng nhỏ và dùng 1 lần, nếu tách ra thành custom thì sẽ khó làm hơn, phức tạp hơn

Tuy nhiên khi sử dụng nhiều lần, nhiều nơi và có các sự kiện giống nhau, có thể sử dụng chúng như một custom Element sẽ dễ dàng sửa chữa, nâng cấp hơn.

<!-- Các thao tác với DOM Nodes -->

## DOM Nodes là gì?

`DOM Nodes` là các đối tượng trong DOM (Document Object Model) đại diện cho các phần tử, văn bản, thuộc tính và các thành phần khác trong tài liệu HTML. Các `DOM Nodes` được sử dụng để truy cập và thao tác với các phần tử trong tài liệu HTML.

`DOM Nodes` có thể là các phần tử HTML, văn bản, các nút chú thích, các nút fragment và nhiều loại khác. Mỗi DOM Node có một `nodeType` để xác định loại của nó, ví dụ: `Node.ELEMENT_NODE` cho phần tử HTML, `Node.TEXT_NODE` cho văn bản, `Node.COMMENT_NODE` cho nút chú thích, và nhiều loại khác.

`DOM Nodes` được sử dụng để thực hiện các thao tác như tạo, xóa, di chuyển và thay đổi các phần tử trong cây DOM. Bằng cách sử dụng `DOM Nodes`, chúng ta có thể thay đổi nội dung, thuộc tính và cấu trúc của tài liệu HTML hoặc XML.

### NodeList là gì?

`NodeList` là một tập hợp các `DOM Nodes`, thường được trả về bởi các thuộc tính như `childNodes` hoặc `querySelectorAll()`. Một `NodeList` không phải là một Array, nhưng có thể được lặp qua bằng cách sử dụng phương thức `forEach()` vì nó được định nghĩa một vòng lặp `forEach()` trong prototype. Nó cũng có thể được chuyển đổi thành một Array thực sự bằng cách sử dụng `Array.from()`.

`HTMLCollection` là một loại đặc biệt của `NodeList` và cũng là một tập hợp các `DOM Nodes`. `HTMLCollection` thường chứa các phần tử con của một phần tử HTML cụ thể trong tài liệu. Ví dụ, `document.children` trả về một `HTMLCollection` chứa các phần tử con của phần tử gốc `<html>`. Tuy nhiên, `HTMLCollection` không phải là một Array và không có các phương thức như `forEach()` và cần sử dụng `Array.from()` nếu muốn sử dụng `forEach()`.

Vì `NodeList` và `HTMLCollection` đều là các tập hợp các DOM Nodes, nhưng có một số khác biệt quan trọng. Một khác biệt chính là `NodeList` có thể là live hoặc static. `NodeList` live sẽ tự động cập nhật khi có thay đổi trong DOM, trong khi `NodeList` static không bị ảnh hưởng bởi các thay đổi trong DOM. `HTMLCollection` là một loại `NodeList` live. Khi lặp qua các phần tử trong `NodeList`, cần lưu ý sự khác biệt này và xem xét việc lưu trữ length của danh sách nếu cần thiết.

## Các thao tác với DOM Nodes

### Các phương thức và thuộc tính phổ biến của Node list

- `forEach()`: Lặp qua từng phần tử trong `NodeList` và gọi một hàm `callback` cho mỗi phần tử.

- `item(index)`: Trả về phần tử tại vị trí chỉ định trong `NodeList`. Hoặc có thể sử dụng `[index]`

- `length`: Trả về số lượng phần tử trong `NodeList`.

Ví dụ:

<code-snippet>

```html
<p class="text">Hello F8</p>
<p class="text">Hello F8</p>
<p class="text">Hello F8</p>
<p class="text">Hello F8</p>
<p class="text">Hello F8</p>
<div class="result1" style="color: red">
  Text content của các phần tử p: <br />
</div>
<div class="result2" style="color: green">Text content của phần tử đầu:</div>
<div class="result3" style="color: blue">Có tổng cộng số phần tử p là:</div>
<script>
  const nodeList = document.querySelectorAll('p');
  const res1 = document.querySelector('.result1');
  const res2 = document.querySelector('.result2');
  const res3 = document.querySelector('.result3');

  nodeList.forEach(function (node) {
    res1.innerText += node.textContent + '\n';
  });

  const firstNode = nodeList.item(0);
  res2.innerText += ' ' + firstNode.textContent;

  res3.innerText += nodeList.length;
</script>
```

</code-snippet>

Trong ví dụ trên, chúng ta sử dụng phương thức `querySelectorAll()` để lấy tất cả các phần tử `<p>` trong HTML và trả về một `NodeList`. Sau đó, chúng ta sử dụng phương thức `forEach()` để lặp qua từng phần tử trong `NodeList` và in ra nội dung của mỗi phần tử. Chúng ta cũng sử dụng phương thức `item()` để truy cập phần tử đầu tiên trong `NodeList` và thuộc tính `length` để lấy số lượng phần tử trong `NodeList`.

---

### Các phương thức, thuộc tính trả về Node list

- `childNodes`: Trả về một `NodeList` chứa tất cả các nút con trực tiếp của một phần tử.
- `querySelectorAll(selector)`: Trả về một `NodeList` chứa tất cả các phần tử phù hợp với một bộ chọn CSS được chỉ định.

Ví dụ:

<code-snippet>

```html
<div class="container">
  <p class="text">Hello F8</p>
  <p class="text">Hello F8</p>
  <p class="text">Hello F8</p>
  <p class="text">Hello F8</p>
  <p class="text">Hello F8</p>
</div>
<span class="count" style="color: green">
  Có tổng cộng các phần tử con trực tiếp trong container là:
</span>
<span class="count2" style="color: green">
  Có tổng cộng các phần tử con trực tiếp trong container là:
</span>
<script>
  const container = document.querySelector('.container');
  const childNodes = parent.childNodes;
  const count = document.querySelector('.count');
  count.innerText += ' ' + childNodes.length;

  const elements = parent.querySelectorAll('p');
  const count2 = document.querySelector('.count2');
  count.innerText += ' ' + elements.length;
</script>
```

</code-snippet>

Trong ví dụ trên, chúng ta sử dụng thuộc tính `childNodes` để lấy tất cả các nút con trực tiếp của một phần tử và trả về một `NodeList`. Chúng ta cũng sử dụng phương thức `querySelectorAll()` để lấy tất cả các phần tử `<p>` trong phần tử có class là "container" và trả về một `NodeList`.

---

## Các loại Node chính trong NodeList

Trong DOM, có ba loại node chính là node text, node comment và node element.

---

1. Node Text:

- Node text đại diện cho một đoạn văn bản trong cây DOM.
- Node text được tạo ra bằng cách sử dụng phương thức `createTextNode()` của đối tượng document.
- Để truy cập và sử dụng node text, bạn có thể sử dụng thuộc tính `textContent` hoặc `nodeValue`.
- Node text thường được sử dụng để hiển thị và thay đổi nội dung văn bản của các phần tử trong trang web.

Ví dụ:

<code-snippet>

```html
<h1 class="count">Count:</h1>
<script>
  const counter = document.querySelector('h1');
  const count = document.createTextNode(0);
  counter.append(count);
  setInterval(() => {
    count.nodeValue++;
  }, 1000);
</script>
```

</code-snippet>

---

2. Node Comment:

- Node comment đại diện cho một đoạn comment trong cây DOM.
- Node comment được tạo ra bằng cách sử dụng phương thức `createComment()` của đối tượng document.
- Để truy cập và sử dụng node comment, bạn có thể sử dụng thuộc tính `nodeValue`.
- Node comment thường được sử dụng để chú thích và giải thích mã HTML trong mã nguồn.

Ví dụ:

<code-snippet>

```html
<h1 class="count">Count:</h1>
<script>
  const counter = document.querySelector('h1');
  const count = document.createTextNode(0);
  const comment = document.createComment(count);
  counter.append(count);
  setInterval(() => {
    count.nodeValue++;
    comment.nodeValue++;
  }, 1000);
</script>
```

</code-snippet>

---

3. Node Element:

- Node element đại diện cho một phần tử HTML trong cây DOM.
- Node element được tạo ra bằng cách sử dụng phương thức `createElement()` của đối tượng document.
- Để truy cập và sử dụng node element, bạn có thể sử dụng các phương thức và thuộc tính của nó, chẳng hạn như `appendChild()`, `removeChild()`, `setAttribute()`, `getAttribute()`, `innerHTML`, `textContent`, ...
- Node element được sử dụng để tạo và quản lý các phần tử HTML trong trang web

Ví dụ:

<code-snippet>

```html
<h1 class="count">Count:</h1>
<script>
  const counter = document.querySelector('h1');
  const count = document.createElement('span');
  count.innerText = 0;
  counter.append(count);
  setInterval(() => {
    count.innerText++;
  }, 1000);
  counter.addEventListener('click', () => count.innerText--);
</script>
```

</code-snippet>

---

## Kết luận

Như vậy, các loại node trong DOM (`node text`, `node comment` và và``) đóng vai trò quan trọng trong việc tạo và quản lý cấu trúc và nội dung của trang web. Bằng cách sử dụng các phương thức và thuộc tính của chúng, chúng ta có thể thao tác và tương tác với các phần tử và nội dung trong cây DOM.
