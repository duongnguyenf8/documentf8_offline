# Fullstack NodeJS - Giáo trình chi tiết

## Giới thiệu

**Nguồn gốc của Javascript**: Javascript được tạo ra bởi Brendan Eich vào năm 1995 tại công ty Netscape. Ban đầu, nó được thiết kế để cung cấp tính năng tương tác trên trang web và được đặt tên là "LiveScript". Sau đó, nó đã được đổi tên thành "Javascript" để tận dụng mức độ phổ biến của ngôn ngữ lập trình Java.

**Cú pháp của Javascript**: Cú pháp của Javascript dựa trên các quy tắc cơ bản của ngôn ngữ lập trình như cấu trúc điều kiện, vòng lặp, hàm và **Object**. Nó sử dụng các từ khóa, toán tử và các loại dữ liệu để xây dựng mã.

**Tầm quan trọng của Javascript**: Javascript đóng vai trò quan trọng trong việc phát triển các ứng dụng web động và tương tác. Với Javascript, chúng ta có thể thay đổi, tương tác với các phần tử trên trang web, thực hiện xử lý logic phía client và giao tiếp với máy chủ thông qua các yêu cầu AJAX.

**Sự phát triển của Javascript**: Javascript đã phát triển mạnh mẽ qua nhiều năm với việc xuất hiện các phiên bản tiêu chuẩn mới như ES6 (ECMAScript 2015) và ES7. Các cải tiến và tính năng mới đã làm cho Javascript trở thành một ngôn ngữ lập trình đa dạng và mạnh mẽ.

**Javascript trên các nền tảng**: Ban đầu, Javascript được sử dụng chủ yếu trong môi trường trình duyệt. Tuy nhiên, với sự phát triển của công nghệ, Javascript đã mở rộng sự hiện diện của mình sang các lĩnh vực khác như phát triển ứng dụng di động, ứng dụng máy chủ và Internet of Things (IoT).

**Cộng đồng và hỗ trợ**: Javascript có một cộng đồng lớn và sôi động với hàng ngàn các thư viện và framework hỗ trợ. Cộng đồng này cung cấp nguồn tài nguyên phong phú, các dự án mã nguồn mở và diễn đàn để trao đổi kiến thức và giúp đỡ.

**Tương lai của Javascript**: Javascript vẫn tiếp tục phát triển với nhiều cải tiến và xu hướng mới. Một số xu hướng nổi bật trong tương lai gồm WebAssembly, Progressive Web Apps (PWA), Machine Learning và Artificial Intelligence (AI).

## Phương pháp học lập trình Javascript hiệu quả

**Tìm hiểu từ các nguồn đáng tin cậy**: Để học lập trình Javascript hiệu quả, hãy tìm hiểu từ các nguồn đáng tin cậy như tài liệu chính thức, sách, khóa học trực tuyến và các nguồn học trực quan như video hướng dẫn. Đảm bảo lựa chọn những nguồn có nội dung cập nhật và đáng tin cậy để có kiến thức chính xác và hiện đại nhất.

**Thực hành thường xuyên**: Thực hành là yếu tố quan trọng trong việc học lập trình Javascript. Hãy thực hành thường xuyên để áp dụng kiến thức vào các bài tập và dự án thực tế. Tạo các ví dụ, viết code và chạy để thấy kết quả trực tiếp. Thực hành sẽ giúp chúng ta làm quen với cú pháp, logic và phát triển kỹ năng thực tế.

**Xây dựng dự án thực tế**: Xây dựng dự án thực tế là một phương pháp học lập trình Javascript hiệu quả. chúng ta có thể tạo các ứng dụng nhỏ, trang web đơn giản hoặc tham gia các dự án mã nguồn mở để áp dụng và rèn kỹ năng của mình. Việc xây dựng dự án thực tế sẽ giúp chúng ta áp dụng toàn bộ quá trình phát triển ứng dụng, từ lên kế hoạch, thiết kế, viết code và kiểm thử.

**Thảo luận và hợp tác**: Thảo luận với cộng đồng lập trình viên Javascript khác và hợp tác trong các dự án là một cách tuyệt vời để học lập trình hiệu quả. Tham gia vào các diễn đàn, nhóm trò chuyện và cộng đồng trực tuyến để trao đổi kiến thức, hỏi đáp câu hỏi và nhận được sự giúp đỡ từ người khác. Hợp tác với những người có kinh nghiệm sẽ giúp chúng ta nâng cao kỹ năng và khám phá những phương pháp mới.

**Đọc và viết code nguồn mở**: Đọc và viết code nguồn mở là một cách tuyệt vời để học lập trình Javascript. Khám phá các dự án mã nguồn mở, đọc mã nguồn, hiểu cách các lập trình viên giải quyết các vấn đề và học từ kinh nghiệm của họ. Đồng thời, hãy tham gia đóng góp vào các dự án mã nguồn mở để rèn kỹ năng và xây dựng danh tiếng trong cộng đồng.

**Theo dõi các xu hướng và cập nhật**: Ngôn ngữ lập trình Javascript không ngừng phát triển và có những xu hướng mới liên tục xuất hiện. Hãy theo dõi các xu hướng mới, các tính năng và cập nhật của ngôn ngữ để không bỏ lỡ những thay đổi quan trọng và tận dụng những cải tiến mới nhất.

## Kiến thức cơ bản

1. **3 cách tích hợp Javascript vào trang web**:

## Cách 1: internal Javascript

1. Tạo một thẻ `<script>` trong phần `<head>` hoặc `<body>` của trang HTML.

2. viết code Javascript trong thẻ `<script>`.

 <htmlcss-snippet>

```html
<button id="btn">Run code</button>
<script>
	const btn = document.getElementById('btn');
	btn.addEventListener('click', () => {
		alert('Xin chào!');
	});
</script>
```

 </htmlcss-snippet>

---

## Cách 2: external Javascript

1. Tạo một tệp Javascript với phần mở rộng `.js`.
2. viết code Javascript trong tệp đó.
3. Link tới tệp Javascript bằng thuộc tính `src` của thẻ `<script>`.

```html
<button id="btn">Run code</button>

<script src="./script.js"></script>
```

```js
// script.js
const btn = document.getElementById('btn');
button.addEventListener('click', () => {
	alert('Xin chào!');
});
```

---

## Cách 3: inline Javascript

1. Tạo một thẻ `<script>` trong phần `<head>` hoặc `<body>` của trang HTML.
2. viết code Javascript trong thẻ `<script>`.
3. Gắn kết các đoạn code Javascript với các sự kiện và hành động trên trang.

<htmlcss-snippet>

```html
<button onclick=" alert('Xin chào!');">Say Hello!</button>
```

</htmlcss-snippet>

---

2. **Làm việc với biến trong Javascript**:

## Khai báo biến bằng từ khóa `var`, `let`, hoặc `const`:

```javascript
var x; // Khai báo biến x bằng từ khóa var
let y; // Khai báo biến y bằng từ khóa let
const z; // Khai báo biến z bằng từ khóa const
```

---

## Gán giá trị cho biến bằng toán tử gán `=`:

```javascript
var x = 5; // Gán giá trị 5 cho biến x
let y = 'Hello'; // Gán giá trị "Hello" cho biến y
const z = true; // Gán giá trị true cho biến z
```

---

## Thay đổi giá trị của biến trong quá trình thực thi:

1. Biến được khai báo bằng từ khóa `var` có thể thay đổi giá trị và khai báo lại.
2. Biến được khai báo bằng từ khóa `let` có thể thay đổi giá trị nhưng không thể khai báo lại.
3. Biến được khai báo bằng từ khóa `const` không thể thay đổi giá trị và khai báo lại.

```javascript
var x = 5;

x = 10; // Thay đổi giá trị của biến x thành 10

console.log(x); // In ra giá trị của biến x là 10

let y = 'Hello';

y = 'Hi'; // Thay đổi giá trị của biến y thành "Hi"

console.log(y); // In ra giá trị của biến y là "Hi"

const z = true;

z = false; // Lỗi: Không thể thay đổi giá trị của biến z

console.log(z); // In ra giá trị của biến z là true
```

---

3. **Tìm hiểu về phạm vi trong Javascript**:

## Khái niệm phạm vi (Scope)

Phạm vi của biến trong Javascript có thể là toàn cục (global) hoặc cục bộ (local). Biến toàn cục có thể truy cập từ bất kỳ đâu trong chương trình, trong khi biến cục bộ chỉ có thể truy cập trong phạm vi của nó (ví dụ: hàm).

---

## Phạm vi biến cục bộ (Local)

- Biến được khai báo trong một hàm có phạm vi cục bộ chỉ sử dụng được trong hàm đó. Nghĩa là biến sẽ không được truy cập từ bên ngoài hàm đó. Ví dụ:

  ```javascript
  function myFunction() {
  	var x = 5; // Biến x có phạm vi cục bộ trong hàm myFunction
  	console.log(x); // Output: 5
  }

  myFunction();
  console.log(x); // Lỗi: x is not defined
  ```

---

## Phạm vi biến toàn cục (Global)

Trong ví dụ trên, biến `x` được khai báo trong hàm `myFunction`, nên chỉ có thể truy cập được trong hàm đó. Khi cố gắng truy cập biến `x` bên ngoài hàm, sẽ xảy ra lỗi "x is not defined" vì biến đó không tồn tại trong phạm vi đó.

- Biến được khai báo bên ngoài các hàm, hoặc bên ngoài phạm vi bất kỳ hàm nào, có phạm vi toàn cục. Điều này có nghĩa là biến có thể truy cập được từ bất kỳ đâu trong chương trình. Ví dụ:

  ```javascript
  var x = 10; // Biến x có phạm vi toàn cục

  function myFunction() {
  	console.log(x); // Output: 10
  }

  myFunction();
  console.log(x); // Output: 10
  ```

  Trong ví dụ trên, biến `x` được khai báo bên ngoài hàm, nên có phạm vi toàn cục. Điều này cho phép biến `x` có thể truy cập từ bất kỳ đâu trong chương trình, bao gồm cả bên trong hàm `myFunction`.

## Lưu ý khi sử dụng biến toàn cục và cục bộ

- Có thể khai báo các biến `global` bằng từ khóa `const`, `let` hoặc `var`. Tuy nhiên:
  - Nếu các biến cục bộ không hề thay đổi thì nên sử dụng từ khóa `const` để khai báo.
  - Nếu các biến cục bộ có thay đổi thì nên sử dụng từ khóa `let` hoặc `var` để khai báo.

---

4. **Tìm hiểu 1 số hàm hay dùng**:

## Hàm `alert()`

- `alert()`: Hàm `alert()` được sử dụng để hiển thị một thông báo cho người dùng trong một hộp thoại. Ví dụ:

  <htmlcss-snippet>

  ```html
  <button id="btn">Run code</button>
  <script>
  	const btn = document.getElementById('btn');
  	btn.addEventListener('click', () => {
  		alert('Xin chào!');
  	});
  </script>
  ```

  </htmlcss-snippet>

---

## Hàm `confirm()`

- `confirm()`: Hàm `confirm()` được sử dụng để hiển thị một hộp thoại xác nhận và trả về giá trị `true` hoặc `false` tùy thuộc vào việc người dùng nhấn OK hay Hủy bỏ. Ví dụ:

  <htmlcss-snippet>

  ```html
  <button id="btn">Run code</button>
  <script>
  	const btn = document.getElementById('btn');
  	btn.addEventListener('click', () => {
  		var result = confirm('chúng ta có chắc chắn muốn xóa?');
  		if (result === true) {
  			alert('Người dùng đã chọn OK');
  		} else {
  			alert('Người dùng đã chọn Hủy bỏ');
  		}
  	});
  </script>
  ```

  </htmlcss-snippet>

---

## Hàm `setTimeout()`

- `setTimeout()`: Hàm `setTimeout()` được sử dụng để thực thi một hàm sau một khoảng thời gian nhất định. Ví dụ:

  <htmlcss-snippet>

  ```html
  <button id="btn">Run code</button>
  <script>
  	const btn = document.getElementById('btn');
  	btn.addEventListener('click', () => {
  		setTimeout(function () {
  			alert('Xin Chào!');
  			// Sau 500ms thì hộp thoại sẽ hiển thị
  		}, 500);
  	});
  </script>
  ```

  </htmlcss-snippet>

---

## Hàm `setInterval()`

- `setInterval()`: Hàm `setInterval()` được sử dụng để thực thi một hàm lặp đi lặp lại sau một khoảng thời gian nhất định. Ví dụ:

   <htmlcss-snippet>

  ```html
  <button id="btn">Run code</button>
  <span id="number">0</span>
  <script>
  	const btn = document.getElementById('btn');
  	let number = document.getElementById('number');
  	let counter = parseInt(number.innerText);
  	// Lấy giá trị hiện tại của thẻ span dưới dạng số nguyên
  	btn.addEventListener('click', () => {
  		setInterval(function () {
  			++counter;
  			number.innerText = counter;
  		}, 1000);
  		// Sau mỗi 1000ms, thẻ span sẽ được cập nhật giá trị mới
  	});
  </script>
  ```

   </htmlcss-snippet>

5. **Toán tử và biểu thức**:

## Toán tử

Toán tử là các ký hiệu được sử dụng để thực hiện các phép tính hoặc thao tác trên các giá trị. Ví dụ:

Toán tử số học: `+` (cộng), `-` (trừ), `*` (nhân), `**` (lũy thừa), `/` (chia), `%` (chia lấy dư).

Toán tử gán: `=` (gán giá trị), `+=` (cộng và gán), `-=` (trừ và gán), `*=` (nhân và gán), `/=` (chia và gán).

Toán tử so sánh: `==` (bằng nhau), `!=` (không bằng), `>` (lớn hơn), `<` (nhỏ hơn), `>=` (lớn hơn hoặc bằng), `<=` (nhỏ hơn hoặc bằng).

Toán tử logic: `&&` (và), `||` (hoặc), `!` (phủ định).

Và nhiều toán tử khác như toán tử chuỗi, toán tử ba ngôi, toán tử truy xuất thuộc tính, v.v.

---

## Biểu thức

Biểu thức là sự kết hợp của các giá trị, biến và toán tử để tạo thành một giá trị mới. Biểu thức có thể được sử dụng trong các câu lệnh, khai báo biến, điều kiện, vòng lặp, v.v. Ví dụ:

---

## Ví dụ

<htmlcss-snippet>

```html
<button id="btn">Run code</button>
<span id="result">0</span>
<script>
	const number1 = 10,
		number2 = 5,
		number3 = 2;
	const btn = document.getElementById('btn');
	btn.addEventListener('click', () => {
		const sum = number1 + number2 + number3;
		const sub = number1 - number2 - number3;
		const mul = number1 * number2 * number3;
		const div = number1 / number2 / number3;
		document.getElementById(
			'result'
		).innerText = `Tổng: ${sum}, Hiệu: ${sub}, Tích: ${mul}, Thương: ${div}`;
	});
</script>
```

</htmlcss-snippet>

Trong ví dụ trên, chúng ta khai báo ba biến `number1`, `number2` và `number3` có giá trị lần lượt là 10, 5 và 2. Sau đó, chúng ta sử dụng các biến này để tính tổng, hiệu, tích và thương của chúng. Cuối cùng, chúng ta hiển thị kết quả lên trang web.

6. **Toán tử 3 ngôi**:

## Toán tử 3 ngôi

- Toán tử 3 ngôi (`condition ? expr1 : expr2`) được sử dụng để thực hiện một phép gán hoặc trả về giá trị dựa trên một điều kiện. Cú pháp của toán tử 3 ngôi gồm ba phần:

  - `condition`: Điều kiện được đánh giá. Nếu điều kiện là `true`, thì giá trị của biểu thức sẽ là `expr1`, ngược lại, giá trị sẽ là `expr2`.
  - `expr1`: Giá trị được trả về nếu điều kiện là `true`.
  - `expr2`: Giá trị được trả về nếu điều kiện là `false`.

- Toán tử 3 ngôi rất hữu ích khi muốn thực hiện một phép gán hoặc trả về giá trị dựa trên một điều kiện một cách ngắn gọn.

---

## Ví dụ

<htmlcss-snippet>

```html
<button id="btn">Run code</button>
<p>chúng ta đang: <span id="result"></span></p>
<script>
	const btn = document.getElementById('btn');
	btn.addEventListener('click', () => {
		const isCoding = confirm('chúng ta có đang lập trình không?');
		const result = isCoding ? 'Coding' : 'Fix bugs...';
		document.getElementById('result').innerText = result;
	});
</script>
```

</htmlcss-snippet>
  
Trong ví dụ trên, chúng ta sử dụng hàm `confirm()` để hiển thị một hộp thoại xác nhận và trả về giá trị `true` hoặc `false` tùy thuộc vào việc người dùng nhấn OK hay Hủy bỏ. Sau đó, chúng ta sử dụng toán tử 3 ngôi để gán giá trị cho biến `result` dựa trên giá trị trả về của hàm `confirm()`. Cuối cùng, chúng ta hiển thị giá trị của biến `result` lên trang web.

---

7. **Toán tử Nullish (`??`)**:

## Toán tử Nullish

- Toán tử Nullish (`??`) được sử dụng để kiểm tra xem một giá trị có là null hoặc undefined không. Nếu giá trị đó là null hoặc undefined, giá trị sau toán tử sẽ được sử dụng.

- Toán tử Nullish khác với toán tử OR (`||`) trong cách xử lý giá trị mặc định. Trong trường hợp sử dụng toán tử OR, nếu giá trị đầu tiên được coi là "falsy" (giá trị sai), giá trị sau toán tử sẽ được sử dụng dù giá trị đó là null, undefined, false, 0 hoặc rỗng. Trong khi đó, toán tử Nullish chỉ coi null và undefined là "falsy".

---

## Ví dụ

- Trong ví dụ đầu tiên, `var totalCount = count ?? defaultCount;` sử dụng toán tử nullish coalescing (??). Toán tử này kiểm tra giá trị của biến `count`. Nếu `count` có giá trị nullish (null hoặc undefined), thì giá trị của biến `totalCount` sẽ là `defaultCount`. Trong trường hợp này, `count` có giá trị là 0, không phải là null hoặc undefined, nên giá trị của `totalCount` sẽ là 0.

- Trong ví dụ thứ hai, `var totalCount = count || defaultCount;` sử dụng toán tử OR (||). Toán tử này kiểm tra giá trị của biến `count`. Nếu `count` có giá trị falsy (false, 0, rỗng, null hoặc undefined), thì giá trị của biến `totalCount` sẽ là `defaultCount`. Trong trường hợp này, `count` có giá trị là 0, là một giá trị falsy, nên giá trị của `totalCount` sẽ là 10.

```javascript
var count = 0;
var defaultCount = 10;
var totalCount = count ?? defaultCount;
console.log(totalCount); // In ra 0

var count = 0;
var defaultCount = 10;
var totalCount = count || defaultCount;
console.log(totalCount); // In ra 10
```

<htmlcss-snippet>

```html
<button id="btn">Run code</button>
<p id="result"></p>
<script>
	const btn = document.getElementById('btn');
	btn.addEventListener('click', () => {
		const count = 0;
		const defaultCount = 10;
		const totalCount = count ?? defaultCount;
		document.getElementById('result').innerText = totalCount;
	});
</script>
```

</htmlcss-snippet>

---

8. Câu lệnh rẽ nhánh:

## if() else if() else

1. `if else`: Sử dụng để thực thi các khối code dựa trên một điều kiện.

---

2. Ví dụ về `if else`:

<htmlcss-snippet>

```html
<button id="btn">Run code</button>

<script>
	const btn = document.getElementById('btn');
	btn.addEventListener('click', () => {
		const age = prompt('Nhập tuổi của chúng ta:');
		if (age < 18) {
			alert('chúng ta chưa đủ tuổi để xem nội dung này!');
		} else if (age >= 18 && age < 30) {
			alert('chúng ta đã đủ tuổi để xem nội dung này!');
		} else {
			alert('chúng ta đã quá tuổi để xem nội dung này!');
		}
	});
</script>
```

</htmlcss-snippet>

---

## switch case

1. `switch case`: Sử dụng để thực thi các khối code dựa trên nhiều điều kiện khác nhau.

---

2. Ví dụ về `switch case`:

<htmlcss-snippet>

```html
<button id="btn">Run code</button>

<script>
	const btn = document.getElementById('btn');
	btn.addEventListener('click', () => {
		const number = prompt('Nhập số chúng ta muốn:');
		switch (number) {
			case '1':
				alert('chúng ta đã nhập số 1');
				break;
			case '2':
				alert('chúng ta đã nhập số 2');
				break;
			case '3':
				alert('chúng ta đã nhập số 3');
				break;
			default:
				alert('chúng ta đã nhập số khác 1, 2, 3');
		}
	});
</script>
```

</htmlcss-snippet>

9. **Truthy và Falsy**:

## Truthy và Falsy

- Trong Javascript, một giá trị được coi là truthy nếu nó có thể đánh giá thành true và falsy nếu nó có thể đánh giá thành false.

- Các giá trị falsy **thông thường** bao gồm: `false`, `0`, `''` (chuỗi rỗng), `null`, `undefined`, và `NaN`. Các giá trị còn lại được coi là truthy.

- Khi một giá trị falsy hoặc truthy được sử dụng trong một điều kiện, JavaScript sẽ tự động chuyển đổi giá trị đó thành kiểu boolean để đánh giá điều kiện.

**Vì sao lại nói là thông thường?**

Trên thực tế, các giá trị falsy và truthy không chỉ bao gồm các giá trị được liệt kê ở trên. Các giá trị falsy và truthy có thể được định nghĩa bởi các đối tượng, hàm, v.v. Tuy nhiên, trong phạm vi bài viết này, chúng ta chỉ tập trung vào các giá trị falsy và truthy thông thường.

Các giá trị khác bao gồm:

- -0: Số không âm, bao gồm cả -0.0, -0x0, v.v.

- 0n: BigInt zero, bao gồm cả 0x0n, v.v. Lưu ý rằng không có BigInt zero âm - phủ định của 0n là 0n.

- document.all: Đối tượng falsy duy nhất trong JavaScript là document.all tích hợp, mặc dù nó không phải là một giá trị.

---

## Ví dụ về truthy và falsy:

1. Ví dụ về truthy và falsy:

```javascript
a = 0; // Giá trị falsy
b = false; // Giá trị falsy
c = ''; // Giá trị falsy
d = null; // Giá trị falsy
e = undefined; // Giá trị falsy
f = NaN; // Giá trị falsy
```

2.  Trong ví dụ trên, các biến `a`, `b`, `c`, `d`, `e` và `f` có giá trị lần lượt là 0, false, "", null, undefined và NaN. Tất cả các giá trị này đều là falsy. Còn lại, tất cả các giá trị khác đều là truthy.

---

## Tác dụng của truthy và falsy

Điều này rất hữu ích khi chúng ta muốn kiểm tra xem một biến có tồn tại hay không, hoặc kiểm tra xem một giá trị đã được gán hay chưa trước khi sử dụng nó trong các câu lệnh điều kiện.

---

10. **Định nghĩa hàm**:

## Hàm

Trong Javascript, hàm là một khối code được đặt tên, có thể được gọi để thực hiện một tác vụ cụ thể.

Cú pháp định nghĩa hàm: `function functionName(parameters) { // code }`

Một hàm có thể có các tham số (parameters) để nhận đầu vào và có thể có một hoặc nhiều dòng code để thực hiện công việc mong muốn.

Khi một hàm được gọi, code bên trong hàm sẽ được thực thi.

---

## Hàm có tên

1. **Hàm có tên**: Đây là loại hàm thông thường được đặt tên và được sử dụng để thực hiện một công việc cụ thể.

   1.1 Khi cần thực hiện một tác vụ cụ thể nhiều lần trong chương trình, chúng ta có thể định nghĩa một hàm có tên để thực hiện tác vụ đó. Khi cần thực hiện tác vụ đó, chúng ta chỉ cần gọi hàm đó.

2. Ví dụ:

```javascript
function hello(name) {
	// Định nghĩa hàm hello với tham số name
	console.log(`Xin chào, ${name}!`); // In ra một thông điệp chào mừng khi hàm được gọi
}
hello('F8'); // Gọi hàm hello với tham số là "F8" truyền vào tham số tương ứng, ở đây là name
hello('Fullstack'); // Gọi hàm hello với tham số là "Fullstack" truyền vào tham số tương ứng, ở đây là name
```

3. Kết quả:

```shell
Xin chào, F8!
```

Trong ví dụ trên, chúng ta định nghĩa một hàm tên là `hello` với một tham số `name`. Hàm này được sử dụng để in ra một thông điệp chào mừng với tên được truyền vào. Khi gọi hàm `hello('F8')`, chúng ta nhận được kết quả "Xin chào, F8!".

Hàm có tên có thể được gọi nhiều lần với các tham số khác nhau. Nó rất hữu ích khi chúng ta muốn thực hiện một tác vụ cụ thể nhiều lần trong chương trình.

---

## Hàm ẩn danh

1. **Hàm ẩn danh**: Hàm ẩn danh là một hàm không có tên và thường được sử dụng như một đối số cho một hàm khác.

   1.1 Khi cần thực hiện một tác vụ cụ thể một lần duy nhất trong chương trình, chúng ta có thể định nghĩa một hàm ẩn danh để thực hiện tác vụ đó. Hàm ẩn danh thường được sử dụng như một đối số cho một hàm khác hay còn gọi là (`callback`)

2. Ví dụ:

```javascript
const numbers = [1, 2, 3, 4, 5]; // Khai báo một biến numbers và gán luôn cho nó là một mảng
numbers.forEach(function (number) {
	// Sử dụng phương thức forEach để lặp qua từng phần tử trong mảng numbers
	// forEach nhận vào một function, ở đây là một hàm ẩn danh (không có tên)
	console.log(number * 2); // In ra giá trị của phần tử nhân đôi khi lặp qua từng phần tử
});
```

3. Kết quả:

```shell
2
4
6
8
10
```

Trong ví dụ trên, chúng ta sử dụng phương thức `forEach` để lặp qua từng phần tử trong mảng `numbers`. Chúng ta truyền một hàm ẩn danh
(không có tên) vào phương thức `forEach`, và hàm này được gọi cho mỗi phần tử trong mảng để in ra giá trị của phần tử nhân đôi.

Hàm ẩn danh có thể được sử dụng nhiều lần trong chương trình. Nó rất hữu ích khi chúng ta muốn thực hiện một tác vụ cụ thể mà không cần phải
định nghĩa một hàm có tên.

---

## Hàm nặc danh

1. **Hàm nặc danh**: Hàm nặc danh là một hàm không có tên, nhưng được gán cho một biến để có thể được sử dụng lại.

   1.1 Khi cần thực hiện một tác vụ cụ thể một lần duy nhất trong chương trình, chúng ta có thể định nghĩa một hàm nặc danh để thực hiện tác vụ đó. Hàm nặc danh thường được gán cho một biến để có thể được sử dụng lại.

2. Ví dụ:

```javascript
const add = function (a, b) {
	// Khai báo 1 biến add và gán cho nó là một hàm ẩn danh (không có tên)
	return a + b; // Trả về kết quả của phép cộng a + b khi hàm được gọi
};
const result = add(5, 3); // Gọi hàm add với tham số là 5 và 3, lưu kết quả vào biến result
const result2 = add(10, 20); // Gọi hàm add với tham số là 10 và 20, lưu kết quả vào biến result2
console.log(result); // In ra kết quả của phép cộng 5 + 3
```

3. Kết quả:

```shell
8
```

Trong ví dụ trên, chúng ta định nghĩa một hàm nặc danh và gán nó cho biến `add`. Hàm này thực hiện phép cộng hai số và trả về kết quả. Sau đó, chúng ta gọi hàm bằng cách sử dụng biến `add` và lưu kết quả vào biến `result`.

Hàm nặc danh có thể được sử dụng nhiều lần trong chương trình. Nó rất hữu ích khi chúng ta muốn thực hiện một tác vụ cụ thể mà không cần phải định nghĩa một hàm có tên.

---

## Hàm lambda

1. **Hàm lambda**: Hàm lambda (còn được gọi là hàm vô danh hoặc hàm nặc danh ngắn gọn) là một cú pháp viết gọn của hàm nặc danh.

   1.1 Khi cần thực hiện một tác vụ cụ thể một lần duy nhất trong chương trình, chúng ta có thể định nghĩa một hàm lambda để thực hiện tác vụ đó. Hàm lambda thường được gán cho một biến để có thể được sử dụng lại.

2. Ví dụ:

```javascript
const multiply = (a, b) => a * b; // Khai báo 1 biến multiply và gán cho nó là một hàm lambda (hàm vô danh)
const result = multiply(4, 6); // Gọi hàm multiply với tham số là 4 và 6, lưu kết quả vào biến result
const result2 = multiply(10, 20); // Gọi hàm multiply với tham số là 10 và 20, lưu kết quả vào biến result2
console.log(result); // In ra kết quả của phép nhân 4 * 6
```

3. Kết quả:

```shell
24
```

Trong ví dụ trên, chúng ta sử dụng cú pháp hàm lambda `(a, b) => a * b` để định nghĩa một hàm nhân hai số với nhau. Chúng ta gọi hàm bằng cách sử dụng biến `multiply` và lưu kết quả vào biến `result`.

Hàm lambda có thể được sử dụng nhiều lần trong chương trình. Nó rất hữu ích khi chúng ta muốn thực hiện một tác vụ cụ thể mà không cần phải định nghĩa một hàm có tên.

Hàm lambda khác với hàm nặc danh ở chỗ nó không có từ khóa `function` và không có tên. Nó cũng khác với hàm nặc danh ở chỗ nó không có thể truy cập được vào `this` và `arguments`.

---

## Hàm callback

1. **Callback**: Callback là một hàm được truyền vào như một đối số cho một hàm khác để được gọi lại sau một sự kiện hoặc một thao tác nào đó.

   1.1 Thực hiện một tác vụ bất đồng bộ (asynchronous) thì phải sử dụng callback để đảm bảo rằng tác vụ đó sẽ được thực hiện sau khi tác vụ bất đồng bộ hoàn thành.

2. Ví dụ:

```javascript
function calculate(a, b, callback) {
	// Định nghĩa hàm calculate nhận vào 2 số và một hàm callback
	const result = a + b; // Thực hiện phép tính a + b
	callback(result);
	// Gọi hàm được truyền vào calculate (callback) để sử dụng hàm callback (displayResult) ở trong hàm calculate
}
function displayResult(value) {
	// Định nghĩa hàm displayResult nhận vào một tham số value
	console.log(`Kết quả là: ${value}`); // In ra kết quả của phép tính a + b
}
calculate(3, 5, displayResult); // Gọi hàm calculate với 3 tham số là 3 (a), 5 (b) và hàm displayResult (callback)
```

3. Kết quả:

```shell
Kết quả là: 8
```

Trong ví dụ trên, chúng ta định nghĩa một hàm `calculate` nhận vào hai số `a` và `b`, và một hàm `callback`. Hàm `calculate` thực hiện phép tính và sau đó gọi hàm `callback` với kết quả. Chúng ta định nghĩa một hàm `displayResult` để hiển thị kết quả. Khi gọi `calculate(3, 5, displayResult)`, kết quả "Kết quả là: 8" được in ra.

Hàm callback có thể được sử dụng nhiều lần trong chương trình. Nó rất hữu ích khi chúng ta muốn thực hiện một tác vụ cụ thể mà không cần phải định nghĩa một hàm có tên.

---

## Hàm Closure

1. **Closure**: Closure là một hàm có thể truy cập và sử dụng biến trong phạm vi của nó và phạm vi của hàm bao bọc nó.

   1.1 Closure có thể được sử dụng để tạo ra các biến ẩn (private variables) và các phương thức ẩn (private methods).

   1.2 Closure có thể được sử dụng để tạo ra các hàm có thể tái sử dụng (reusable functions).

2. Ví dụ:

```javascript
function outer() {
	// Định nghĩa hàm outer
	const message = 'Hello'; // Khai báo biến message trong hàm outer và gán giá trị là "Hello"
	function inner() {
		// Định nghĩa hàm inner trong hàm outer
		console.log(message); // In ra giá trị của biến message trong hàm outer
	}
	return inner; // Trả về hàm inner trong hàm outer khi hàm outer được gọi
}
const innerFunction = outer(); // Gán kết quả của hàm outer cho biến innerFunction
innerFunction(); // Gọi hàm innerFunction
```

3. Kết quả:

```shell
Hello
```

Trong ví dụ trên, chúng ta định nghĩa một hàm `outer` chứa một biến `message` và một hàm `inner`. Hàm `inner` có thể truy cập biến `message` trong phạm vi của `outer`. Sau đó, chúng ta gán kết quả của hàm `outer` cho biến `innerFunction` và gọi `innerFunction()`, dẫn đến việc in ra kết quả "Hello".

Hàm closure có thể được sử dụng nhiều lần trong chương trình. Nó rất hữu ích khi chúng ta muốn thực hiện một tác vụ cụ thể mà không cần phải định nghĩa một hàm có tên.

---

## Kết luận

Hàm là một khái niệm quan trọng và không thể thiếu trong bất kỳ ngôn ngữ lập trình nào. Trong Javascript, hàm có thể được định nghĩa bằng nhiều cách khác nhau, bao gồm hàm có tên, hàm ẩn danh, hàm nặc danh và hàm lambda... Mỗi loại hàm có những ứng dụng khác nhau và có thể được sử dụng trong các trường hợp khác nhau. Tuy nhiên chúng đều cùng một mục đích là thực hiện một tác vụ cụ thể khi được gọi.

---

5. **Giải thuật đệ quy trong lập trình**:

## Đệ quy là gì?

> Liệu đệ quy có phải là em con rùa?

> Recursive (đệ quy) là một khái niệm khá **đơn giản** mà chúng ta đã tiếp xúc từ toán lớp 3:
> ![image.png](https://files.fullstack.edu.vn/f8-prod/public-images/64a2441837afe.png)

Đệ quy là quá trình một hàm gọi lại chính nó trong quá trình thực thi.

Giải thuật đệ quy thường được sử dụng để giải quyết các bài toán có tính chất lặp đi lặp lại.

Giải thuật đệ quy có thể được áp dụng trong các bài toán phức tạp như tìm kiếm trong cây (tree traversal), tính giai thừa, tìm kiếm đường đi trong đồ thị, và nhiều bài toán khác.

Khi sử dụng đệ quy, chúng ta cần chắc chắn có điều kiện dừng để tránh lặp vô hạn và cẩn thận với việc quản lý bộ nhớ.

Đệ quy có rất nhiều loại:

- Đệ quy tuyến tính (Linear recursion): Một hàm gọi lại chính nó một lần.
- Đệ quy nhị phân (Binary recursion): Một hàm gọi lại chính nó hai lần.
- Đệ quy đa tuyến (Multiple recursion): Một hàm gọi lại chính nó nhiều lần.
- Đệ quy lồng nhau (Nested recursion): Một hàm gọi lại chính nó với tham số là một lời gọi hàm khác.

Khử đệ quy là quá trình chuyển đổi một giải thuật đệ quy thành một giải thuật không đệ quy.

- Hay là một kỹ thuật để thay thế đệ quy bằng vòng lặp mà không ảnh hưởng đến kết quả của giải thuật.
- Khử đệ quy được sử dụng để giảm bớt thời gian thực thi và bộ nhớ cần thiết cho giải thuật. (Giải quyết vấn đề performance)

---

## Ví dụ về giải thuật đệ quy

Ở đây, chúng ta định nghĩa một hàm `countdown` sử dụng giải thuật đệ quy để in ra các số từ `n` đến 1, sau đó in ra thông báo "Hết!". Hàm `countdown` gọi lại chính nó với tham số `n - 1` cho đến khi `n` nhỏ hơn hoặc bằng 0.

  <htmlcss-snippet>

```html
<button id="btn">Run code</button>
<ul id="result"></ul>
<script>
	const btn = document.getElementById('btn');
	btn.addEventListener('click', () => {
		const n = prompt('Nhập một số nguyên dương:');
		countdown(n);
	});

	function countdown(n) {
		const result = document.getElementById('result');
		const li = document.createElement('li');
		li.innerText = n;
		result.appendChild(li);
		if (n <= 0) {
			const li = document.createElement('li');
			li.innerText = 'Hết!';
			result.appendChild(li);
		} else {
			countdown(n - 1);
		}
	}
</script>
```

  </htmlcss-snippet>

---

## Sử dụng

1. Sử dụng giải thuật đệ quy khi:

- Các bài toán có tính chất lặp đi lặp lại.
- Các bài toán có tính chất phân chia và trị.
- Các bài toán có tính chất quay lui.
- Các bài toán có tính chất quy hoạch động.
- Các bài toán có tính chất tham lam.
- Các bài toán có tính chất nhánh cận.

2. Sử dụng đệ quy trong một bài toán thực tế:

Khi API trả về một mảng trong đó có nhiều mảng con, mỗi mảng con có thể có mảng con với key là children, trong các children có thể có các children khác, và cứ tiếp tục như vậy. Ví dụ như một `Menu đa cấp` có nhiều `Menu con` và `Menu con` có thể có nhiều `Menu con` khác nữa.

Ví dụ:

<htmlcss-snippet>

```html
<button id="btn">Run code</button>
<div id="menu"></div>
<script>
	const btn = document.getElementById('btn');
	const menu = [
		{
			id: 1,
			name: 'Menu 1',
			children: [
				{
					id: 2,
					name: 'Menu 1.1',
					children: [
						{
							id: 3,
							name: 'Menu 1.1.1',
							children: [
								{
									id: 4,
									name: 'Menu',
								},
							],
						},
					],
				},
				{
					id: 5,
					name: 'Menu 1.2',
				},
			],
		},
		{
			id: 6,
			name: 'Menu 2',
		},
		{
			id: 7,
			name: 'Menu 3',
			children: [
				{
					id: 8,
					name: 'Menu 3.1',
				},
			],
		},
	];
	function renderMenu(menu) {
		let html = '<ul>';
		for (let i = 0; i < menu.length; i++) {
			html += `<li>${menu[i].name}</li>`;
			if (menu[i].children) {
				html += renderMenu(menu[i].children);
			}
		}
		html += '</ul>';
		return html;
	}
	btn.addEventListener('click', () => {
		const menuElement = document.getElementById('menu');
		menuElement.innerHTML = renderMenu(menu);
	});
</script>
```

</htmlcss-snippet>

---

## Kết luận

Giải thuật đệ quy là một trong những cách thức để giải quyết vấn đề có tính chất lặp lại một cách nhanh gọn, tuy nhiên vấn đề hiệu năng và bộ nhớ của nó rất kém. Vì vậy cần chú ý trước khi sử dụng để giải quyết vấn đề. Nếu có thể, nên khử đệ quy để giúp nâng cao hiệu năng và giảm bớt bộ nhớ cần thiết cho giải thuật.

Tuy vậy, cả với lập trình backend hay frontend, đặc biệt là React, đệ quy vẫn được sử dụng khá nhiều. Ví dụ như trong React, chúng ta có thể sử dụng đệ quy để render ra các component có tính chất lặp lại như Menu đa cấp, Tree, v.v.

Vì vậy, đệ quy vẫn là một trong những kiến thức cần thiết cho một dự án thực tế và được hỏi khi phỏng vấn.

---

4. **Vòng lặp**:

## Vòng lặp là gì?

- Trong Javascript, vòng lặp là một khối code được thực thi nhiều lần cho đến khi một điều kiện được thỏa mãn.

- Các vòng lặp thường được sử dụng để thực hiện các tác vụ lặp đi lặp lại, duyệt qua mảng, tìm kiếm, và nhiều tác vụ khác.

## Các vòng lặp thông dụng trong Javascript

Các vòng lặp thông dụng trong `javascript` bao gồm:

1: `for`: Sử dụng để lặp qua một khối code một số lần đã xác định trước.

- Cú pháp: `for (initialization; condition; final-expression) { // code }`

2: `while`: Sử dụng để lặp qua một khối code miễn là một điều kiện được thỏa mãn.

- Cú pháp: `while (condition) { // code }`

3: `do while`: Sử dụng để lặp qua một khối code ít nhất một lần và sau đó tiếp tục lặp miễn là một điều kiện được thỏa mãn.

- Cú pháp: `do { // code } while (condition)`

### Các vòng lặp khác

Ngoài các vòng lặp thông dụng như `for`, `while`, và `do while`, còn có các vòng lặp khác như `for...in` và `for...of` được sử dụng trong việc duyệt qua các phần tử của **Object** hoặc mảng.

1: `for...in`: Sử dụng để lặp qua các thuộc tính của một **Object**.

- Cú pháp: `for (variable in object) { // code }`

2: `for...of`: Sử dụng để lặp qua các phần tử của một mảng.

- Cú pháp: `for (variable of iterable) { // code }`

## Ví dụ

- `for`: Sử dụng để lặp qua một khối code một số lần đã xác định trước.

- Khi `for` lặp, các biểu thức `initialization`, `condition` và `final-expression` được thực thi theo thứ tự sau:

  1. Thực thi biểu thức `initialization` (thường là khởi tạo một biến đếm).
  2. Kiểm tra điều kiện `condition`. Nếu điều kiện là `true`, thực thi khối code. Nếu điều kiện là `false`, thoát khỏi vòng lặp.
  3. Thực thi biểu thức `final-expression` (thường là tăng biến đếm).
  4. Quay lại bước 2.

<htmlcss-snippet>

```html
<button id="btn">Run code</button>
<ul id="result"></ul>
<script>
	const btn = document.getElementById('btn');
	btn.addEventListener('click', () => {
		const n = prompt('Nhập một số nguyên dương:');
		for (let i = 0; i < n; i++) {
			const result = document.getElementById('result');
			const li = document.createElement('li');
			li.innerText = i;
			result.appendChild(li);
		}
	});
</script>
```

</htmlcss-snippet>

Trong ví dụ trên, chúng ta sử dụng vòng lặp `for` để in ra các số từ 0 đến `n - 1` với `n` là một số nguyên dương được nhập vào từ bàn phím.

---

- `while`: Sử dụng để lặp qua một khối code miễn là một điều kiện được thỏa mãn.

- Khi `while` lặp, điều kiện `condition` được kiểm tra. Nếu điều kiện là `true`, thực thi khối code. Nếu điều kiện là `false`, thoát khỏi vòng lặp.

<htmlcss-snippet>

```html
<button id="btn">Run code</button>

<ul id="result"></ul>

<script>
	const btn = document.getElementById('btn');
	btn.addEventListener('click', () => {
		const n = prompt('Nhập một số nguyên dương:');
		let i = 0;
		while (i < n) {
			const result = document.getElementById('result');
			const li = document.createElement('li');
			li.innerText = i;
			result.appendChild(li);
			i++;
		}
	});
</script>
```

</htmlcss-snippet>

Trong ví dụ trên, chúng ta sử dụng vòng lặp `while` để in ra các số từ 0 đến `n - 1` với `n` là một số nguyên dương được nhập vào từ bàn phím.

---

- `do while`: Sử dụng để lặp qua một khối code ít nhất một lần và sau đó tiếp tục lặp miễn là một điều kiện được thỏa mãn.

- Khi `do while` lặp, điều kiện `condition` được kiểm tra. Nếu điều kiện là `true`, thực thi khối code. Nếu điều kiện là `false`, thoát khỏi vòng lặp.

<htmlcss-snippet>

```html
<button id="btn">Run code</button>

<ul id="result"></ul>

<script>
	const btn = document.getElementById('btn');

	btn.addEventListener('click', () => {
		const n = prompt('Nhập một số nguyên dương:');
		let i = 0;
		do {
			const result = document.getElementById('result');
			const li = document.createElement('li');
			li.innerText = i;
			result.appendChild(li);
			i++;
		} while (i < n);
	});
</script>
```

</htmlcss-snippet>

Trong ví dụ trên, chúng ta sử dụng vòng lặp `do while` để in ra các số từ 0 đến `n - 1` với `n` là một số nguyên dương được nhập vào từ bàn phím.

---

- `for...in`: Sử dụng để lặp qua các thuộc tính của một **Object**.

- Khi `for...in` lặp, các thuộc tính của **Object** được lặp theo thứ tự ngẫu nhiên.

<htmlcss-snippet>

```html
<button id="btn">Run code</button>

<ul id="result"></ul>

<script>
	const btn = document.getElementById('btn');
	const arr = [1, 2, 3, 4, 5];

	btn.addEventListener('click', () => {
		const result = document.getElementById('result');
		for (let i in arr) {
			const li = document.createElement('li');
			li.innerText = arr[i];
			result.appendChild(li);
		}
	});
</script>
```

</htmlcss-snippet>

Trong ví dụ trên, chúng ta sử dụng vòng lặp `for...in` để in ra các phần tử của mảng `arr`.

---

- `for...of`: Sử dụng để lặp qua các phần tử của một mảng.

- Khi `for...of` lặp, các phần tử của mảng được lặp theo thứ tự.

<htmlcss-snippet>

```html
<button id="btn">Run code</button>
<ul id="result"></ul>

<script>
	const btn = document.getElementById('btn');
	const arr = [1, 2, 3, 4, 5];
	btn.addEventListener('click', () => {
		const result = document.getElementById('result');
		for (let i of arr) {
			const li = document.createElement('li');
			li.innerText = i;
			result.appendChild(li);
		}
	});
</script>
```

</htmlcss-snippet>

Trong ví dụ trên, chúng ta sử dụng vòng lặp `for...of` để in ra các phần tử của mảng `arr`.

---

## Phân biệt `for in` và `for of`

| Đặc điểm                           | `for in`                        | `for of`                               |
| ---------------------------------- | ------------------------------- | -------------------------------------- |
| Duyệt                              | Duyệt các thuộc tính            | Duyệt các phần tử                      |
| Loại đối tượng                     | Duyệt Object                    | Duyệt mảng hoặc Object                 |
| Trình tự duyệt                     | Trình tự không xác định         | Trình tự tăng dần                      |
| Khả năng duyệt thuộc tính riêng tư | Có thể duyệt                    | Không thể duyệt                        |
| Hiệu suất                          | Thấp                            | Cao                                    |
| Sử dụng                            | Duyệt các thuộc tính của Object | Duyệt các phần tử của mảng hoặc Object |

`for in` là một cú pháp lặp cổ điển trong JavaScript được sử dụng để duyệt các thuộc tính của một Object. Cú pháp này duyệt tất cả các thuộc tính của Object, bao gồm cả các thuộc tính công khai và thuộc tính riêng tư. Trình tự duyệt của `for in` là không xác định, có nghĩa là các thuộc tính có thể được duyệt theo bất kỳ thứ tự nào. `for in` có hiệu suất thấp hơn `for of` vì nó phải duyệt tất cả các thuộc tính của Object, ngay cả khi các thuộc tính đó không được sử dụng.

`for of` là một cú pháp lặp mới hơn trong JavaScript được sử dụng để duyệt các phần tử của một mảng hoặc Object. Cú pháp này chỉ duyệt các phần tử của mảng hoặc Object, và không duyệt các thuộc tính. Trình tự duyệt của `for of` là tăng dần, có nghĩa là các phần tử được duyệt theo thứ tự tăng dần về chỉ mục. `for of` có hiệu suất cao hơn `for in` vì nó chỉ duyệt các phần tử của mảng hoặc Object, và không phải duyệt các thuộc tính.

Trong hầu hết các trường hợp, chúng ta nên sử dụng `for of` thay vì `for in` để duyệt các phần tử của một mảng hoặc Object. `for of` có hiệu suất cao hơn và dễ đọc hơn.

**Nói rõ hơn về "Trình tự không xác định:"**

Trình tự duyệt không xác định trong `for in` là vì trình duyệt không đảm bảo rằng các thuộc tính của đối tượng sẽ được duyệt theo thứ tự nào. Các thuộc tính có thể được duyệt theo bất kỳ thứ tự nào, và trình duyệt có thể thay đổi thứ tự duyệt bất cứ lúc nào.

Có một số lý do tại sao trình duyệt không đảm bảo thứ tự duyệt. Một lý do là các thuộc tính của đối tượng có thể được thêm hoặc xóa bất cứ lúc nào. Nếu trình duyệt đảm bảo thứ tự duyệt, thì nó sẽ phải cập nhật thứ tự duyệt bất cứ khi nào một thuộc tính được thêm hoặc xóa. Điều này có thể là một quá trình tốn kém, và nó có thể làm chậm hiệu suất của trang web.

Một lý do khác là các thuộc tính của đối tượng có thể được truy cập từ nhiều luồng khác nhau. Nếu trình duyệt đảm bảo thứ tự duyệt, thì nó sẽ phải đảm bảo rằng các luồng khác nhau truy cập các thuộc tính theo cùng một thứ tự. Điều này có thể là một nhiệm vụ phức tạp, và nó có thể làm tăng nguy cơ xảy ra lỗi.

Do những lý do này, trình duyệt không đảm bảo thứ tự duyệt của `for in`. Điều này có nghĩa là các thuộc tính của đối tượng có thể được duyệt theo bất kỳ thứ tự nào, và chúng ta không nên dựa vào bất kỳ thứ tự cụ thể nào.

## Các lưu ý khi làm việc với vòng lặp

1. Sử dụng vòng lặp cần chú ý đến các điều kiện dừng để tránh lặp vô hạn.

2. Sử dụng vòng lặp cần chú ý đến việc quản lý bộ nhớ để tránh tràn bộ nhớ.

3. Sử dụng vòng lặp cần chú ý đến việc quản lý thời gian thực thi để tránh tràn thời gian thực thi.

---

# Áp dụng lệnh `break` và `continue`:

## Lệnh `break` là gì?

- `break`: Sử dụng để thoát khỏi vòng lặp hiện tại hoặc thoát khỏi một khối lệnh vòng lặp.

- Khi `break` được gọi, vòng lặp hiện tại sẽ dừng lại và chương trình sẽ tiếp tục thực thi các câu lệnh sau vòng lặp.

- Khi `break` được gọi trong một khối lệnh vòng lặp, vòng lặp hiện tại sẽ dừng lại và chương trình sẽ tiếp tục thực thi các câu lệnh sau khối lệnh vòng lặp. Hay nói cách khác, `break` sẽ thoát khỏi khối lệnh vòng lặp.

- Khi `break` được gọi trong một switch case, switch case hiện tại sẽ dừng lại và chương trình sẽ tiếp tục thực thi các câu lệnh sau switch case.

- Khi `break` được gọi trong một vòng lặp lồng nhau, vòng lặp lồng bên trong sẽ dừng lại và vòng lặp lồng bên ngoài sẽ tiếp tục thực thi.

## Lệnh `continue` là gì?

- `continue`: Sử dụng để bỏ qua phần còn lại của vòng lặp hiện tại và chuyển đến lần lặp tiếp theo.

- Khi `continue` được gọi, các câu lệnh trong vòng lặp hiện tại sẽ bị bỏ qua và vòng lặp sẽ tiếp tục lặp.

- Khi `continue` được gọi trong một vòng lặp lồng nhau, vòng lặp lồng bên trong sẽ bị bỏ qua và vòng lặp lồng bên ngoài sẽ tiếp tục lặp.

- Khi `continue` được gọi trong một switch case, các câu lệnh trong switch case hiện tại sẽ bị bỏ qua và switch case sẽ tiếp tục thực thi các câu lệnh sau switch case.

## Ví dụ

### Ví dụ về lệnh `break`

- `break`: Sử dụng để thoát khỏi vòng lặp hiện tại hoặc thoát khỏi một khối lệnh vòng lặp.

<htmlcss-snippet>

```html
<button id="btn">Run code</button>

<ul id="result"></ul>

<script>
	const btn = document.getElementById('btn');
	btn.addEventListener('click', () => {
		const n = prompt('Nhập một số nguyên dương:');
		for (let i = 0; i < n; i++) {
			if (i === 3) {
				break;
			}
			const result = document.getElementById('result');
			const li = document.createElement('li');
			li.innerText = i;
			result.appendChild(li);
		}
	});
</script>
```

</htmlcss-snippet>

Trong ví dụ trên, chúng ta sử dụng lệnh `break` để thoát khỏi vòng lặp khi `i` bằng 3.

---

### Ví dụ về lệnh `continue`

- `continue`: Sử dụng để bỏ qua phần còn lại của vòng lặp hiện tại và chuyển đến lần lặp tiếp theo.

<htmlcss-snippet>

```html
<button id="btn">Run code</button>

<ul id="result"></ul>

<script>
	const btn = document.getElementById('btn');
	btn.addEventListener('click', () => {
		const n = prompt('Nhập một số nguyên dương:');
		for (let i = 0; i < n; i++) {
			if (i === 3) {
				continue;
			}
			const result = document.getElementById('result');
			const li = document.createElement('li');
			li.innerText = i;
			result.appendChild(li);
		}
	});
</script>
```

</htmlcss-snippet>

Trong ví dụ trên, chúng ta sử dụng lệnh `continue` để bỏ qua phần còn lại của vòng lặp khi `i` bằng 3.

---

## Các lưu ý khi làm việc với lệnh `break` và `continue`

Sử dụng lệnh `break` và `continue` cần chú ý đến việc quản lý bộ nhớ để tránh tràn bộ nhớ.

Sử dụng lệnh `break` và `continue` cần chú ý đến việc quản lý thời gian thực thi để tránh tràn thời gian thực thi.

Sử dụng lệnh `break` và `continue` giúp kết quả và dữ liệu tránh bị sai sót và thất thoát.

---

6. Thực hành áp dụng các bài tập về vòng lặp:

Thực hành các bài tập thực tế liên quan đến vòng lặp để nắm vững cách sử dụng và ứng dụng chúng vào các tình huống thực tế.

## Đề bài:

Bài tập: Tính tổng các số nguyên tố từ 1 đến n

Tạo hàm `sumPrime` có 1 tham số **n**. Hàm trả ra tổng các số **nguyên tố** từ 1 đến `n`.

Số nguyên tố là số chỉ chia hết cho 1 và chính nó.

## Hướng dẫn:

/\*\*

- Expected
- sumPrime(5) // output: 10;
- sumPrime(10) // output: 17;
  \*/

## Test case

```js
{
    "Tạo hàm sumPrime": () => {
        return new Promise(resolve => {
          assert.equal(typeof sumPrime, "function", "Chưa tìm thấy hàm sumPrime");
            resolve();
        });
    },
    "Hàm sumPrime(n) trả về tổng của các số nguyên tố từ 1 đến n": () => {
        return new Promise(resolve => {
            assert.equal(sumPrime(22), 77, "Hàm sumPrime chưa đúng logic");
            assert.equal(sumPrime(11), 28, "Hàm sumPrime chưa đúng logic");
            resolve();
        });
    },
}
```

## Hướng dẫn giải

code mẫu tối ưu:

```js
function sumPrime(n) {
	let sum = 0;
	let primes = new Array(n + 1).fill(true);
	primes[0] = false;
	primes[1] = false;
	for (let i = 2; i <= n; i++) {
		if (primes[i]) {
			sum += i;
			for (let j = i * i; j <= n; j += i) {
				primes[j] = false;
			}
		}
	}
	return sum;
}

/*
Giải thích code: 
1. Tạo một mảng primes với giá trị ban đầu là true với độ dài là n + 1
2. Gán giá trị false cho primes[0] và primes[1] vì 0 và 1 không phải là số nguyên tố
3. Duyệt qua mảng primes từ 2 đến n
4. Nếu primes[i] là true, thì thêm i vào sum và đánh dấu các bội của i là false
5. Trả về sum
*/

sumPrime(5); // 10
```

Cách khác:

```js
function isPrime(n) {
	if (n < 2) {
		return false;
	}
	for (let i = 2; i <= Math.sqrt(n); i++) {
		if (n % i === 0) {
			return false;
		}
	}
	return true;
}
function sumPrime(n) {
	let sum = 0;
	for (let i = 2; i <= n; i++) {
		if (isPrime(i)) {
			sum += i;
		}
	}
	return sum;
}

/*
Giải thích code:
1. Tạo hàm isPrime để kiểm tra một số có phải là số nguyên tố hay không
2. Nếu n < 2 thì trả về false
3. Duyệt qua các số từ 2 đến căn bậc 2 của n
4. Nếu n chia hết cho i thì trả về false
5. Trả về true
6. Tạo hàm sumPrime để tính tổng các số nguyên tố từ 1 đến n
7. Tạo biến sum để lưu tổng các số nguyên tố
8. Duyệt qua các số từ 2 đến n
9. Nếu số đó là số nguyên tố thì thêm số đó vào sum
10. Trả về sum
*/

sumPrime(5); // 10
```

Cách khác

```js
function sumPrime(n) {
	let sum = 0;
	for (let i = 2; i <= n; i++) {
		let isPrime = true;
		for (let j = 2; j <= Math.sqrt(i); j++) {
			if (i % j === 0) {
				isPrime = false;
				break;
			}
		}
		if (isPrime) {
			sum += i;
		}
	}
	return sum;
}

/*
Giải thích code:
1. Tạo hàm sumPrime để tính tổng các số nguyên tố từ 1 đến n
2. Tạo biến sum để lưu tổng các số nguyên tố
3. Duyệt qua các số từ 2 đến n
4. Tạo biến isPrime để kiểm tra số đó có phải là số nguyên tố hay không
5. Duyệt qua các số từ 2 đến căn bậc 2 của i
6. Nếu i chia hết cho j thì gán isPrime là false và thoát khỏi vòng lặp
7. Nếu isPrime là true thì thêm i vào sum
8. Trả về sum
*/
```

7. **Các kiểu dữ liệu trong JavaScript**:

> Trong JavaScript, có các kiểu dữ liệu cơ bản như số, chuỗi, boolean, null và undefined, cũng như các kiểu dữ liệu phức tạp như **Object** và mảng, và các kiểu dữ liệu đặc biệt như **Symbol**, **function** và **BigInt**.

## Kiểu dữ liệu: Number

**Kiểu dữ liệu số (Number)**: Đại diện cho các **giá trị số**. Có thể là các _số nguyên_, _số thập phân_ hoặc _số âm_.

```javascript
const age = 25;
const price = 9.99;
```

## Kiểu dữ liệu: String

**Kiểu dữ liệu chuỗi (String)**: Đại diện cho các **chuỗi ký tự**. Chuỗi được đặt trong dấu nháy đơn (**''**) hoặc dấu nháy
kép (**""**).

```javascript
const name = 'F8, JavaScript';
const message = 'Hello World!';
```

## Kiểu dữ liệu: Boolean

**Kiểu dữ liệu boolean (Boolean)**: Đại diện cho hai giá trị **true** _(đúng)_ hoặc **false** _(sai)_.

```javascript
const isLogged = true;
const isValid = false;
```

## Kiểu dữ liệu: Null

**Kiểu dữ liệu null**: Đại diện cho giá trị **null**, tức là không có giá trị hoặc không tồn tại **Object**.

```javascript
const user = null;
```

## Kiểu dữ liệu: Undefined

**Kiểu dữ liệu undefined**: Đại diện cho biến **chưa được gán giá trị** hoặc **không tồn tại**.

```javascript
let address;
```

## Kiểu dữ liệu: Object

**Kiểu dữ liệu **Object** (Object)**: Đại diện cho một **Object** chứa nhiều thuộc tính và phương thức. Object được định nghĩa bằng cặp ngoặc nhọn **{}**.

```javascript
const person = {
	name: 'F8 Javascript',
	age: 25,
	isAdmin: false,
};
```

## Kiểu dữ liệu: Array

**Kiểu dữ liệu mảng (Array)**: Đại diện cho một tập hợp các phần tử. Mảng được định nghĩa bằng cặp ngoặc vuông **[]**.

```javascript
const numbers = [1, 2, 3, 4, 5];
const fruits = ['apple', 'banana', 'orange'];
```

---

## Kiểu dữ liệu Symbol

**Kiểu dữ liệu Symbol**: Đại diện cho một **Symbol**. **Symbol** là một giá trị duy nhất không thể thay đổi và được sử dụng làm tên thuộc tính của **Object**.

```javascript
const id = Symbol('id');
const user = {
	[id]: 1,
};
```

---

## Kiểu dữ liệu function

**Kiểu dữ liệu function**: Đại diện cho một **function**. **Function** là một khối mã có thể được gọi bằng cách sử dụng tên của nó.

Một giá trị **function** cũng có thể được bọc trong một `Object`:

```javascript
const sayHello = function () {
	console.log('Hello World!');
};
```

---

## Kiểu dữ liệu BigInt

**Kiểu dữ liệu BigInt**: Đại diện cho các số nguyên lớn hơn `2^53 - 1`. **BigInt** được định nghĩa bằng cách thêm chữ `n` vào cuối một số nguyên.

Một giá trị **BigInt** cũng có thể được bọc trong một `Object`:

```javascript
const bigInt = 1234567890123456789012345678901234567890n;
```

---

## Lưu ý khi làm việc với kiểu dữ liệu

Khi làm việc với các kiểu dữ liệu, hãy nhớ rằng JavaScript là một ngôn ngữ linh hoạt và cho phép chuyển đổi kiểu dữ liệu tự động trong một số trường hợp.

---

8. **Phân biệt sự khác nhau giữa Primitive và Reference Types**:

## Kiểu dữ liệu nguyên thủy (Primitive types)

**Kiểu dữ liệu nguyên thủy (Primitive types)** bao gồm số, chuỗi, boolean, null và undefined. Khi gán giá trị của kiểu dữ liệu nguyên thủy cho biến khác, giá trị được sao chép.

```javascript
let num1 = 10;
let num2 = num1; // Giá trị của num1 được sao chép vào num2
num2 = 20; // num1 không bị ảnh hưởng bởi việc thay đổi giá trị của num2
```

---

## Kiểu dữ liệu tham chiếu (Reference types)

**Kiểu dữ liệu tham chiếu (Reference types)** bao gồm **Object**, mảng và function. Khi gán giá trị của kiểu dữ liệu tham chiếu cho biến khác, tham chiếu đến **Object** được chuyển, không phải giá trị thực tế.

```javascript
let arr1 = [1, 2, 3];
let arr2 = arr1; // arr2 tham chiếu đến cùng một mảng với arr1
arr2.push(4); // Sự thay đổi được áp dụng cho cả arr1 và arr2
```

Khi làm việc với kiểu dữ liệu nguyên thủy, giá trị được sao chép và các biến độc lập với nhau. Một biến không ảnh hưởng đến giá trị của biến khác.

Trong khi đó, khi làm việc với kiểu dữ liệu tham chiếu, giá trị không được sao chép mà chỉ tham chiếu đến **Object** ban đầu. Do đó, khi thay đổi một biến, biến khác cùng tham chiếu sẽ bị ảnh hưởng.

Điều này có ý nghĩa khi thực hiện các thao tác trên mảng và **Object**. Khi một mảng hoặc **Object** được chuyển từ một biến sang biến khác, thì cả hai biến sẽ tham chiếu đến cùng một **Object** trong bộ nhớ.

```javascript
let obj1 = { name: 'F8' };
let obj2 = obj1; // obj2 tham chiếu đến cùng một **Object** với obj1
obj2.name = 'Fullstack'; // Sự thay đổi được áp dụng cho cả obj1 và obj2
```

- Lưu ý: Khi sao chép giá trị của một biến tham chiếu, chỉ sao chép tham chiếu, không phải tạo một bản sao độc lập của **Object**.

Để tạo một bản sao độc lập của một mảng hoặc **Object**, chúng ta có thể sử dụng các phương pháp như `slice()` cho mảng và `Object.assign()` hoặc spread operator (`...`) cho **Object**.

```javascript
let arr1 = [1, 2, 3];
let arr2 = arr1.slice(); // Tạo một bản sao độc lập của mảng arr1
arr2.push(4); // Sự thay đổi chỉ áp dụng cho arr2
```

```javascript
let obj1 = { name: 'F8' };
let obj2 = Object.assign({}, obj1); // Tạo một bản sao độc lập của **Object** obj1
obj2.name = 'Fullstack'; // Sự thay đổi chỉ áp dụng cho obj2
```

```javascript
let obj1 = { name: 'F8' };
let obj2 = { ...obj1 }; // Sử dụng spread operator để tạo một bản sao độc lập của **Object** obj1
obj2.name = 'Fullstack'; // Sự thay đổi chỉ áp dụng cho obj2
```

Việc hiểu và phân biệt giữa kiểu dữ liệu nguyên thủy và kiểu dữ liệu tham chiếu là rất quan trọng khi làm việc với JavaScript để tránh gặp phải những vấn đề liên quan đến tham chiếu và sao chép giá trị.

- **Ví dụ thêm**:

```javascript
let num1 = 10;
let num2 = num1;
num2 = 20;
console.log(num1); // Output: 10
let arr1 = [1, 2, 3];
let arr2 = arr1;
arr2.push(4);
console.log(arr1); // Output: [1, 2, 3, 4]
let obj1 = { name: 'F8' };
let obj2 = obj1;
obj2.name = 'Fullstack';
console.log(obj1); // Output: { name: 'Fullstack' }
```

Ở ví dụ này, chúng ta có một biến `num1` có giá trị là 10. Sau đó, chúng ta gán giá trị của `num1` cho biến `num2`. Khi thay đổi giá trị của `num2`, giá trị của `num1` không bị ảnh hưởng.

Tuy nhiên, khi chúng ta làm tương tự với một mảng hoặc **Object**, thì giá trị của biến ban đầu sẽ bị ảnh hưởng.
